/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 7);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "g", function() { return initOptList; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return d3tsv; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return d3json; });
/* unused harmony export d3text */
/* unused harmony export deepc */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "j", function() { return parseCoords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return formatCoords; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "i", function() { return overlaps; });
/* unused harmony export subtract */
/* unused harmony export obj2list */
/* unused harmony export same */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return getCaretRange; });
/* unused harmony export setCaretRange */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "m", function() { return setCaretPosition; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "h", function() { return moveCaretPosition; });
/* unused harmony export getCaretPosition */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return coordsAfterTransform; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "l", function() { return removeDups; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return clip; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "k", function() { return prettyPrintBases; });

// =============================================
//                    UTILS
// =============================================

// ---------------------------------------------
// (Re-)Initializes an option list.
// Args:
//   selector (string or Node) CSS selector of the container <select> element. Or the element itself.
//   opts (list) List of option data objects. May be simple strings. May be more complex.
//   value (function or null) Function to produce the <option> value from an opts item
//       Defaults to the identity function (x=>x).
//   label (function or null) Function to produce the <option> label from an opts item
//       Defaults to the value function.
//   multi (boolean) Specifies if the list support multiple selections. (default = false)
//   selected (function or null) Function to determine if a given option is selectd.
//       Defaults to d=>False. Note that this function is only applied to new options.
//   sortBy (function) Optional. If provided, a comparison function to use for sorting the options.
//   	 The comparison function is passes the data objects corresponding to two options and should
//   	 return -1, 0 or +1. If not provided, the option list will have the same sort order as the opts argument.
// Returns:
//   The option list in a D3 selection.
function initOptList(selector, opts, value, label, multi, selected, sortBy) {

    // set up the functions
    let ident = d => d;
    value = value || ident;
    label = label || value;
    selected = selected || (x => false);

    // the <select> elt
    let s = d3.select(selector);

    // multiselect
    s.property('multiple', multi || null) ;

    // bind the opts.
    let os = s.selectAll("option")
        .data(opts, label);
    os.enter()
        .append("option") 
        .attr("value", value)
        .property("selected", o => selected(o) || null)
        .text(label) 
        ;
    //
    os.exit().remove() ;

    // sort the results
    if (!sortBy) sortBy = (a,b) => {
    	let ai = opts.indexOf(a);
	let bi = opts.indexOf(b);
	return ai - bi;
    }
    os.sort(sortBy);

    //
    return s;
}

//----------------------------------------------
// Promisifies a call to d3.tsv.
// Args:
//   url (string) The url of the tsv resource
// Returns:
//   a promise that resolves to the list of row objects
function d3tsv(url) {
    return new Promise(function(resolve, reject) {
        d3.tsv(url, function(error, val){
            error ? reject({ status: error.status, statusText: error.statusText}) : resolve(val);
        })  
    }); 
}

//----------------------------------------------
// Promisifies a call to d3.json.
// Args:
//   url (string) The url of the json resource
// Returns:
//   a promise that resolves to the json object value, or rejects with an error
function d3json(url) {
    return new Promise(function(resolve, reject) {
        d3.json(url, function(error, val){
            error ? reject({ status: error.status, statusText: error.statusText}) : resolve(val);
        })  
    }); 
}

//----------------------------------------------
// Promisifies a call to d3.text.
// Args:
//   url (string) The url of the text resource
// Returns:
//   a promise that resolves to the json object value, or rejects with an error
function d3text(url) {
    return new Promise(function(resolve, reject) {
        d3.text(url, 'text/plain', function(error, val){
            error ? reject({ status: error.status, statusText: error.statusText}) : resolve(val);
        })  
    }); 
}

//----------------------------------------------
// Returns a deep copy of object o. 
// Args:
//   o  (object) Must be a JSON object (no curcular refs, no functions).
// Returns:
//   a deep copy of o
function deepc(o) {
    if (!o) return o;
        return JSON.parse(JSON.stringify(o));
}

//----------------------------------------------
// Parses a string of the form "chr:start..end".
// Returns:
//   object contining the parsed fields.
// Example:
//   parseCoords("10:10000000..20000000") -> {chr:"10", start:10000000, end:20000000}
function parseCoords (coords) {
    let re = /([^:]+):(\d+)\.\.(\d+)/;
    let m = coords.match(re);
    return m ? {chr:m[1], start:parseInt(m[2]), end:parseInt(m[3])} : null;
}

//----------------------------------------------
// Formats a chromosome name, start and end position as a string.
// Args (form 1):
//   coords (object) Of the form {chr:string, start:int, end:int}
// Args (form 2):
//   chr string
//   start int
//   end int
// Returns:
//     string
// Example:
//     formatCoords("10", 10000000, 20000000) -> "10:10000000..20000000"
function formatCoords (chr, start, end) {
    if (arguments.length === 1) {
	let c = chr;
	chr = c.chr;
	start = c.start;
	end = c.end;
    }
    return `${chr}:${Math.round(start)}..${Math.round(end)}`
}
//----------------------------------------------
// Returns true iff the two ranges overlap by at least 1.
// Each range must have a chr, start, and end.
//
function overlaps (a, b) {
    return a.chr === b.chr && a.start <= b.end && a.end >= b.start;
}
//----------------------------------------------
// Given two ranges, a and b, returns a - b.
// The result is a list of 0, 1 or 2 new ranges, depending on a and b.
function subtract(a, b) {
    if (a.chr !== b.chr) return [ a ];
    let abLeft = { chr:a.chr, start:a.start,                    end:Math.min(a.end, b.start-1) };
    let abRight= { chr:a.chr, start:Math.max(a.start, b.end+1), end:a.end };
    let ans = [ abLeft, abRight ].filter( r => r.start <= r.end );
    return ans;
}

//----------------------------------------------
// Creates a list of key,value pairs from the obj.
function obj2list (o) {
    return Object.keys(o).map(k => [k, o[k]])    
}

//----------------------------------------------
// Returns true iff the two lists have the same contents (based on indexOf).
// Brute force approach. Be careful where you use this.
function same (alst,blst) {
   return alst.length === blst.length && 
       alst.reduce((acc,x) => (acc && blst.indexOf(x)>=0), true);
}

//---------------------------------------------
// Add basic set ops to Set prototype.
// Lifted from: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Set
Set.prototype.union = function(setB) {
    var union = new Set(this);
    for (var elem of setB) {
        union.add(elem);
    }
    return union;
}

Set.prototype.intersection = function(setB) {
    var intersection = new Set();
    for (var elem of setB) {
        if (this.has(elem)) {
            intersection.add(elem);
        }
    }
    return intersection;
}

Set.prototype.difference = function(setB) {
    var difference = new Set(this);
    for (var elem of setB) {
        difference.delete(elem);
    }
    return difference;
}
// ---------------------------------------------
function getCaretRange (elt) {
    // FIXME: does not work for IE
    return [elt.selectionStart, elt.selectionEnd];
}
function setCaretRange (elt, range) {
    // FIXME: does not work for IE
    elt.selectionStart = range[0];
    elt.selectionEnd   = range[1];
}
function setCaretPosition (elt, pos) {
    setCaretRange(elt, [pos,pos]);
}
function moveCaretPosition (elt, delta) {
    setCaretPosition(elt, getCaretPosition(elt) + delta);
}
function getCaretPosition (elt) {
    let r = getCaretRange(elt);
    return r[1];
}

// ---------------------------------------------
// Returns the screen coordinates of an SVG shape (circle, rect, polygon, line)
// after all transforms have been applied.
//
// Args:
//     shape (node) The SVG shape.
//
// Returns:
//     The form of the returned value depends on the shape.
//     circle:  { cx, cy, r }
//         returns the transformed center point and transformed radius         
//     line:	{ x1, y1, x2, y2 }
//         returns the transformed endpoints
//     rect:	{ x, y, width, height }
//         returns the transformed corner point and transformed width+height.
//     polygon: [ {x,y}, {x,y} , ... ]
//         returns the transformed list of points
//
// Adapted from: https://stackoverflow.com/questions/6858479/rectangle-coordinates-after-transform?rq=1
//
function coordsAfterTransform (shape) {
    //
    let dshape = d3.select(shape);
    let svg = shape.closest("svg");
    if (!svg) return null;
    let stype = shape.tagName.toLowerCase();
    let matrix = shape.getCTM();
    let p = svg.createSVGPoint();
    let p2= svg.createSVGPoint();
    //
    switch (stype) {
    //
    case 'circle':
	p.x  = parseFloat(dshape.attr("cx"));
	p.y  = parseFloat(dshape.attr("cy"));
	p2.x = p.x + parseFloat(dshape.attr("r"));
	p2.y = p.y;
	p    = p.matrixTransform(matrix);
	p2   = p2.matrixTransform(matrix);
	// calc new radius as distance between transformed points
	let dx = Math.abs(p.x - p2.x);
	let dy = Math.abs(p.y - p2.y);
	let r = Math.sqrt(dx*dx + dy*dy);
        return { cx: p.x, cy: p.y, r:r };
    //
    case 'rect':
	// FIXME: does not handle rotations correctly. To fix, translate corner points separately and then
	// calculate the transformed width and height. As a convenience to the user, might be nice to return
	// the transformed corner points and possibly the final angle of rotation.
	p.x  = parseFloat(dshape.attr("x"));
	p.y  = parseFloat(dshape.attr("y"));
	p2.x = p.x + parseFloat(dshape.attr("width"));
	p2.y = p.y + parseFloat(dshape.attr("height"));
	//
	p  = p.matrixTransform(matrix);
	p2 = p2.matrixTransform(matrix);
	//
        return { x: p.x, y: p.y, width: p2.x-p.x, height: p2.y-p.y };
    //
    case 'polygon':
        let pts = dshape.attr("points").trim().split(/ +/);
	return pts.map( pt => {
	    let xy = pt.split(",");
	    p.x = parseFloat(xy[0])
	    p.y = parseFloat(xy[1])
	    p = p.matrixTransform(matrix);
	    return { x: p.x, y: p.y };
	});
    //
    case 'line':
	p.x   = parseFloat(dshape.attr("x1"));
	p.y   = parseFloat(dshape.attr("y1"));
	p2.x  = parseFloat(dshape.attr("x2"));
	p2.y  = parseFloat(dshape.attr("y2"));
	p     = p.matrixTransform(matrix);
	p2    = p2.matrixTransform(matrix);
        return { x1: p.x, y1: p.y, x2: p2.x, x2: p2.y };
    //
    // FIXME: add case 'text'
    //

    default:
	throw "Unsupported node type: " + stype;
    }

}

// ---------------------------------------------
// Removes duplicates from a list while preserving list order.
// Args:
//     lst (list)
// Returns:
//     A processed copy of lst in which any dups have been removed.
function removeDups (lst) {
    let lst2 = [];
    let seen = new Set();
    lst.forEach(x => {
	// remove dups while preserving order
	if (seen.has(x)) return;
	lst2.push(x);
	seen.add(x);
    });
    return lst2;
}

// ---------------------------------------------
// Clips a value to a range.
function clip (n, min, max) {
    return Math.min(max, Math.max(min, n));
}

// ---------------------------------------------
// Returns the given basepair amount "pretty printed" to an apporpriate scale, precision, and units.
// Eg,  
//    127 => '127 bp'
//    123456789 => '123.5 Mb'
function prettyPrintBases (n) {
    let absn = Math.abs(n);
    if (absn < 1000) {
        return `${n} bp`;
    }
    if (absn >= 1000 && absn < 1000000) {
        return `${(n/1000).toFixed(2)} kb`;
    }
    else {
        return `${(n/1000000).toFixed(2)} Mb`;
    }
    return 
}
// ---------------------------------------------
// ---------------------------------------------



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony default export */ __webpack_exports__["a"] = ({
    MGVApp : {
	name :	"Multiple Genome Viewer (MGV)",
	version :	"1.0.0", // use semantic versioning
    },
    FeatureManager : {
        transcriptBlockSize : 2000000
    },
    AuxDataManager : {
	mousemine : 'test',
	allMines : {
	    'dev' : 'http://bhmgimm-dev:8080/mousemine',
	    'test': 'http://test.mousemine.org/mousemine',
	    'public' : 'http://www.mousemine.org/mousemine',
	}
    },
    SVGView : {
	outerWidth : 100,
	width : 100,
	outerHeight : 100,
	height : 100,
	margins : {top: 18, right: 12, bottom: 12, left: 12}
    },
    ZoomView : {
	topOffset : 20,		// Y offset to first strip (should = stripGap, so technically redundant)
	featHeight : 8,		// height of a rectangle representing a feature
	laneGap : 8,	        // space between swim lanes, also defines font size
	laneHeight : 18,	// == featHeight + laneGap
	laneGapMinor : 2,	// space between minor lanes (between transcripts)
	laneHeightMinor : 10,	// == featHeight + laneGapMinor
	minLanes : 3,		// minimum number of swim lanes (each strand)
	blockHeight : 60,	// == 2 * minLanes * laneHeight
	minStripHeight : 75,    // height per genome in the zoom view
	stripGap : 20,	        // space between strips
	maxSBgap : 20,	        // max gap allowed between blocks.
	dmode : 'comparison',   // initial drawing mode. 'comparison' or 'reference'
	wheelThreshold : 3,	// minimum wheel distance 
	featureDetailThreshold : 2000000, // if width <= thresh, draw feature details.
	sequenceDisplayThreshold: 1, // display sequence if pixels per base is at least this
	wheelContextDelay : 300,// ms delay after last wheel event before changing context
    },
    QueryManager : {
	searchTypes : [{
	    method: "featuresByPhenotype",
	    label: "...by phenotype or disease",
	    template: "",
	    placeholder: "Pheno/disease (MP/DO) term or IDs"
	},{
	    method: "featuresByFunction",
	    label: "...by cellular function",
	    template: "",
	    placeholder: "Gene Ontology (GO) terms or IDs"
	},{
	    method: "featuresByPathway",
	    label: "...by pathway",
	    template: "",
	    placeholder: "Reactome pathways names, IDs"
	},{
	    method: "featuresById",
	    label: "...by symbol/ID",
	    template: "",
	    placeholder: "MGI names, synonyms, etc."
	}]
    }
});


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Component; });
// ---------------------------------------------
class Component {
    // app - the owning app object
    // elt - container. may be a string (selector), a DOM node, or a d3 selection of 1 node.
    constructor (app, elt) {
	this.app = app
	if (typeof(elt) === "string")
	    // elt is a CSS selector
	    this.root = d3.select(elt);
	else if (typeof(elt.selectAll) === "function")
	    // elt is a d3 selection
	    this.root = elt;
	else if (typeof(elt.getElementsByTagName) === "function")
	    // elt is a DOM node
	    this.root = d3.select(elt);
    }
    initDom () {
        // override me
    }
}




/***/ }),
/* 3 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return KeyStore; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_idb_keyval__ = __webpack_require__(11);


const DB_NAME_PREFIX = 'mgv-datacache-';

class KeyStore {
    constructor (name) {
	try {
	    this.store = new __WEBPACK_IMPORTED_MODULE_0_idb_keyval__["a" /* Store */](DB_NAME_PREFIX+name, name);
	    this.disabled = false;
	    console.log(`KeyStore: ${DB_NAME_PREFIX+name}`);
	}
	catch (err) {
	    this.store = null;
	    this.disabled = true;
	    this.nullP = Promise.resolve(null);
	    console.log(`KeyStore: error in constructor: ${err} \n Disabled.`)
	}
    }
    get (key) {
	if (this.disabled) 
	    return this.nullP;
        return Object(__WEBPACK_IMPORTED_MODULE_0_idb_keyval__["d" /* get */])(key, this.store);
    }
    del (key) {
	if (this.disabled) 
	    return this.nullP;
        return Object(__WEBPACK_IMPORTED_MODULE_0_idb_keyval__["c" /* del */])(key, this.store);
    }
    set (key, value) {
	if (this.disabled) 
	    return this.nullP;
        return Object(__WEBPACK_IMPORTED_MODULE_0_idb_keyval__["f" /* set */])(key, value, this.store);
    }
    put (key, value) {
        return this.set(key, value);
    }
    keys () {
	if (this.disabled) 
	    return this.nullP;
        return Object(__WEBPACK_IMPORTED_MODULE_0_idb_keyval__["e" /* keys */])(this.store);
    }
    contains (key) {
	if (this.disabled) 
	    return this.nullP;
        return this.get(key).then(x => x !== undefined);
    }
    clear () {
	if (this.disabled) 
	    return this.nullP;
        return Object(__WEBPACK_IMPORTED_MODULE_0_idb_keyval__["b" /* clear */])(this.store);
    }
};




/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Feature; });
class Feature {
    constructor (genome, ID, gffObj) {
	this.genome = genome
	this.chr    = gffObj[0];
	this.start  = gffObj[3];
	this.end    = gffObj[4];
	this.strand = gffObj[6];
        this.type    = gffObj[2];
	let ga = gffObj[8];
        this.biotype = ga['biotype'];
	this.ID      = ID;
	this.canonical = ga['canonical_id'];
        this.symbol  = ga['canonical_symbol'];
	//
	this.transcript_count = ga['transcript_count'] || 0;
	this.transcripts = [];
	this.transcriptsLoaded = false;
    }
    //
    get length () {
        return this.end - this.start + 1;
    }
    //
    get id () {
        return this.canonical || this.ID;
    }
    //
    get label () {
        return this.symbol || this.ID;
    }
    //
    getMungedType () {
	return this.type === "gene" ?
	    this.biotype.indexOf('protein') >= 0 ?
		"protein_coding_gene"
		:
		this.biotype.indexOf("pseudogene") >= 0 ?
		    "pseudogene"
		    :
		    (this.biotype.indexOf("RNA") >= 0 || this.biotype.indexOf("antisense") >= 0) ?
			"ncRNA_gene"
			:
			this.biotype.indexOf("segment") >= 0 ?
			    "gene_segment"
			    :
			    "other_gene"
	    :
	    this.type === "pseudogene" ?
		"pseudogene"
		:
		this.type.indexOf("gene_segment") >= 0 ?
		    "gene_segment"
		    :
		    this.type.indexOf("RNA") >= 0 ?
			"ncRNA_gene"
			:
			this.type.indexOf("gene") >= 0 ?
			    "other_gene"
			    :
			    "other_feature_type";
    }
}




/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ListFormulaParser; });
// ---------------------------------------------
// Parses a list operator expression, eg "(a + b)*c - d"
// Returns an abstract syntax tree.
//     Leaf nodes = list names. They are simple strings.
//     Interior nodes = operations. They look like: {left:node, op:string, right:node}
// 
class ListFormulaParser {
    constructor () {
	this.r_op    = /[+-]/;
	this.r_op2   = /[*]/;
	this.r_ops   = /[()+*-]/;
	this.r_ident = /[a-zA-Z_][a-zA-Z0-9_]*/;
	this.r_qstr  = /"[^"]*"/;
	this.re = new RegExp(`(${this.r_ops.source}|${this.r_qstr.source}|${this.r_ident.source})`, 'g');
	//this.re = /([()+*-]|"[^"]+"|[a-zA-Z_][a-zA-Z0-9_]*)/g
	this._init("");
    }
    _init (s) {
        this.expr = s;
	this.tokens = this.expr.match(this.re) || [];
	this.i = 0;
    }
    _peekToken() {
	return this.tokens[this.i];
    }
    _nextToken () {
	let t;
        if (this.i < this.tokens.length) {
	    t = this.tokens[this.i];
	    this.i += 1;
	}
	return t;
    }
    _expr () {
        let node = this._term();
	let op = this._peekToken();
	if (op === "+" || op === "-") {
	    this._nextToken();
	    node = { left:node, op:op==="+"?"union":"difference", right: this._expr() }
	    return node;
        }               
	else if (op === ")" || op === undefined || op === null)
	    return node;
	else
	    this._error("UNION or INTERSECTION or ) or NULL", op);
    }
    _term () {
        let node = this._factor();
	let op = this._peekToken();
	if (op === "*") {
	    this._nextToken();
	    node = { left:node, op:"intersection", right: this._factor() }
	}
	return node;
    }
    _factor () {
        let t = this._nextToken();
	if (t === "("){
	    let node = this._expr();
	    let nt = this._nextToken();
	    if (nt !== ")") this._error("')'", nt);
	    return node;
	}
	else if (t && (t.startsWith('"'))) {
	    return t.substring(1, t.length-1);
	}
	else if (t && t.match(/[a-zA-Z_]/)) {
	    return t;
	}
	else
	    this._error("EXPR or IDENT", t||"NULL");
	return t;
	    
    }
    _error (expected, saw) {
        throw `Parse error: expected ${expected} but saw ${saw}.`;
    }
    // Parses the string and returns the abstract syntax tree.
    // Throws an exception if there is a syntax error.
    parse (s) {
	this._init(s);
	return this._expr();
    }
    // returns true iff string is syntactically valid
    isValid (s) {
        try {
	    this.parse(s);
	    return true;
	}
	catch (e) {
	    return false;
	}
    }
}




/***/ }),
/* 6 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return SVGView; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Component__ = __webpack_require__(2);



// ---------------------------------------------
class SVGView extends __WEBPACK_IMPORTED_MODULE_1__Component__["a" /* Component */] {
    constructor (app, elt, width, height, margins, rotation, translation) {
        super(app, elt);
        this.svg = this.root.select("svg");
        this.svgMain = this.svg
            .append("g")    // the margin-translated group
            .append("g")	  // main group for the drawing
	    .attr("name","svgmain");
	let c = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].SVGView;
	this.outerWidth = c.outerWidth;
	this.width = c.width;
	this.outerHeight = c.outerHeight;
	this.height = c.height;
	this.margins = Object.assign({}, c.margins);
	this.rotation = 0;
	this.translation = [0,0];
	//
        this.setGeom({width, height, margins, rotation, translation});
    }
    setGeom (cfg) {
        this.outerWidth  = cfg.width       || this.outerWidth;
        this.outerHeight = cfg.height      || this.outerHeight;
        this.margins     = cfg.margins     || this.margins;
	this.rotation    = typeof(cfg.rotation) === "number" ? cfg.rotation : this.rotation;
	this.translation = cfg.translation || this.translation;
        //
        this.width  = this.outerWidth  - this.margins.left - this.margins.right;
        this.height = this.outerHeight - this.margins.top  - this.margins.bottom;
        //
        this.svg.attr("width", this.outerWidth)
              .attr("height", this.outerHeight)
            .select('g[name="svgmain"]')
              .attr("transform", `translate(${this.margins.left},${this.margins.top}) rotate(${this.rotation}) translate(${this.translation[0]},${this.translation[1]})`);
        return this;
    }
    setMargins( tm, rm, bm, lm ) {
	if (arguments.length === 1) {
	    rm = bm = lm = tm;
	}
	else if (arguments.length === 2) {
	    bm = tm;
	    lm = rm;
	}
	else if (arguments.length !== 4)
	    throw "Bad arguments.";
        //
	this.setGeom({top: tm, right: rm, bottom: bm, left: lm});
	//
	return this;
    }
    rotate (deg) {
        this.setGeom({rotation:deg});
	return this;
    }
    translate (dx, dy) {
        this.setGeom({translation:[dx,dy]});
	return this;
    }
    // Args:
    //   the window width
    fitToWidth (width) {
        let r = this.svg[0][0].getBoundingClientRect();
        this.setGeom({width: width - r.x})
	return this;
    }
} // end class SVGView




/***/ }),
/* 7 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MGVApp__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);



// ---------------------------------------------
// ---------------------------------------------
//
// pqstring = Parse qstring. Parses the parameter portion of the URL.
//
function pqstring (qstring) {
    //
    let cfg = {};

    // FIXME: URLSearchParams API is not supported in all browsers.
    // OK for development but need a fallback eventually.
    let prms = new URLSearchParams(qstring);
    let genomes = [];

    // ----- genomes ------------
    let pgenomes = prms.get("genomes") || "";
    // For now, allow "comps" as synonym for "genomes". Eventually, don't support "comps".
    pgenomes = (pgenomes +  " " + (prms.get("comps") || ""));
    //
    pgenomes = Object(__WEBPACK_IMPORTED_MODULE_1__utils__["l" /* removeDups */])(pgenomes.trim().split(/ +/));
    pgenomes.length > 0 && (cfg.genomes = pgenomes);

    // ----- ref genome ------------
    let ref = prms.get("ref");
    ref && (cfg.ref = ref);

    // ----- highlight IDs --------------
    let hls = new Set();
    let hls0 = prms.get("highlight");
    if (hls0) {
	hls0 = hls0.replace(/[ ,]+/g, ' ').split(' ').filter(x=>x);
	hls0.length > 0 && (cfg.highlight = hls0);
    }

    // ----- coordinates --------------
    //
    let chr   = prms.get("chr");
    let start = prms.get("start");
    let end   = prms.get("end");
    chr   && (cfg.chr = chr);
    start && (cfg.start = parseInt(start));
    end   && (cfg.end = parseInt(end));
    //
    let landmark = prms.get("landmark");
    let flank    = prms.get("flank");
    let length   = prms.get("length");
    let delta    = prms.get("delta");
    landmark && (cfg.landmark = landmark);
    flank    && (cfg.flank = parseInt(flank));
    length   && (cfg.length = parseInt(length));
    delta    && (cfg.delta = parseInt(delta));
    //
    // ----- drawing mode -------------
    let dmode = prms.get("dmode");
    dmode && (cfg.dmode = dmode);
    //
    return cfg;
}


// The main program, wherein the app is created and wired to the browser. 
//
function __main__ (selector) {
    // Behold, the MGV application object...
    let mgv = null;

    // Callback to pass into the app to register changes in context.
    // Uses the current app context to set the hash part of the
    // browser's location. This also registers the change in 
    // the browser history.
    function setHash () {
	let newHash = mgv.getParamString();
	if ('#'+newHash === window.location.hash)
	    return;
	// temporarily disable popstate handler
	let f = window.onpopstate;
	window.onpopstate = null;
	// now set the hash
	window.location.hash = newHash;
	// re-enable
	window.onpopstate = f;
    }
    // Handler called when user clicks the browser's back or forward buttons.
    // Sets the app's context based on the hash part of the browser's
    // location.
    window.onpopstate = function(event) {
	let cfg = pqstring(document.location.hash.substring(1));
	mgv.setContext(cfg, true);
    };
    // get initial set of context params 
    let qstring = window.location.hash.substring(1);
    let cfg = pqstring(qstring);
    cfg.width = window.innerWidth;
    cfg.oncontextchange = setHash;

    // create the app
    window.mgv = mgv = new __WEBPACK_IMPORTED_MODULE_0__MGVApp__["a" /* MGVApp */](selector, cfg);
    
    // handle resize events
    window.onresize = () => {mgv.resize();mgv.setContext({});}
}


__main__("#mgv");


/***/ }),
/* 8 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return MGVApp; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Genome__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__Component__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__FeatureManager__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__QueryManager__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__ListManager__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__ListEditor__ = __webpack_require__(17);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__FacetManager__ = __webpack_require__(18);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__BTManager__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__GenomeView__ = __webpack_require__(22);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__FeatureDetails__ = __webpack_require__(23);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__ZoomView__ = __webpack_require__(24);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__KeyStore__ = __webpack_require__(3);















// ---------------------------------------------
class MGVApp extends __WEBPACK_IMPORTED_MODULE_3__Component__["a" /* Component */] {
    constructor (selector, cfg) {
	super(null, selector);
	this.globalConfig = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */];
	console.log(__WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */]);
	this.app = this;
	this.name = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].MGVApp.name;
	this.version = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].MGVApp.version;
	//
	this.initialCfg = cfg;
	//
	this.contextChanged = (cfg.oncontextchange || function(){});
	//
	this.name2genome = {};  // map from genome name -> genome data obj
	this.label2genome = {}; // map from genome label -> genome data obj
	this.nl2genome = {};    // combines indexes
	//
	this.allGenomes = [];   // list of all available genomes
	this.rGenome = null;    // the current reference genome
	this.cGenomes = [];     // current comparison genomes (rGenome is *not* included).
	this.vGenomes = [];	// list of all currenty viewed genomes (ref+comps) in Y-order.
	//
	this.dur = 250;         // animation duration, in ms
	this.defaultZoom = 2;	// multiplier of current range width. Must be >= 1. 1 == no zoom.
				// (zooming in uses 1/this amount)
	this.defaultPan  = 0.15;// fraction of current range width
	this.currListIndex = {};
	this.currListCounter = 0;


	// Coordinates may be specified in one of two ways: mapped or landmark. 
	// Mapped coordinates are specified as chromosome+start+end. This coordinate range is defined relative to 
	// the current reference genome, and is mapped to the corresponding range(s) in each comparison genome.
	// Landmark coordinates are specified as landmark+[flank|width]+delta. The landmark is looked up in each 
	// genome. Its coordinates, combined with flank|length and delta, determine the absolute coordinate range
	// in that genome. If the landmark does not exist in a given genome, then mapped coordinate are used.
	// 
	this.cmode = 'mapped' // 'mapped' or 'landmark'
	this.coords = { chr: '1', start: 1000000, end: 10000000 };  // mapped
	this.lcoords = { landmark: 'Pax6', flank: 500000, delta:0 };// landmark

	this.initDom();

	//
	//
	this.genomeView = new __WEBPACK_IMPORTED_MODULE_10__GenomeView__["a" /* GenomeView */](this, '#genomeView', 800, 250);
	this.zoomView   = new __WEBPACK_IMPORTED_MODULE_12__ZoomView__["a" /* ZoomView */]  (this, '#zoomView', 800, 250, this.coords);
	this.resize();
        //
	this.featureDetails = new __WEBPACK_IMPORTED_MODULE_11__FeatureDetails__["a" /* FeatureDetails */](this, '#featureDetails');

	// Categorical color scale for feature types
	this.cscale = d3.scale.category10().domain([
	    'protein_coding_gene',
	    'pseudogene',
	    'ncRNA_gene',
	    'gene_segment',
	    'other_gene',
	    'other_feature_type'
	]);
	//
	//
	this.listManager    = new __WEBPACK_IMPORTED_MODULE_6__ListManager__["a" /* ListManager */](this, "#mylists");
	this.listManager.ready.then( () => this.listManager.update() );
	//
	this.listEditor = new __WEBPACK_IMPORTED_MODULE_7__ListEditor__["a" /* ListEditor */](this, '#listeditor');
	//
	this.queryManager = new __WEBPACK_IMPORTED_MODULE_5__QueryManager__["a" /* QueryManager */](this, "#findGenesBox");
	// 
	this.translator     = new __WEBPACK_IMPORTED_MODULE_9__BTManager__["a" /* BTManager */](this);
	this.featureManager = new __WEBPACK_IMPORTED_MODULE_4__FeatureManager__["a" /* FeatureManager */](this);
	//
	this.userPrefsStore = new __WEBPACK_IMPORTED_MODULE_13__KeyStore__["a" /* KeyStore */]("user-preferences");
	
	//
	// -------------------------------------------------------------------
	// Facets
	// -------------------------------------------------------------------
	//
	this.facetManager = new __WEBPACK_IMPORTED_MODULE_8__FacetManager__["a" /* FacetManager */](this);
	let self = this;

	// Feature-type facet
	let ftFacet  = this.facetManager.addFacet("FeatureType", f => f.getMungedType());
	this.initFeatTypeControl(ftFacet);

	// Has-MGI-id facet
	let mgiFacet = this.facetManager.addFacet("HasCanonicalId",    f => f.canonical  ? "yes" : "no" );
	d3.selectAll('input[name="mgiFacet"]').on("change", function(){
	    mgiFacet.setValues(this.value === "" ? [] : [this.value]);
	    self.zoomView.highlight();
	});

	// Is-in-current-list facet
	let inCurrListFacet = this.facetManager.addFacet("InCurrList", f => {
	    return this.currListIndex[f.id] ? "yes" : "no";
	});
	d3.selectAll('input[name="inCurrListFacet"]').on("change", function(){
	    inCurrListFacet.setValues(this.value === "" ? [] : [this.value]);
	    self.zoomView.highlight();
	});

	// Is-highlighted facet
	let hiFacet = this.facetManager.addFacet("IsHi", f => {
	    let ishi = this.zoomView.hiFeats[f.id] || this.currListIndex[f.id];
	    return ishi ? "yes" : "no";
	});
	d3.selectAll('input[name="hiFacet"]').on("change", function(){
	    hiFacet.setValues(this.value === "" ? [] : [this.value]);
	    self.zoomView.highlight();
	});


	//
	this.setUIFromPrefs();

	// ------------------------------
	// ------------------------------

	// Things are all wired up. Now let's get some data.
	// Start with the file of all the genomes.
	this.checkTimestamp().then( () => {
	    Object(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* d3tsv */])("./data/allGenomes.tsv").then(data => {
		// create Genome objects from the raw data.
		this.allGenomes   = data.map(g => new __WEBPACK_IMPORTED_MODULE_2__Genome__["a" /* Genome */](g));
		this.allGenomes.sort( (a,b) => {
		    return a.label < b.label ? -1 : a.label > b.label ? +1 : 0;
		});
		//
		// build a name->Genome index
		this.nl2genome = {}; // also build the combined list at the same time...
		this.name2genome  = this.allGenomes
		    .reduce((acc,g) => { this.nl2genome[g.name] = acc[g.name] = g; return acc; }, {});
		// build a label->Genome index
		this.label2genome = this.allGenomes
		    .reduce((acc,g) => { this.nl2genome[g.label] = acc[g.label] = g; return acc; }, {});

		// Now preload all the chromosome files for all the genomes
		let cdps = this.allGenomes.map(g => Object(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* d3tsv */])(`./data/${g.name}/chromosomes.tsv`));
		return Promise.all(cdps);
	    })
	    .then( data => {

		//
		this.processChromosomes(data);
		this.initDomPart2();
		//
		// FINALLY! We are ready to draw the initial scene.
		this.setContext(this.initialCfg);

	    });
	});
    }
    //----------------------------------------------
    checkTimestamp () {
        let tStore = new __WEBPACK_IMPORTED_MODULE_13__KeyStore__["a" /* KeyStore */]('timestamp');
	return Object(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* d3tsv */])('./data/TIMESTAMP.tsv').then( ts => {
	    let newTimeStamp =  new Date(Date.parse(ts[0].TIMESTAMP));
	    return tStore.get('TIMESTAMP').then( oldTimeStamp => {
	        if (!oldTimeStamp || newTimeStamp > oldTimeStamp) {
		    tStore.put('TIMESTAMP',newTimeStamp);
		    return this.clearCachedData();
		}
	    })
	});
    }
    //----------------------------------------------
    // 
    initDom () {
	self = this;
	this.root = d3.select('#mgv');
	
	d3.select('#header label')
	    .text(this.name)
	    ;
	d3.select('#version')
	    .text('version ' + this.version)
	    ;
	//
	// TODO: refactor pagebox, draggable, and friends into a framework module,
	// 
	this.pbDragger = this.getContentDragger();
	// Add busy icon, currently invisibe.
	d3.selectAll('.pagebox')
	    .append('i')
		.attr('class','material-icons busy rotating')
	    ;
	//
	// If a pagebox has title text, append a help icon to the label and move the text there
	d3.selectAll('.pagebox[title]')
	    .append('i')
	        .attr('class', 'material-icons button help')
	        .attr('title', function(){
		    let p = d3.select(this.parentNode);
		    let t = p.attr('title');
		    p.attr('title', null);
		    return t;
		})
		.on('click', function() {
		    self.showStatus(d3.select(this).attr('title'), d3.event.clientX, d3.event.clientY);
		})
		;
	// 
	// Add open/close button to closables and wire them up.
	d3.selectAll('.closable')
	    .append('i')
		.attr('class','material-icons button close')
		.attr('title','Click to open/close.')
		.on('click.default', function () {
		    let p = d3.select(this.parentNode);
		    p.classed('closed', ! p.classed('closed'));
		    d3.select(this).attr('title','Click to ' +  (p.classed('closed') ? 'open' : 'close') + '.')
		    self.setPrefsFromUI();
		});
	//
	// Set up draggables.
	d3.selectAll('.content-draggable > *')
	    .append('i')
		.attr('title','Drag up/down to reposition.')
		.attr('class','material-icons button draghandle')
		.on('mouseenter', function(){
		    // Attach the drag behavior when the user mouses over the drag handle, and remove the behavior
		    // when user mouses out. Why do it this way? Because if the drag behavior stays on all the time,
		    // the user cannot select any text within the box.
		    let pb = this.closest('.pagebox');
		    if (!pb) return;
		    d3.select(pb).call(self.pbDragger);
		})
		.on('mouseleave', function(){
		    let pb = this.closest('.pagebox');
		    if (!pb) return;
		    d3.select(pb).on('.drag',null);
		});

	// 
        d3.select('#statusMessage')
	    .on('click', () => { this.showStatus(false); });
	
	//
	// Button: Gear icon to show/hide left column
	d3.select("#header > .gear.button")
	    .on("click", () => {
	        let lc = this.root.select('[name="leftcolumn"]');
		lc.classed("closed", () => ! lc.classed("closed"));
		window.setTimeout(()=>{
		    this.resize()
		    this.setContext({});
		    this.setPrefsFromUI();
		}, 250);
	    });
	/*
	// Display Settings Controls
	d3.selectAll('#settings .setting input')
	    .on('click', function () {
	        let v = parseInt(this.value);
		let n = this.attributes['name'].value;
		self.zoomView[n] = v;
	    });
	*/
    }
    //----------------------------------------------
    // Dom initializtion that must wait until after genome meta data is loaded.
    initDomPart2 () {
	//
	let cfg = this.sanitizeCfg(this.initialCfg);
	let self = this;

	// initialize the ref and comp genome option lists
	Object(__WEBPACK_IMPORTED_MODULE_1__utils__["g" /* initOptList */])("#refGenome",   this.allGenomes, g=>g.name, g=>g.label, false, g => g === cfg.ref);
	Object(__WEBPACK_IMPORTED_MODULE_1__utils__["g" /* initOptList */])("#compGenomes", this.allGenomes, g=>g.name, g=>g.label, true,  g => cfg.genomes.indexOf(g) !== -1);
	d3.select("#refGenome").on("change", function() {
	    self.setContext({ ref: this.value });
	});
	d3.select("#compGenomes").on("change", function() {
	    let selectedNames = [];
	    for(let x of this.selectedOptions){
		selectedNames.push(x.value);
	    }
	    // want to preserve current genome order as much as possible 
	    let gNames = self.vGenomes.map(g=>g.name)
		.filter(n => {
		    return selectedNames.indexOf(n) >= 0 || n === self.rGenome.name;
		});
	    gNames = gNames.concat(selectedNames.filter(n => gNames.indexOf(n) === -1));
	    self.setContext({ genomes: gNames });
	});
	Object(__WEBPACK_IMPORTED_MODULE_1__utils__["d" /* d3tsv */])("./data/genomeSets.tsv").then(sets => {
	    // Create selection buttons.
	    sets.forEach( s => s.genomes = s.genomes.split(",") );
	    let cgb = d3.select('#compGenomesBox').selectAll('button').data(sets);
	    cgb.enter().append('button')
		.text(d=>d.name)
		.attr('title', d=>d.description)
		.on('click', d => {
		    self.setContext(d);
		})
		;
	}).catch(()=>{
	    console.log("No genomeSets file found.");
	}); // OK if no genomeSets file

    }
    //----------------------------------------------
    processChromosomes (data) {
	// data is a list of chromosome lists, one per genome
	// Fill in the genomeChrs map (genome -> chr list)
	this.allGenomes.forEach((g,i) => {
	    // nicely sort the chromosomes
	    let chrs = data[i];
	    g.maxlen = 0;
	    chrs.forEach( c => {
		//
		c.length = parseInt(c.length)
		g.maxlen = Math.max(g.maxlen, c.length);
		// because I'd rather say "chromosome.name" than "chromosome.chromosome"
		c.name = c.chromosome;
		delete c.chromosome;
	    });
	    // nicely sort the chromosomes
	    chrs.sort((a,b) => {
		let aa = parseInt(a.name) - parseInt(b.name);
		if (!isNaN(aa)) return aa;
		return a.name < b.name ? -1 : a.name > b.name ? +1 : 0;
	    });
	    g.chromosomes = chrs;
	});
    }
    //----------------------------------------------
    getContentDragger () {
      let self = this;
      // Helper function for the drag behavior. Reorders the contents based on
      // current screen position of the dragged item.
      function reorderByDom() {
	  // Locate the sib whose position is beyond the dragged item by the least amount
	  let dr = self.dragging.getBoundingClientRect();
	  let bSib = null;
	  let xy = d3.select(self.dragParent).classed("flexrow") ? "x" : "y";
	  for (let s of self.dragSibs) {
	      let sr = s.getBoundingClientRect();
	      if (dr[xy] < sr[xy]) {
		   let dist = sr[xy] - dr[xy];
		   if (!bSib || dist < bSib[xy] - dr[xy])
		       bSib = s;
	      }
	  }
	  // Insert the dragged item before the located sib (or append if no sib found)
	  self.dragParent.insertBefore(self.dragging, bSib);
      }
      function reorderByStyle() {
	  let dd = d3.select(self.dragging);
	  // Locate the sib that contains the dragged item's origin.
	  let dr = self.dragging.getBoundingClientRect();
	  let bSib = null;
	  let xy = d3.select(self.dragParent).classed("flexrow") ? "x" : "y";
	  let sz = xy === "x" ? "width" : "height";
	  let sty= xy === "x" ? "left" : "top";
	  for (let s of self.dragSibs) {
	      // skip the dragged item
	      if (s === self.dragging) continue;
	      let ds = d3.select(s);
	      let sr = s.getBoundingClientRect();
	      // ifw the dragged item's origin is between the start and end of sib, we found it.
	      if (dr[xy] >= sr[xy] && dr[xy] <= (sr[xy] + sr[sz])) {
		   // move sib toward the hole, amount = the size of the hole
		   let amt = self.dragHole[sz] * (self.dragHole[xy] < sr[xy] ? -1 : 1);
		   ds.style(sty, parseInt(ds.style(sty)) + amt + "px");
		   self.dragHole[xy] -= amt;
                   break;
	      }
	  }
      }
      //
      return d3.behavior.drag()
	  .origin(function(d,i){
	      return this.getBoundingClientRect();
	  })
          .on("dragstart.m", function() {
	      let t = d3.event.sourceEvent.target;
	      if (! d3.select(t).classed("draghandle")) return;
	      d3.event.sourceEvent.stopPropagation();
	      //
	      self.dragging    = this.closest(".pagebox");
	      self.dragHole    = self.dragging.getBoundingClientRect();
	      self.dragParent  = self.dragging.parentNode;
	      self.dragSibs    = self.dragParent.children;
	      //
	      d3.select(self.dragging).classed("dragging", true);
	  })
	  .on("drag.m", function () {
	      if (!self.dragging) return;
	      let dd = d3.select(self.dragging);
	      let tp = parseInt(dd.style("top"))
	      dd.style("top", tp + d3.event.dy + "px");
	      //reorderByStyle();
	  })
	  .on("dragend.m", function () {
	      if (!self.dragging) return;
	      reorderByDom();
	      self.setPrefsFromUI();
	      let dd = d3.select(self.dragging);
	      dd.style("top", "0px");
	      dd.classed("dragging", false);
	      self.dragging    = null;
	      self.dragHole    = null;
	      self.dragParent  = null;
	      self.dragSibs    = null;
	  })
	  ;
    }
    //----------------------------------------------
    setUIFromPrefs () {
	this.userPrefsStore.get("prefs").then( prefs => {
	    prefs = prefs || {};
	    console.log("Got prefs from storage", prefs);

	    // set open/closed states
	    (prefs.closables || []).forEach( c => {
		let id = c[0];
		let state = c[1];
		d3.select('#'+id).classed('closed', state === "closed" || null);
	    });

	    // set draggables' order
	    (prefs.draggables || []).forEach( d => {
		let ctrId = d[0];
		let contentIds = d[1];
		let ctr = d3.select('#'+ctrId);
		let contents = ctr.selectAll('#'+ctrId+' > *');
		contents[0].sort( (a,b) => {
		    let ai = contentIds.indexOf(a.getAttribute('id'));
		    let bi = contentIds.indexOf(b.getAttribute('id'));
		    return ai === -1 ? 1 : bi === -1 ? -1 : ai - bi;
		});
		contents.order();
	    });
	});
    }
    setPrefsFromUI () {
        // save open/closed states
	let closables = this.root.selectAll('.closable');
	let ocData = closables[0].map( c => {
	    let dc = d3.select(c);
	    return [dc.attr('id'), dc.classed("closed") ? "closed" : "open"];
	});
	// save draggables' order
	let dragCtrs = this.root.selectAll('.content-draggable');
	let draggables = dragCtrs.selectAll('.content-draggable > *');
	let ddData = draggables.map( (d,i) => {
	    let ctr = d3.select(dragCtrs[0][i]);
	    return [ctr.attr('id'), d.map( dd => d3.select(dd).attr('id'))];
	});
	let prefs = {
	    closables: ocData,
	    draggables: ddData
	}
	console.log("Saving prefs to storage", prefs);
	this.userPrefsStore.set("prefs", prefs);
    }
    //----------------------------------------------
    showBlocks (comp) {
	let ref = this.rGenome;
	if (! comp) comp = this.cGenomes[0];
	if (! comp) return;
	this.translator.ready().then( () => {
	    let blocks = comp === ref ? [] : this.translator.getBlocks(ref, comp);
	    this.genomeView.drawBlocks({ ref, comp, blocks });
	});
    }
    //----------------------------------------------
    showBusy (isBusy, message) {
        d3.select("#header > .gear.button")
	    .classed("rotating", isBusy);
        d3.select("#zoomView").classed("busy", isBusy);
	if (isBusy && message) this.showStatus(message);
	if (!isBusy) this.showStatus('')
    }
    //----------------------------------------------
    showingStatus () {
        return d3.select('#statusMessage').classed('showing');
    }

    //----------------------------------------------
    showStatus (msg, nearX, nearY) {
	let bb = this.root.node().getBoundingClientRect();
	let _ = (n, len, nmax) => {
	    if (n === undefined)
	        return '50%';
	    else if (typeof(n) === 'string')
	        return n;
	    else if ( n + len < nmax ) {
	        return n + 'px';
	    }
	    else {
	        return (nmax - len) + 'px';
	    }
	};
	nearX = _(nearX, 250, bb.width);
	nearY = _(nearY, 150, bb.height);
	if (msg)
	    d3.select('#statusMessage')
		.classed('showing', true)
		.style('left', nearX)
		.style('top',  nearY)
		.select('span')
		    .text(msg);
	else
	    d3.select('#statusMessage').classed('showing', false);
    }

    //----------------------------------------------
    setRefGenomeSelection () {
	d3.selectAll("#refGenome option")
	    .property("selected",  gg => (gg.label === this.rGenome.label  || null));
    }
    //----------------------------------------------
    setCompGenomesSelection () {
	let cgns = this.vGenomes.map(g=>g.label);
	d3.selectAll("#compGenomes option")
	        .property("selected",  gg => cgns.indexOf(gg.label) >= 0);
    }
    //----------------------------------------------
    // Sets or returns
    setHighlight (flist) {
	if (!flist) return false;
	this.zoomView.hiFeats = flist.reduce((a,v) => { a[v]=v; return a; }, {});
	return true;
    }
    //----------------------------------------------
    // Returns the current context as an object.
    // Current context = ref genome + comp genomes + current range (chr,start,end)
    getContext () {
	if (this.cmode === 'mapped') {
	    let c = this.coords;
	    return {
		ref : this.rGenome.label,
		genomes: this.vGenomes.map(g=>g.label),
		chr: c.chr,
		start: c.start,
		end: c.end,
		highlight: Object.keys(this.zoomView.hiFeats).sort(),
		dmode: this.zoomView.dmode
	    }
	} else {
	    let c = this.lcoords;
	    return {
		ref : this.rGenome.label,
		genomes: this.vGenomes.map(g=>g.label),
		landmark: c.landmark,
		flank: c.flank,
		length: c.length,
		delta: c.delta,
		highlight: Object.keys(this.zoomView.hiFeats).sort(),
		dmode: this.zoomView.dmode
	    }
	}
    }
    //----------------------------------------------
    // Resolves the specified landmark to a feature and the list of equivalent feaures.
    // May be given an id, canonical id, or symbol.
    // Args:
    //     cfg (obj) Sanitized config object, with a landmark (string) field.
    // Returns:
    //     The cfg object, with additional fields:
    //        landmarkRefFeat: the landmark (Feature obj) in the ref genome
    //        landmarkFeats: [ equivalent features in each genome (includes rf)]
    //     Also, changes ref to be the genome of the landmarkRefFeat
    //     Returns null if landmark not found in any genome.
    // 
    resolveLandmark (cfg) {
	let rf, feats;
	// Find the landmark feature in the ref genome. 
	rf = this.featureManager.getCachedFeaturesByLabel(cfg.landmark, cfg.ref)[0];
	if (!rf) {
	    // Landmark does not exist in ref genome. Does it exist in any specified genome?
	    rf = this.featureManager.getCachedFeaturesByLabel(cfg.landmark).filter(f => cfg.genomes.indexOf(f.genome) >= 0)[0];
	    if (rf) {
	        cfg.ref = rf.genome;
	    }
	    else {
	        // Landmark cannot be resolved.
		return null;
	    }
	}
	// landmark exists in ref genome. Get equivalent feat in each genome.
	feats = rf.canonical ? this.featureManager.getCachedFeaturesByCanonicalId(rf.canonical) : [rf];
	cfg.landmarkRefFeat = rf;
	cfg.landmarkFeats = feats.filter(f => cfg.genomes.indexOf(f.genome) >= 0);
	return cfg;
    }
    //----------------------------------------------
    // Returns a sanitized version of the argument configuration object.
    // The sanitized version:
    //     - has a setting for every parameter. Parameters not specified in 
    //       the argument are (generally) filled in with their current values.
    //     - is always valid, eg
    //     	- has a list of 1 or more valid genomes, with one of them designated as the ref
    //     	- has a valid coordinate range
    //     	    - start and end are integers with start <= end
    //     	    - valid chromosome for ref genome
    //
    // The sanitized version is also "compiled":
    //     - it has actual Genome objects, where the argument just has names
    //     - groups the chr+start+end in "coords" object
    //
    //
    sanitizeCfg (c) {
	let cfg = {};

	// Sanitize the input.

	// window size -----------------------------------------------------------------
	if (c.width) {
	    cfg.width = c.width
	}

	// ref genome ------------------------------------------------------------------
	//
	// Set cfg.ref to specified genome, 
	//   with fallback to current ref genome, 
	//      with fallback to C57BL/6J (1st time thru)
	// FIXME: final fallback should be a config setting.
	cfg.ref = (c.ref ? this.nl2genome[c.ref] || this.rGenome : this.rGenome) || this.nl2genome['C57BL/6J'];

	// comparison genomes ----------------------------------------------------------
	// Set cfg.genomes to be the specified genomes,
	//     with fallback to the current genomes
	//        with fallback to [ref] (1st time thru)
	cfg.genomes = c.genomes ?
	    (c.genomes.map(g => this.nl2genome[g]).filter(x=>x))
	    :
	    this.vGenomes;
	// Add ref to genomes if not there already
	if (cfg.genomes.indexOf(cfg.ref) === -1)
	    cfg.genomes.unshift(cfg.ref);
	
	// absolute coordinates -----------------------------------------------------------------
	//
	// Set cfg.chr to be the specified chromosome
	//     with fallback to the current chr
	//         with fallback to the 1st chromosome in the ref genome
	cfg.chr = cfg.ref.getChromosome(c.chr);
	if (!cfg.chr) cfg.chr = cfg.ref.getChromosome( this.coords ? this.coords.chr : "1" );
	if (!cfg.chr) cfg.chr = cfg.ref.getChromosome(0);
	if (!cfg.chr) throw "No chromosome."
	
	// Set cfg.start to be the specified start with fallback to the current start
	// Clip at chr boundaries
	cfg.start = Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* clip */])(Math.round(typeof(c.start) === "number" ? c.start : this.coords.start), 1, cfg.chr.length);

	// Set cfg.end to be the specified end with fallback to the current end
	// Clip at chr boundaries
	cfg.end = Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* clip */])(Math.round(typeof(c.end) === "number" ? c.end : this.coords.end), 1, cfg.chr.length);

	// Ensure start <= end
	if (cfg.start > cfg.end) {
	   let tmp = cfg.start; cfg.start = cfg.end; cfg.end = tmp;
	}

	// landmark coordinates --------------------------------------------------------
	// NOTE that landmark coordinate cannot be fully resolved to absolute coordinate until
	// *after* genome data have been loaded. See setContext and resolveLandmark methods.
	cfg.landmark = c.landmark || this.lcoords.landmark;
	cfg.delta    = Math.round('delta' in c ? c.delta : (this.lcoords.delta || 0));
	if (typeof(c.flank) === 'number'){
	    cfg.flank = Math.round(c.flank);
	}
	else if ('length' in c) {
	    cfg.length = Math.round(c.length);
	}
	else {
	    cfg.length = Math.round(this.coords.end - this.coords.start + 1);
	}

	// cmode -----------------------------------------------------------------------
	if (c.cmode && c.cmode !== 'mapped' && c.cmode !== 'landmark') c.cmode = null;
	cfg.cmode = c.cmode || 
	    (('chr' in c || 'start' in c || 'end' in c) ?
	        'mapped' : 
		('landmark' in c || 'flank' in c || 'length' in c || 'delta' in c) ?
		    'landmark' : 
		    this.cmode || 'mapped');

	// highlighting ----------------------------------------------------------------
	// Set cfg.highlight
	//    with fallback to current highlight
	//        with fallback to []
	cfg.highlight = c.highlight || this.zoomView.highlighted || [];

	// drawing mode ----------------------------------------------------------------
	// Set the drawing mode for the ZoomView.
	//     with fallback to the current value
	if (c.dmode === 'comparison' || c.dmode === 'reference') 
	    cfg.dmode = c.dmode;
	else
	    cfg.dmode = this.zoomView.dmode || 'comparison';

	//
	return cfg;
    }

    //----------------------------------------------
    // Sets the current context from the config object. 
    // Only those context items specified in the config are affected, except as noted.
    //
    // All configs are sanitized before being applied (see sanitizeCfg).
    // 
    // Args:
    //    c (object) A configuration object that specifies some/all config values.
    //         The possible config items:
    //            genomes   (list o strings) All the genomes you want to see, in top-to-bottom order. 
    //               May use internal names or display labels, eg, "mus_musculus_129s1svimj" or "129S1/SvImJ".
    //            ref       (string) The genome to use as the reference. May be name or label.
    //            highlight (list o strings) IDs of features to highlight
    //            dmode     (string) either 'comparison' or 'reference'
    //
    //            Coordinates are specified in one of 2 forms.
    //              chr       (string) Chromosome for coordinate range
    //              start     (int) Coordinate range start position
    //              end       (int) Coordinate range end position
    //
    //              Displays this coordinate range from the current reference geneoms, and the equivalent (mapped)
    //              coordinate range(s) in each comparison genome.
    //
    //            or:
    //              landmark  (string) ID, canonical ID, or symbol, identifying a feature.
    //              flank|length (int) If flank, viewing region size = flank + len(landmark) + flank. 
    //                 If length, viewing region size = length. In either case, the landmark is centered in
    //                 the viewing area, +/- any specified delta.
    //              delta     (int) Amount in bp to shift the region left (<0) or right (>0).
    //
    //              Displays the region around the specified landmark in each genome where it exists.
    //
    //    quietly (boolean) If true, don't update browser history (as when going back)
    //
    // Returns:
    //    Nothing
    // Side effects:
    //	  Redraws 
    //	  Calls contextChanged() 
    //
    setContext (c, quietly) {
        let cfg = this.sanitizeCfg(c);
	//console.log("Set context (raw):", c);
	//console.log("Set context (sanitized):", cfg);
	if (!cfg) return;
	this.showBusy(true, 'Requesting data...');
	let p = this.featureManager.loadGenomes(cfg.genomes).then(() => {
	    if (cfg.cmode === 'landmark') {
	        cfg = this.resolveLandmark(cfg);
		if (!cfg) {
		    alert("Landmark does not exist in current reference genome. Please change the reference genome and try again.");
		    this.showBusy(false);
		    return;
		}
	    }
	    this.vGenomes = cfg.genomes;
	    this.rGenome  = cfg.ref;
	    this.cGenomes = cfg.genomes.filter(g => g !== cfg.ref);
	    this.setRefGenomeSelection(this.rGenome.name);
	    this.setCompGenomesSelection(this.vGenomes.map(g=>g.name));
	    //
	    this.cmode = cfg.cmode;
	    //
	}).then(() => {
	    //
	    if (!cfg) return;
	    this.coords   = {
		chr: cfg.chr.name,
		chromosome: cfg.chr,
		start: cfg.start,
		end: cfg.end
	    };
	    this.lcoords  = {
	        landmark: cfg.landmark, 
		landmarkRefFeat: cfg.landmarkRefFeat,
		landmarkFeats: cfg.landmarkFeats,
		flank: cfg.flank, 
		length: cfg.length, 
		delta: cfg.delta 
	    };
	    //
	    this.translator.ready().then(() => {
		this.zoomView.update(cfg);
		//
		this.genomeView.setBrushCoords(this.coords);
		this.genomeView.redraw();
		//
		if (!quietly)
		    this.contextChanged();
		//
		this.showBusy(false);
	    });
	});
	return p;
    }
 
    //----------------------------------------------
    setCoordinates (str) {
	let coords = Object(__WEBPACK_IMPORTED_MODULE_1__utils__["j" /* parseCoords */])(str);
	if (! coords) {
	    let feats = this.featureManager.getCachedFeaturesByLabel(str);
	    let feats2 = feats.filter(f=>f.genome == this.rGenome);
	    let f = feats2[0] || feats[0];
	    if (f) {
		coords = {
		    ref: f.genome.name,
		    landmark: str,
		    delta: 0,
		    highlight: f.id
		}
	    }
	    else {
		alert("Unable to set coordinates with this value: " + str);
		return;
	    }
	}
	this.setContext(coords);
    }

    //----------------------------------------------
    resize () {
	let w = window.innerWidth - 24;
	this.genomeView.fitToWidth(w);
	this.zoomView.fitToWidth(w);
    }
    //----------------------------------------------
    // Returns the current context as a parameter string
    // Current context = ref genome + comp genomes + current range (chr,start,end)
    getParamString () {
	let c = this.getContext();
        let ref = `ref=${c.ref}`;
        let genomes = `genomes=${c.genomes.join("+")}`;
	let coords = `chr=${c.chr}&start=${c.start}&end=${c.end}`;
	let lflf = c.flank ? '&flank='+c.flank : '&length='+c.length;
	let lcoords = `landmark=${c.landmark}&delta=${c.delta}${lflf}`;
	let hls = `highlight=${c.highlight.join("+")}`;
	let dmode = `dmode=${c.dmode}`;
	return `${this.cmode==='mapped'?coords:lcoords}&${dmode}&${ref}&${genomes}&${hls}`;
    }

    //----------------------------------------------
    getCurrentList () {
        return this.currList;
    }
    //----------------------------------------------
    setCurrentList (lst, goToFirst) {
    	//
	let prevList = this.currList;
	this.currList = lst;
	if (lst !== prevList) {
	    this.currListIndex = lst ? lst.ids.reduce( (x,i) => { x[i]=i; return x; }, {}) : {};
	    this.currListCounter = 0;
	}
	//
	let lists = d3.select('#mylists').selectAll('.listInfo');
	lists.classed("current", d => d === lst);
	//
	// show this list as tick marks in the genome view
	this.genomeView.drawTicks(lst ? lst.ids : []);
	this.genomeView.drawTitle();
	this.zoomView.highlight();
	//
	if (goToFirst) this.goToNextListElement();
    }
    //----------------------------------------------
    goToNextListElement () {
	if (!this.currList || this.currList.ids.length === 0) return;
	let currId = this.currList.ids[this.currListCounter];
        this.currListCounter = (this.currListCounter + 1) % this.currList.ids.length;
	this.setCoordinates(currId);
    }
    //----------------------------------------------
    panzoom(pfactor, zfactor) {
	//
	!pfactor && (pfactor = 0);
	!zfactor && (zfactor = 1);
	//
	let c = this.coords;
	let width = c.end - c.start + 1;
	let mid = (c.start + c.end)/2;
	let chr = this.rGenome.chromosomes.filter(c => c.name === this.coords.chr)[0];
	let ncxt = {}; // new context
	let minD = -(c.start-1); // min delta (at current zoom)
	let maxD = chr.length - c.end; // max delta (at current zoom)
	let d = Object(__WEBPACK_IMPORTED_MODULE_1__utils__["a" /* clip */])(pfactor * width, minD, maxD); // delta (at new zoom)
	let newwidth = zfactor * width;
	let newstart = mid - newwidth/2 + d;
	//
	if (this.cmode === 'mapped') {
	    ncxt.chr = c.chr;
	    ncxt.start = newstart;
	    ncxt.end = newstart + newwidth - 1;
	}
	else {
	    ncxt.length = newwidth;
	    ncxt.delta = this.lcoords.delta + d ;
	}
	this.setContext(ncxt);
    }
    zoom (factor) {
        this.panzoom(null, factor);
    }
    pan (factor) {
        this.panzoom(factor, null);
    }	

    //----------------------------------------------
    initFeatTypeControl (facet) {
	let self = this;
	let colors = this.cscale.domain().map(lbl => {
	    return { lbl:lbl, clr:this.cscale(lbl) };
	});
	let ckes = d3.select(".colorKey")
	    .selectAll('.colorKeyEntry')
		.data(colors);
	let ncs = ckes.enter().append("div")
	    .attr("class", "colorKeyEntry flexrow");
	ncs.append("div")
	    .attr("class","swatch")
	    .attr("name", c => c.lbl)
	    .style("background-color", c => c.clr)
	    .on("click", function () {
		let t = d3.select(this);
	        t.classed("checked", ! t.classed("checked"));
		let swatches = d3.selectAll(".swatch.checked")[0];
		let fts = swatches.map(s=>s.getAttribute("name"))
		facet.setValues(fts);
		self.zoomView.highlight();
	    })
	    .append("i")
	        .attr("class","material-icons");
	ncs.append("span")
	    .text(c => c.lbl);
    }
    //----------------------------------------------
    clearCachedData (ask) {
	if (!ask || window.confirm('Delete all cached data. Are you sure?')) {
	    this.featureManager.clearCachedData();
	    this.translator.clearCachedData();
	}
    }

    //----------------------------------------------
    linkToMgiSnpReport () {
	let c = this.getContext();
	let urlBase = 'http://www.informatics.jax.org/snp/summary';
	let tabArg = 'selectedTab=1';
	let searchByArg = 'searchBySameDiff=';
	let chrArg = `selectedChromosome=${c.chr}`;
	let coordArg = `coordinate=${c.start}-${c.end}`;
	let unitArg = 'coordinateUnit=bp';
	let csArgs = c.genomes.map(g => `selectedStrains=${g}`)
	let rsArg = `referenceStrain=${c.ref}`;
	let linkUrl = `${urlBase}?${tabArg}&${searchByArg}&${chrArg}&${coordArg}&${unitArg}&${rsArg}&${csArgs.join('&')}`
	window.open(linkUrl, "_blank");
    }
    //----------------------------------------------
    linkToMgiQTLs () {
	let c        = this.getContext();
	let urlBase  = 'http://www.informatics.jax.org/allele/summary';
	let chrArg   = `chromosome=${c.chr}`;
	let coordArg = `coordinate=${c.start}-${c.end}`;
	let unitArg  = 'coordUnit=bp';
	let typeArg  = 'alleleType=QTL';
	let linkUrl  = `${urlBase}?${chrArg}&${coordArg}&${unitArg}&${typeArg}`;
	window.open(linkUrl, "_blank");
    }
    //----------------------------------------------
    linkToMgiJBrowse () {
	let c = this.getContext();
	let urlBase = 'http://jbrowse.informatics.jax.org/';
	let dataArg = 'data=data%2Fmouse'; // "data/mouse"
	let locArg  = `loc=chr${c.chr}%3A${c.start}..${c.end}`;
	let tracks  = ['DNA','MGI_Genome_Features','NCBI_CCDS','NCBI','ENSEMBL'];
	let tracksArg=`tracks=${tracks.join(',')}`;
	let highlightArg = 'highlight=';
	let linkUrl = `${urlBase}?${ [dataArg,locArg,tracksArg,highlightArg].join('&') }`;
	window.open(linkUrl, "_blank");
    }
    //----------------------------------------------
    // Downloads DNA sequences of the specified type in FASTA format for the specified feature.
    // If genomes is specified, lists the specific genomes to retrieve from; otherwise retrieves from all genomes.
    // Args:
    //     f (object) the feature
    //     type (string) which sequences to download: 'genomic','exon','CDS',
    //     genomes (list of strings) names of genomes to retrieve from. If not specified,
    //         retrieves sequenecs from all available mouse genomes.
    //
    downloadFasta (f, type, genomes) {
	let q = this.queryManager.auxDataManager.sequencesForFeature(f, type, genomes)
	if (q) window.open(q,"_blank");
    }
    linkToReportPage (f) {
        let u = this.queryManager.auxDataManager.linkToReportPage(f.id);
	window.open(u, '_blank')
    }
} // end class MGVApp




/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Genome; });
class Genome {
  constructor (cfg) {
    this.name = cfg.name;
    this.label= cfg.label;
    this.chromosomes = [];
    this.maxlen = -1;
    this.xscale = null;
    this.yscale = null;
    this.zoomY  = -1;
  }
  getChromosome (n) {
      if (typeof(n) === 'string')
	  return this.chromosomes.filter(c => c.name === n)[0];
      else
          return this.chromosomes[n];
  }
  hasChromosome (n) {
      return this.getChromosome(n) ? true : false;
  }
}




/***/ }),
/* 10 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeatureManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Feature__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__KeyStore__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__Layout__ = __webpack_require__(12);






//----------------------------------------------
// How the app loads feature data. Provides two calls:
// Requests features from the server and registers them in a cache.
// Interacts with the back end to load features.
//
class FeatureManager {
    constructor (app) {
	this.cfg = __WEBPACK_IMPORTED_MODULE_3__config__["a" /* default */].FeatureManager;
        this.app = app;
	this.auxDataManager = this.app.queryManager.auxDataManager;
        this.id2feat = {};		// index from  feature ID to feature
	this.canonical2feats = {};	// index from canonical ID -> [ features tagged with that id ]
	this.symbol2feats = {}		// index from symbol -> [ features having that symbol ]
					// want case insensitive searches, so keys are lower cased
	this.cache = {};		// {genome.name -> {chr.name -> list of blocks}}
	this.mineFeatureCache = {};	// auxiliary info pulled from MouseMine 
	this.loadedGenomes = new Set(); // the set of Genomes that have been fully loaded
	this.transcriptFiles = {};	// map from file name to promise for that file.
	//
	this.fStore = new __WEBPACK_IMPORTED_MODULE_2__KeyStore__["a" /* KeyStore */]('features'); // maps genome name -> list of features
    }
 
    //----------------------------------------------
    // Args:
    //   d (parsed GFF row)
    processFeature (genome, d) {
	let ID = d[8]['ID'];
	// If we've already got this one in the cache, return it.
	let f = ID ? this.id2feat[ID] : null;
	if (f) return f;
	// Create a new Feature
	f = new __WEBPACK_IMPORTED_MODULE_1__Feature__["a" /* Feature */](genome, ID, d);
	// Register it.
	this.id2feat[f.ID] = f;
	// genome cache
	let gc = this.cache[genome.name] = (this.cache[genome.name] || {});
	// chromosome cache (w/in genome)
	let cc = gc[f.chr] = (gc[f.chr] || []);
	cc.push(f);
	//
	if (f.canonical && f.canonical !== '.') {
	    let lst = this.canonical2feats[f.canonical] = (this.canonical2feats[f.canonical] || []);
	    lst.push(f);
	}
	if (f.symbol && f.symbol !== '.') {
	    let s = f.symbol.toLowerCase();
	    let lst = this.symbol2feats[s] = (this.symbol2feats[s] || []);
	    lst.push(f);
	}
	// here y'go.
	return f;
    }
    //---------------------------------------------
    assertSorted (feats) {
	let prev = null;
        feats.forEach((f,i) => {
	    if (prev && f.chr !== prev.chr)
	        prev = null;
	    if (prev && f.start < prev.start)
	        throw 'Features are not sorted at position ' + i;
	    prev = f;
	});
    }
    //----------------------------------------------
    // Processes the "raw" features returned by the server.
    // Turns them into Feature objects and registers them.
    // If the same raw feature is registered again,
    // the Feature object created the first time is returned.
    // (I.e., registering the same feature multiple times is ok)
    //
    processFeatures (genome, feats) {
	let cta;	// contig assigner
	let swa_p;	// swim lane assigner for plus strand
	let swa_m;	// swim lane assigner for minus strand
	let fp;		// feature packer
	let prev;	// previous feature
	// turn raw features into Feature objects
	feats = feats.map(d => this.processFeature(genome, d));
	// assign lanes
	feats.forEach(f => {
	    if (f.chr != prev) {
	        cta = new __WEBPACK_IMPORTED_MODULE_4__Layout__["a" /* ContigAssigner */]();
		swa_p = new __WEBPACK_IMPORTED_MODULE_4__Layout__["c" /* SwimLaneAssigner */]();
		swa_m = new __WEBPACK_IMPORTED_MODULE_4__Layout__["c" /* SwimLaneAssigner */]();
		fp = new __WEBPACK_IMPORTED_MODULE_4__Layout__["b" /* FeaturePacker */](1);
	    }
	    f.contig = cta.assignNext(f.start, f.end);
	    f.lane = f.strand === '+' ? 
	        swa_p.assignNext(f.start, f.end)
		:
		-swa_m.assignNext(f.start, f.end);
	    f.lane2 = fp.assignNext(f.start, f.end, Math.max(1, f.transcript_count), f.symbol)
	    prev = f.chr;
	});
	//this.assertSorted(feats);
	return feats;
    }

    //----------------------------------------------
    ensureFeaturesByGenome (genome) {
	if (this.loadedGenomes.has(genome))
	    return Promise.resolve(true);
	return this.fStore.get(genome.name).then(data => {
	    if (data === undefined) {
		console.log("Requesting:", genome.name, );
		let url = `./data/${genome.name}/features.json`;
		return Object(__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* d3json */])(url).then( rawfeats => {
		    this.fStore.set(genome.name, rawfeats);
		    let feats = this.processFeatures(genome, rawfeats);
		});
	    }
	    else {
		console.log("Found in cache:", genome.name, );
		let feats = this.processFeatures(genome, data);
		return true;
	    }
	}).then( ()=> {
	    this.loadedGenomes.add(genome);  
	    this.app.showStatus(`Loaded: ${genome.name}`);
	    return true; 
	});
    }

    //----------------------------------------------
    processTranscript (t) {
	let gid = t[8]['gene_id'];
	let feat = this.id2feat[gid];
	let tt = {
	    ID: t[8]['ID'],
	    chr: t[0],
	    start: t[3],
	    end: t[4],
	    strand: t[6],
	    feature: feat,
	}
	tt.exons = t[8]['eOffsets'].map( (o,i) => {
	    let start = t[3] + o;
	    let end = start + t[8]['eLengths'][i] - 1;
	    return {ID:'?', start:start, end:end, feature:feat}
	});
	feat.transcripts.push(tt);
    }

    //----------------------------------------------
    loadTranscriptFile (feat) {
	let genome = feat.genome.name;
	let chr = feat.chr;
	let blk = Math.floor(feat.start/this.cfg.transcriptBlockSize);
	let url = `data/${genome}/transcripts/chr${chr}.${blk}.json`;
	let p = this.transcriptFiles[url];
	if (!p) {
	    p = this.transcriptFiles[url] = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* d3json */])(url).then(transcripts => {
		transcripts.forEach(t => this.processTranscript(t));
		console.log('Loaded transcripts: ' + url);
	    });
	}
	return p;
    }

    //----------------------------------------------
    // Returns a promise that resolves when all exons for the given set of gene ids.
    // Gene IDs are genome-specific, NOT canonical.
    //
    ensureTranscriptsByGeneIds (ids) {
	// Map ids to Feature objects, filter for those where exons have not been retrieved yet
	// Exons accumulate in their features - no cache eviction implemented yet. FIXME.
	// 
	let feats = (ids||[]).map(i => this.id2feat[i]).filter(f => f);
	let promises = feats.map(f => {
	    let genome = f.genome.name;
	    let chr = f.chr;
	    let blk = Math.floor(f.start/this.cfg.transcriptBlockSize);
	    let url = `data/${genome}/transcripts/chr${chr}.${blk}.json`;
	    let p = this.transcriptFiles[url];
	    if (!p) {
	        p = this.transcriptFiles[url] = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["c" /* d3json */])(url).then(transcripts => {
		    transcripts.forEach(t => this.processTranscript(t));
		    console.log('Loaded transcripts: ' + url);
		});
	    }
	    return p;
	})
	return Promise.all(promises);
    }

    //----------------------------------------------
    loadGenomes (genomes) {
        return Promise.all(genomes.map(g => this.ensureFeaturesByGenome (g))).then(()=>true);
    }

    //----------------------------------------------
    getCachedFeaturesByRange (genome, range) {
        let gc = this.cache[genome.name] ;
	if (!gc) return [];
	let cFeats = gc[range.chr];
	if (!cFeats) return [];
	// FIXME: should be smarter than testing every feature!
	let feats = cFeats.filter(cf => Object(__WEBPACK_IMPORTED_MODULE_0__utils__["i" /* overlaps */])(cf, range));
        return feats;	
    }

    //----------------------------------------------
    // Returns all cached features having the given canonical id.
    getCachedFeatureById (id) {
        return this.id2feats[id];
    }

    //----------------------------------------------
    // Returns all cached features having the given canonical id.
    getCachedFeaturesByCanonicalId (cid) {
        return this.canonical2feats[cid] || [];
    }

    //----------------------------------------------
    // Returns a list of features that match the given label, which can be an id, canonical id, or symbol.
    // If genome is specified, limit results to features from that genome.
    // 
    getCachedFeaturesByLabel (label, genome) {
	let f = this.id2feat[label]
	let feats = f ? [f] : this.canonical2feats[label] || this.symbol2feats[label.toLowerCase()] || [];
	return genome ? feats.filter(f=> f.genome === genome) : feats;
    }

    //----------------------------------------------
    // Returns a promise for the features in 
    // the specified ranges of the specified genome.
    getFeaturesByRange (genome, ranges, getExons) {
	let fids = []
	let p = this.ensureFeaturesByGenome(genome).then(() => {
            ranges.forEach( r => {
	        r.features = this.getCachedFeaturesByRange(genome, r) 
		r.genome = genome;
		fids = fids.concat(r.features.map(f => f.ID))
	    });
	    let results = { genome, blocks:ranges };
	    return results;
	});
	if (getExons) {
	    p = p.then(results => {
	        return this.ensureTranscriptsByGeneIds(fids).then(()=>results);
		});
	}
	return p;
    }
    //----------------------------------------------
    // Returns a promise for the features having the specified ids from the specified genome.
    getFeaturesById (genome, ids) {
        return this.ensureFeaturesByGenome(genome).then( () => {
	    let feats = [];
	    let seen = new Set();
	    let addf = (f) => {
		if (f.genome !== genome) return;
		if (seen.has(f.id)) return;
		seen.add(f.id);
		feats.push(f);
	    };
	    let add = (f) => {
		if (Array.isArray(f)) 
		    f.forEach(ff => addf(ff));
		else
		    addf(f);
	    };
	    for (let i of ids){
		let f = this.canonical2feats[i] || this.id2feat[i];
		f && add(f);
	    }
	    return feats;
	});
    }
    //----------------------------------------------
    clearCachedData () {
	console.log("FeatureManager: Cache cleared.")
        return this.fStore.clear();
    }

} // end class Feature Manager




/***/ }),
/* 11 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Store; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return get; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return set; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return del; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return clear; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return keys; });
class Store {
    constructor(dbName = 'keyval-store', storeName = 'keyval') {
        this.storeName = storeName;
        this._dbp = new Promise((resolve, reject) => {
            const openreq = indexedDB.open(dbName, 1);
            openreq.onerror = () => reject(openreq.error);
            openreq.onsuccess = () => resolve(openreq.result);
            // First time setup: create an empty object store
            openreq.onupgradeneeded = () => {
                openreq.result.createObjectStore(storeName);
            };
        });
    }
    _withIDBStore(type, callback) {
        return this._dbp.then(db => new Promise((resolve, reject) => {
            const transaction = db.transaction(this.storeName, type);
            transaction.oncomplete = () => resolve();
            transaction.onabort = transaction.onerror = () => reject(transaction.error);
            callback(transaction.objectStore(this.storeName));
        }));
    }
}
let store;
function getDefaultStore() {
    if (!store)
        store = new Store();
    return store;
}
function get(key, store = getDefaultStore()) {
    let req;
    return store._withIDBStore('readonly', store => {
        req = store.get(key);
    }).then(() => req.result);
}
function set(key, value, store = getDefaultStore()) {
    return store._withIDBStore('readwrite', store => {
        store.put(value, key);
    });
}
function del(key, store = getDefaultStore()) {
    return store._withIDBStore('readwrite', store => {
        store.delete(key);
    });
}
function clear(store = getDefaultStore()) {
    return store._withIDBStore('readwrite', store => {
        store.clear();
    });
}
function keys(store = getDefaultStore()) {
    const keys = [];
    return store._withIDBStore('readonly', store => {
        // This would be store.getAllKeys(), but it isn't supported by Edge or Safari.
        // And openKeyCursor isn't supported by Safari.
        (store.openKeyCursor || store.openCursor).call(store).onsuccess = function () {
            if (!this.result)
                return;
            keys.push(this.result.key);
            this.result.continue();
        };
    }).then(() => keys);
}




/***/ }),
/* 12 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ContigAssigner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return SwimLaneAssigner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return FeaturePacker; });

class ContigAssigner {
    constructor () {
        this.contig = 0;
	this.hwm = null;
    }
    assignNext (fstart, fend) {
        if (this.hwm === null || fstart > this.hwm)
	    this.contig += 1;
	this.hwm = Math.max(this.hwm, fend);
	return this.contig;
    }
}

class SwimLaneAssigner {
    constructor () {
        this.lanes = [];
    }
    assignNext (fstart, fend) {
        for (let i = 0; i < this.lanes.length; i++) {
	    let hwm = this.lanes[i];
	    if (fstart > hwm) {
	        this.lanes[i] = fend;
		return i+1;
	    }
	}
	this.lanes.push(fend);
	return this.lanes.length;
    }
}

class xFeaturePacker {
    constructor (ygap) {
	// distance between blocks.
	this.ygap = ygap || 0;
	// overlapping features.
        this.buffer = [];
    }
    assignNext (fstart, fend, fheight) {
	// remove buffer items that do not overlap the new feature
        this.buffer = this.buffer.filter(ff => {
	    return fstart <= ff.fend && fend >= ff.fstart;
	});
	// Look for a big enough gap in the y dimension between buffer items
	// to fit this new one. If none found, stack on top.
	// Buffer is maintained in sorted y order.
	// NB: remember, up means negative y direction.
	let minGap = fheight + 2*this.ygap;
	let y = 0;
	let i = 0;
	for (i in this.buffer) {
	    let ff = this.buffer[i];
	    // distance between current y and bottom of next block in buffer
	    let gapSize = y - (ff.y + ff.fheight);
	    if (gapSize >= minGap) {
		break;
	    }
	    // set current y to top of this buffer block
	    y = ff.y;
	};
	// Found y for new block's baseline. Want position at top of block.
	y = y - fheight - this.ygap;
	// Insert into buffer. Maintain y sort.
	this.buffer.splice(i,0, {fstart, fend, fheight, y});
	// here ya go
	return y;
    }
}
class FeaturePacker {
    constructor (ygap) {
	// distance between blocks.
	this.ygap = ygap || 0;
	// overlapping features.
        this.buffer = [];
    }
    assignNext (fstart, fend, fheight, fsymbol) {
	// remove buffer items that do not overlap the new feature
        this.buffer = this.buffer.filter(ff => {
	    return fstart <= ff.fend && fend >= ff.fstart;
	});
	// Look for a big enough gap in the y dimension between buffer items
	// to fit this new one. If none found, stack on top.
	// Buffer is maintained in sorted y order.
	// NB: remember, positive y is down in screen coords
	let minGap = fheight + 2*this.ygap;
	let y = 0; // start off at baseline
	let i;
	for (i = 0; i < this.buffer.length; i++) {
	    let ff = this.buffer[i];
	    // distance between current y and top of next block in buffer
	    let gapSize = ff.y - y;
	    if (gapSize >= minGap) {
		break;
	    }
	    // set current y to bottom of this buffer block
	    y = ff.y + ff.fheight;
	};
	// Found y for new block's baseline. Want position at top of block.
	y += this.ygap;
	// Insert into buffer. Maintain y sort.
	this.buffer.splice(i, 0, {fstart, fend, fheight, y, fsymbol});
	// here ya go
	return y;
    }
}




/***/ }),
/* 13 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return QueryManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Component__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__AuxDataManager__ = __webpack_require__(14);





// ---------------------------------------------
class QueryManager extends __WEBPACK_IMPORTED_MODULE_2__Component__["a" /* Component */] {
    constructor (app, elt) {
        super(app, elt);
	this.cfg = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].QueryManager.searchTypes;
	this.auxDataManager = new __WEBPACK_IMPORTED_MODULE_3__AuxDataManager__["a" /* AuxDataManager */]();
	this.select = null;	// my <select> element
	this.term = null;	// my <input> element
	this.initDom();
    }
    initDom () {
	this.select = this.root.select('[name="searchtype"]');
	this.term   = this.root.select('[name="searchterm"]');
	//
	this.term.attr("placeholder", this.cfg[0].placeholder)
	Object(__WEBPACK_IMPORTED_MODULE_1__utils__["g" /* initOptList */])(this.select[0][0], this.cfg, c=>c.method, c=>c.label);
	// When user changes the query type (selector), change the placeholder text.
	this.select.on("change", () => {
	    let opt = this.select.property("selectedOptions")[0];
	    this.term.attr("placeholder", opt.__data__.placeholder)
	    
	});
	// When user enters a search term, run a query
	this.term.on("change", () => {
	    let term = this.term.property("value");
	    this.term.property("value","");
	    let searchType  = this.select.property("value");
	    let lstName = term;
	    d3.select("#mylists").classed("busy",true); // FIXME - reachover
	    this.auxDataManager[searchType](term)	// <- run the query
	      .then(feats => {
		  // FIXME - reachover - this whole handler
		  let lst = this.app.listManager.createList(lstName, feats.map(f => f.primaryIdentifier))
		  this.app.listManager.update(lst);
		  //
		  this.app.zoomView.hiFeats = {};
		  feats.forEach(f => this.app.zoomView.hiFeats[f.canonical] = f.canonical);
		  this.app.zoomView.highlight();
		  //
		  this.app.setCurrentList(lst,true);
		  //
		  d3.select("#mylists").classed("busy",false);
	      });
	})
    }
}




/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return AuxDataManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);



// ---------------------------------------------
// AuxDataManager - knows how to query an external source (i.e., MouseMine) for genes
// annotated to different ontologies and for exons associated with specific genes or regions.
class AuxDataManager {
    constructor () {
	this.cfg = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].AuxDataManager;
	if (!this.cfg.allMines[this.cfg.mousemine]) 
	    throw "Unknown mine name: " + this.cfg.mousemine;
	this.baseUrl = this.cfg.allMines[this.cfg.mousemine];
	console.log("MouseMine url:", this.baseUrl);
        this.qUrl = this.baseUrl + '/service/query/results?';
	this.rUrl = this.baseUrl + '/portal.do?class=SequenceFeature&externalids=';
	this.faUrl = this.baseUrl + '/service/query/results/fasta?';
	this.seqSliceUrl = this.baseUrl + '/service/sequence?';
    }
    //----------------------------------------------
    getAuxData (q, format) {
	//console.log('Query: ' + q);
	format = format || 'jsonobjects';
	let query = encodeURIComponent(q);
	let url = this.qUrl + `format=${format}&query=${query}`;
	return Object(__WEBPACK_IMPORTED_MODULE_1__utils__["c" /* d3json */])(url).then(data => data.results||[]);
    }

    //----------------------------------------------
    isIdentifier (q) {
        let pts = q.split(':');
        if (pts.length === 2 && pts[1].match(/^[0-9]+$/))
	    return true;
	if (q.toLowerCase().startsWith('r-mmu-'))
	    return true;
	return false;
    }
    //----------------------------------------------
    addWildcards (q) {
        return (this.isIdentifier(q) || q.indexOf('*')>=0) ? q : `*${q}*`;
    }
    //----------------------------------------------
    // do a LOOKUP query for SequenceFeatures from MouseMine
    featuresByLookup (qryString) {
	let q = `<query name="" model="genomic" 
	    view="SequenceFeature.primaryIdentifier SequenceFeature.symbol" 
	    constraintLogic="A and B and C">
		<constraint code="A" path="SequenceFeature" op="LOOKUP" value="${qryString}"/>
		<constraint code="B" path="SequenceFeature.organism.taxonId" op="=" value="10090"/>
		<constraint code="C" path="SequenceFeature.sequenceOntologyTerm.name" op="!=" value="transgene"/>
	    </query>`;
	return this.getAuxData(q);
    }
    //----------------------------------------------
    featuresByOntologyTerm (qryString, termTypes) {
	qryString = this.addWildcards(qryString);
        let q = `<query name="" model="genomic" 
	  view="SequenceFeature.primaryIdentifier SequenceFeature.symbol" constraintLogic="A and B and C and D">
	      <constraint code="A" path="SequenceFeature.ontologyAnnotations.ontologyTerm.parents" op="LOOKUP" value="${qryString}"/>
	      <constraint code="B" path="SequenceFeature.organism.taxonId" op="=" value="10090"/>
	      <constraint code="C" path="SequenceFeature.sequenceOntologyTerm.name" op="!=" value="transgene"/>
	      <constraint code="D" path="SequenceFeature.ontologyAnnotations.ontologyTerm.ontology.name" op="ONE OF">
		  ${ termTypes.map(tt=> '<value>'+tt+'</value>').join('') }
	      </constraint>
	  </query>`
	return this.getAuxData(q);
    }
    //----------------------------------------------
    featuresByPathwayTerm (qryString) {
	qryString = this.addWildcards(qryString);
        let q = `<query name="" model="genomic" 
	  view="Gene.primaryIdentifier Gene.symbol" constraintLogic="A and B">
	      <constraint path="Gene.pathways" code="A" op="LOOKUP" value="${qryString}"/>
	      <constraint path="Gene.organism.taxonId" code="B" op="=" value="10090"/>
	  </query>`;
	return this.getAuxData(q);
    }
    //----------------------------------------------
    featuresById        (qryString) { return this.featuresByLookup(qryString); }
    featuresByFunction  (qryString) { return this.featuresByOntologyTerm(qryString, ["Gene Ontology"]); }
    featuresByPhenotype (qryString) { return this.featuresByOntologyTerm(qryString, ["Mammalian Phenotype","Disease Ontology"]); }
    featuresByPathway   (qryString) { return this.featuresByPathwayTerm(qryString); }
    //----------------------------------------------
    // Returns a promise for all exons of features overlapping a specified range in the specifed genome.
    exonView () {
	return [
	    'Exon.gene.canonical.primaryIdentifier',
	    'Exon.gene.primaryIdentifier',
	    'Exon.transcripts.primaryIdentifier',
	    'Exon.primaryIdentifier',
	    'Exon.chromosome.primaryIdentifier',
	    'Exon.chromosomeLocation.start',
	    'Exon.chromosomeLocation.end',
	    'Exon.strain.name'
	].join(' ');
    }
    //
    sequenceSlice (genome, chr, start, end) {
        let q = ` <query model="genomic"
	    view="Chromosome.sequence.residues">
	    <constraint path="Chromosome.primaryIdentifier" op="=" value="${chr}" />
	    <constraint path="Chromosome.strain.name" op="=" value="${genome}" />
	    </query>`
	let query = encodeURIComponent(q);
	// FIXME: Weird. This web service appears to use 0-based coordinates, and want end to be 1 beyond the 
	// last base you want returned. Have to convert from normal genome coordinates.
	let url = this.seqSliceUrl + `start=${start-1}&end=${end}&query=${query}`;
	return Object(__WEBPACK_IMPORTED_MODULE_1__utils__["c" /* d3json */])(url).then(data => {
	    let result = data.features[0]
	    result.genome = genome;
	    result.chr = chr;
	    return result;
	});
    }
    // Returns a promise for all exons from the given genome where the exon's gene overlaps the given coordinates.
    exonsByRange	(genome, chr, start, end) {
        let q = `<query model="genomic" view="${this.exonView()}" constraintLogic="A and B">
	    <constraint code="A" path="Exon.gene.chromosomeLocation" op="OVERLAPS">
		<value>${chr}:${start}..${end}</value>
	    </constraint>
	    <constraint code="B" path="Exon.strain.name" op="=" value="${genome}"/>
	    </query>`
	return this.getAuxData(q);
    }
    // Returns a promise for all exons of all genologs of the specified canonical gene
    exonsByCanonicalId	(ident) {
        let q = `<query model="genomic" view="${this.exonView()}" >
	    <constraint code="A" path="Exon.gene.canonical.primaryIdentifier" op="=" value="${ident}" />
	    </query>`
	return this.getAuxData(q);
    }
    // Returns a promise for all exons of the specified gene.
    exonsByGeneId	(ident) {
        let q = `<query model="genomic" view="${this.exonView()}" >
	    <constraint code="A" path="Exon.gene.primaryIdentifier" op="=" value="${ident}" />
	    </query>`
	return this.getAuxData(q);
    }
    // Returns a promise for all exons of the specified gene.
    exonsByGeneIds	(idents) {
	let vals = idents.map(i => `<value>${i}</value>`).join('');
        let q = `<query model="genomic" view="${this.exonView()}" >
	    <constraint code="A" path="Exon.gene.primaryIdentifier" op="ONE OF">${vals}</constraint>
	    </query>`
	return this.getAuxData(q);
    }
    //----------------------------------------------
    // Constructs a URL for linking to a MouseMine report page by id
    linkToReportPage (ident) {
        return this.rUrl + ident;
    }
    //----------------------------------------------
    // Constructs a URL to retrieve mouse sequences of the specified type for the specified feature.
    sequencesForFeature (f, type, genomes) {
	let q;
	let url;
	let view;
	let ident;
        //
	type = type ? type.toLowerCase() : 'genomic';
	//
	if (f.canonical) {
	    ident = f.canonical
	    //
	    let gs = ''
	    let vals;
	    if (genomes) {
		vals = genomes.map((g) => `<value>${g}</value>`).join('');
	    }
	    switch (type) {
	    case 'genomic':
		view = 'Gene.canonical.primaryIdentifier';
		gs = `<constraint path="Gene.strain.name" op="ONE OF">${vals}</constraint>`
		q = `<query name="sequencesByCanonicalId" model="genomic" view="Gene.primaryIdentifier" >
		    <constraint path="Gene.canonical.primaryIdentifier" op="=" value="${ident}"/>
		    ${gs}</query>`;
		break;

            case 'transcript':
		view = 'Transcript.gene.canonical.primaryIdentifier';
		gs = `<constraint path="Transcript.strain.name" op="ONE OF">${vals}</constraint>`
		q = `<query name="transcriptSequencesByCanonicalId" model="genomic" view="Transcript.primaryIdentifier" >
		    <constraint path="Transcript.gene.canonical.primaryIdentifier" op="=" value="${ident}"/>
		    ${gs}</query>`;
	        break;

	    case 'exon':
		view = 'Exon.gene.canonical.primaryIdentifier';
		gs = `<constraint path="Exon.strain.name" op="ONE OF">${vals}</constraint>`
		q = `<query name="exonSequencesByCanonicalId" model="genomic" view="Exon.primaryIdentifier" >
		    <constraint path="Exon.gene.canonical.primaryIdentifier" op="=" value="${ident}"/>
		    ${gs}</query>`;
	        break;
	    case 'cds':
		view = 'CDS.gene.canonical.primaryIdentifier';
		gs = `<constraint path="CDS.strain.name" op="ONE OF">${vals}</constraint>`
		q = `<query name="cdsSequencesByCanonicalId" model="genomic" view="CDS.primaryIdentifier" >
		    <constraint path="CDS.gene.canonical.primaryIdentifier" op="=" value="${ident}"/>
		    ${gs}</query>`;
	        break;
	    }
	}
	else {
	    ident = f.ID;
	    view = ''
	    switch (type) {
	    case 'genomic':
		q = `<query name="sequencesById" model="genomic" view="Gene.primaryIdentifier" >
		    <constraint path="Gene.primaryIdentifier" op="=" value="${ident}"/>
		  </query>`;
		break;
            case 'transcript':
		q = `<query name="transcriptSequencesById" model="genomic" view="Transcript.primaryIdentifier" >
		    <constraint path="Transcript.gene.primaryIdentifier" op="=" value="${ident}"/>
		  </query>`;
	        break;
	    case 'exon':
		q = `<query name="exonSequencesById" model="genomic" view="Exon.primaryIdentifier" >
		    <constraint path="Exon.gene.primaryIdentifier" op="=" value="${ident}"/>
		  </query>`;
	        break;
	    case 'cds':
		q = `<query name="cdsSequencesById" model="genomic" view="CDS.primaryIdentifier" >
		    <constraint path="CDS.gene.primaryIdentifier" op="=" value="${ident}"/>
		  </query>`;
	        break;
	    }
	}
	if (!q) return null;
	console.log(q, view);
	url = this.faUrl + `query=${encodeURIComponent(q)}`;
	if (view)
            url += `&view=${encodeURIComponent(view)}`;
	return url;
    }
}




/***/ }),
/* 15 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ListManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ListFormulaEvaluator__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__KeyStore__ = __webpack_require__(3);




// ---------------------------------------------
// Maintains named lists of IDs. Lists may be temporary, lasting only for the session, or permanent,
// lasting until the user clears the browser local storage area.
//
// Uses window.sessionStorage and window.localStorage to save lists
// temporarily or permanently, resp.  FIXME: should be using window.indexedDB
//
class ListManager extends __WEBPACK_IMPORTED_MODULE_0__Component__["a" /* Component */] {
    constructor (app, elt) {
        super(app, elt);
	this.name2list = null;
	this.listStore = new __WEBPACK_IMPORTED_MODULE_2__KeyStore__["a" /* KeyStore */]('user-lists');
	this.formulaEval = new __WEBPACK_IMPORTED_MODULE_1__ListFormulaEvaluator__["a" /* ListFormulaEvaluator */](this);
	this.ready = this._load().then( ()=>this.initDom() );
    }
    initDom () {
	// Button: show/hide warning message
	this.root.select('.button.warning')
	    .on('click', () => {
	        let w = this.root.select('[name="message"]');
		w.classed('showing', !w.classed('showing'));
	    });
	// Button: create list from current selection
	this.root.select('.button[name="newfromselection"]')
	    .on("click", () => {
		let ids = new Set(Object.keys(this.app.zoomView.hiFeats)); // FIXME - reachover
		let lst = this.app.getCurrentList();
		if (lst)
		    ids = ids.union(lst.ids);
		if (ids.size === 0) {
		    alert("Nothing selected.");
		    return;
		}
		let newlist = this.createList("selection", Array.from(ids));
		this.update(newlist);
	    });

	// Button: combine lists: open list editor with formula editor open
	this.root.select('.button[name="combine"]')
	    .on("click", () => {
		if (this.getNames().length === 0) {
		    alert("No lists.");
		    return;
		}
		let le = this.app.listEditor;
		le.open();
		le.openFormulaEditor();
	    });
	// Button: delete all lists (get confirmation first).
	this.root.select('.button[name="purge"]')
	    .on("click", () => {
		if (this.getNames().length === 0) {
		    alert("No lists.");
		    return;
		}
	        if (window.confirm("Delete all lists. Are you sure?")) {
		    this.purge();
		    this.update();
		}
	    });
    }
    _load () {
	return this.listStore.get("all").then(all => {
	    this.name2list = all || {};
	});
    }
    _save () {
	return this.listStore.set("all", this.name2list)
    }
    //
    // returns the names of all the lists, sorted
    getNames () {
        let nms = Object.keys(this.name2list);
	nms.sort();
	return nms;
    }
    // returns true iff a list exists with this name
    has (name) {
        return name in this.name2list;
    }
    // If no list with the given name exists, return the name.
    // Otherwise, return a modified version of name that is unique.
    // Unique names are created by appending a counter.
    // E.g., uniquify("foo") -> "foo.1" or "foo.2" or whatever.
    //
    uniquify (name) {
	if (!this.has(name)) 
	    return name;
	for (let i = 1; ; i += 1) {
	    let nn = `${name}.${i}`;
	    if (!this.has(nn))
	        return nn;
	}
    }
    // returns the list with this name, or null if no such list
    get (name) {
        let lst = this.name2list[name];
	if (!lst) throw "No such list: " + name;
	return lst;
    }
    // returns all the lists, sorted by name
    getAll () {
        return this.getNames().map(n => this.get(n))
    }
    // 
    createOrUpdate (name, ids) {
        return this.has(name) ? this.updateList(name,null,ids) : this.createList(name, ids);
    }
    // creates a new list with the given name and ids.
    createList (name, ids, formula) {
	if (name !== "_")
	    name = this.uniquify(name);
	//
	let dt = new Date() + "";
	this.name2list[name] = {
	    name:     name,
	    ids:      ids,
	    formula:  formula || "",
	    created:  dt,
	    modified: dt
	};
	this._save();
	return this.name2list[name];
    }
    // Provide access to evaluation service
    evalFormula (expr) {
	return this.formulaEval.eval(expr);
    }
    // Refreshes a list and returns a promise for the refreshed list.
    // If the list if a POLO, promise resolves immediately to the list.
    // Otherwise, starts a reevaluation of the formula that resolves after the
    // list's ids have been updated.
    // If there is an error, the returned promise rejects with the error.
    refreshList (name) {
        let lst = this.get(name);
	if (!lst) throw "No such list: " + name;
	lst.modified = ""+new Date();
	if (!lst.formula)
	    return Promise.resolve(lst);
	else {
	    let p = this.formualEval.eval(lst.formula).then( ids => {
		    lst.ids = ids;
		    return lst;
		});
	    return p;
	}
    }

    // updates the ids in the given list
    updateList (name, newname, newids, newformula) {
	let lst = this.get(name);
        if (! lst) throw "No such list: " + name;
	if (newname) {
	    delete this.name2list[lst.name];
	    lst.name = this.uniquify(newname);
	    this.name2list[lst.name] = lst;
	}
	if (newids) lst.ids  = newids;
	if (newformula || newformula==="") lst.formula = newformula;
	lst.modified = new Date() + "";
	this._save();
	return lst;
    }
    // deletes the specified list
    deleteList (name) {
        let lst = this.get(name);
	delete this.name2list[name];
	this._save();
	// FIXME: use events!!
	if (lst === this.app.getCurrentList()) this.app.setCurrentList(null);
	if (lst === this.app.listEditor.list) this.app.listEditor.list = null;
	return lst;
    }
    // delete all lists
    purge () {
        this.name2list = {}
	this._save();
	//
	this.app.setCurrentList(null);
	this.app.listEditor.list = null; // FIXME - reachacross
    }
    // Returns true iff expr is valid, which means it is both syntactically correct 
    // and all mentioned lists exist.
    isValid (expr) {
	return this.formulaEval.isValid(expr);
    }
    //----------------------------------------------
    // Updates the "My lists" box with the currently available lists.
    // Args:
    //   newlist (List) optional. If specified, we just created that list, and its name is
    //   	a generated default. Place focus there so user can type new name.
    update (newlist) {
	let self = this;
        let lists = this.getAll();
	let byName = (a,b) => {
	    let an = a.name.toLowerCase();
	    let bn = b.name.toLowerCase();
	    return (an < bn ? -1 : an > bn ? +1 : 0);
	};
	let byDate = (a,b) => ((new Date(b.modified)).getTime() - (new Date(a.modified)).getTime());
	lists.sort(byName);
	let items = this.root.select('[name="lists"]').selectAll(".listInfo")
	    .data(lists);
	let newitems = items.enter().append("div")
	    .attr("class","listInfo flexrow");

	newitems.append("i").attr("class","material-icons button")
	    .attr("name","edit")
	    .text("mode_edit")
	    .attr("title","Edit this list.");

	newitems.append("span").attr("name","name");

	newitems.append("span").attr("name","size");
	newitems.append("span").attr("name","date");

	newitems.append("i").attr("class","material-icons button")
	    .attr("name","delete")
	    .text("highlight_off")
	    .attr("title","Delete this list.");

	if (newitems[0][0]) {
	    let last = newitems[0][newitems[0].length-1];
	    last.scrollIntoView();
	}

	items
	    .attr("name", lst=>lst.name)
	    .on("click", function (lst) {
		if (d3.event.altKey) {
		    // alt-click copies the list's name into the formula editor
		    let le = self.app.listEditor; // FIXME reachover
		    let s = lst.name;
		    let re = /[ =()+*-]/;
		    if (s.search(re) >= 0)
			s = '"' + s + '"';
		    if (!le.isEditingFormula) {
		        le.open();
			le.openFormulaEditor();
		    }
		    //
		    le.addToListExpr(s+' ');
		}
		else if (d3.event.shiftKey) {
		    // shift-click goes to next list element if it's the same list,
		    // or else sets the list and goes to the first element.
		    if (self.app.getCurrentList() !== lst)
			self.app.setCurrentList(lst, true);
		    else
			self.app.goToNextListElement(lst);
		}
		else {
		    // plain click sets the set if it's a different list,
		    // or else unsets the list.
		    if (self.app.getCurrentList() !== lst)
		        self.app.setCurrentList(lst);
		    else
		        self.app.setCurrentList(null);
		}
	    });
	items.select('.button[name="edit"]')
	    // edit: click 
	    .on("click", function(lst) {
	        self.app.listEditor.open(lst);
	    });
	items.select('span[name="name"]')
	    .text(lst => lst.name);
	items.select('span[name="date"]').text(lst => {
	    let md = new Date(lst.modified);
	    let d = `${md.getFullYear()}-${md.getMonth()+1}-${md.getDate()} ` 
	          + `:${md.getHours()}.${md.getMinutes()}.${md.getSeconds()}`;
	    return d;
	});
	items.select('span[name="size"]').text(lst => lst.ids.length);
	items.select('.button[name="delete"]')
	    .on("click", lst => {
	        this.deleteList(lst.name);
		this.update();

		// Not sure why this is necessary here. But without it, the list item after the one being
		// deleted here will receive a click event.
		d3.event.stopPropagation();
		//
	    });

	//
	items.exit().remove();
	//
	if (newlist) {
	    let lstelt = 
	        d3.select(`#mylists [name="lists"] [name="${newlist.name}"]`)[0][0];
            lstelt.scrollIntoView(false);
	}
    }

} // end class ListManager




/***/ }),
/* 16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ListFormulaEvaluator; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ListFormulaParser__ = __webpack_require__(5);


// ---------------------------------------------
// Knows how to parse and evaluate a list formula (aka list expression).
class ListFormulaEvaluator {
    constructor (listManager) {
	this.listManager = listManager;
        this.parser = new __WEBPACK_IMPORTED_MODULE_0__ListFormulaParser__["a" /* ListFormulaParser */]();
    }
    // Evaluates the expression and returns a Promise for the list of ids.
    // If there is an error, the promise rejects with the error message.
    eval (expr) {
	 return new Promise(function(resolve, reject) {
	     try {
		let ast = this.parser.parse(expr);
		let lm = this.listManager;
		let reach = (n) => {
		    if (typeof(n) === "string") {
			let lst = lm.get(n);
			if (!lst) throw "No such list: " + n;
			return new Set(lst.ids);
		    }
		    else {
			let l = reach(n.left);
			let r = reach(n.right);
			return l[n.op](r);
		    }
		}
		let ids = reach(ast);
		resolve(Array.from(ids));
	    }
	    catch (e) {
		reject(e);
	    }
	 }.bind(this));
    }
    // Checks the current expression for syntactic and semantic validity and sets the 
    // valid/invalid class accordingly. Semantic validity simply means all names in the
    // expression are bound.
    //
    isValid  (expr) {
	try {
	    // first check syntax
	    let ast = this.parser.parse(expr);
	    let lm  = this.listManager; 
	    // now check list names
	    (function reach(n) {
		if (typeof(n) === "string") {
		    let lst = lm.get(n);
		    if (!lst) throw "No such list: " + n
		}
		else {
		    reach(n.left);
		    reach(n.right);
		}
	    })(ast);

	    // Thumbs up!
	    return true;
	}
	catch (e) {
	    // syntax error or unknown list name
	    return false;
	}
    }
}




/***/ }),
/* 17 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ListEditor; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Component__ = __webpack_require__(2);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ListFormulaParser__ = __webpack_require__(5);




// ---------------------------------------------
class ListEditor extends __WEBPACK_IMPORTED_MODULE_1__Component__["a" /* Component */] {
    constructor (app, elt) {
	super(app, elt);
	this.parser = new __WEBPACK_IMPORTED_MODULE_2__ListFormulaParser__["a" /* ListFormulaParser */]();
	this.form = null;
	this.initDom();
	this.isEditingFormula = false;
	//
	this.list = null;
    }
    initDom () {
	let self = this;
	this.form = this.root.select("form")[0][0];
	if (!this.form) throw "Could not init ListEditor. No form element.";
	d3.select(this.form)
	    .on("click", () => {
	        let t = d3.event.target;
		if ("button" === t.tagName.toLowerCase()){
		    d3.event.preventDefault();
		    let f = this.form;
		    let s = f.ids.value.replace(/[,|]/g, ' ').trim();
		    let ids = s ? s.split(/\s+/) : [];
		    // save list
		    if (t.name === "save") {
			if (!this.list) return;
			this.list = this.app.listManager.updateList(this.list.name, f.name.value, ids, f.formula.value);
			this.app.listManager.update(this.list);
		    }
		    // create new list
		    else if (t.name === "new") {
			let n = f.name.value.trim();
			if (!n) {
			   alert("Your list has no name and is very sad. Please give it a name and try again.");
			   return
			}
			else if (n.indexOf('"') >= 0) {
			   alert("Oh dear, your list's name has a double quote character, and I'm afaraid that's not allowed. Please remove the '\"' and try again.");
			   return
			}
		        this.list = this.app.listManager.createList(n, ids, f.formula.value);
			this.app.listManager.update(this.list);
		    }
		    // clear form
		    else if (t.name === "clear") {
		        this.list = null;
		    }
		    // forward to MGI
		    else if (t.name === "toMgi") {
		        let frm = d3.select('#mgibatchform')[0][0];
			frm.ids.value = ids.join(" ");
			frm.submit()
		    }
		    // forward to MouseMine
		    else if (t.name === "toMouseMine") {
		        let frm = d3.select('#mousemineform')[0][0];
			frm.externalids.value = ids.join(",");
			frm.submit()
		    }
		}
	    });

	// Button: show/hide formula editor
	this.root.select('[name="idsection"] .button[name="editformula"]')
	    .on("click", () => this.toggleFormulaEditor());
	    
	// Input box: formula: validate on any input
	this.root.select('[name="formulaeditor"] [name="formula"]')
	    .on("input", () => {
	        this.validateExpr();
	    });

	// Forward -> MGI/MouseMine: disable buttons if no ids
	this.root.select('[name="ids"]')
	    .on("input", () => {
	        let empty = this.form.ids.value.trim().length === 0;
		this.form.toMgi.disabled = this.form.toMouseMine.disabled = empty;
	    });

	// Buttons: the list operator buttons (union, intersection, etc.)
	this.root.selectAll('[name="formulaeditor"] .button.listop')
	    .on("click", function () {
		// add my symbol to the formula
		let inelt = self.form.formula;
		let op = d3.select(this).attr("name");
		self.addToListExpr(op);
		self.validateExpr();
	    });

	// Button: refresh button for running the formula
	this.root.select('[name="formulaeditor"] .button[name="refresh"]')
            .on("click", () => {
		let emessage="I'm terribly sorry, but there appears to be a problem with your list expression: ";
		let formula = this.form.formula.value.trim();
		if (formula.length === 0)
		    return;
	        this.app.listManager
		    .evalFormula(formula)
		    .then(ids => {
		        this.form.ids.value = ids.join("\n");
		     })
		    .catch(e => alert(emessage + e));
	    });

	// Button: close formula editor
	this.root.select('[name="formulaeditor"] .button[name="close"]')
            .on("click", () => this.closeFormulaEditor() );
	
	// Clicking the box collapse button should clear the form
	this.root.select(".button.close")
	    .on("click.extra", () => {
	        this.list = null;
		this.closeFormulaEditor();
	    });
    }
    parseIds (s) {
	return s.replace(/[,|]/g, ' ').trim().split(/\s+/);
    }
    get list () {
        return this._list;
    }
    set list (lst) {
        this._list = lst;
	this._syncDisplay();
    }
    _syncDisplay () {
	let lst = this._list;
	if (!lst) {
	    this.form.name.value = '';
	    this.form.ids.value = '';
	    this.form.ids.disabled = false;
	    this.form.modified.value = '';
	    this.form.formula.value = '';
	    this.form.save.disabled = true;
	    this.form.toMgi.disabled = true;
	    this.form.toMouseMine.disabled = true;
	}
	else {
	    this.form.name.value = lst.name;
	    this.form.ids.value = lst.ids.join('\n');
	    this.form.formula.value = lst.formula || "";
	    this.form.ids.disabled = this.form.formula.value.trim().length > 0;
	    this.form.modified.value = lst.modified;
	    this.form.save.disabled = false;
	    this.form.toMgi.disabled 
	      = this.form.toMouseMine.disabled 
	        = (this.form.ids.value.trim().length === 0);
	}
	this.validateExpr();
    }
    clear () {
        this.list = null;
    }
    open (lst) {
        this.list = lst;
	this.root.classed("closed", false);
    }
    close () {
        this.list = null;
	this.root.classed("closed", true);
    }
    openFormulaEditor () {
	this.root.classed("editingformula", true);
	this.isEditingFormula = true;
	let f = this.form.formula.value;
	this.form.formula.focus();
	Object(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* setCaretPosition */])(this.form.formula, f.length);
    }
    closeFormulaEditor () {
	this.root.classed("editingformula", false);
	this.isEditingFormula = false;
    }
    toggleFormulaEditor () {
	let showing = this.root.classed("editingformula");
	showing ? this.closeFormulaEditor() : this.openFormulaEditor();
    }
    //----------------------------------------------
    // Checks the current expression and sets the valid/invalid class.
    validateExpr  () {
	let inp = this.root.select('[name="formulaeditor"] [name="formula"]');
	let expr = inp[0][0].value.trim();
	if (!expr) {
	    inp.classed("valid",false).classed("invalid",false);
 	    this.form.ids.disabled = false;
	}
	else {
	    let isValid = this.app.listManager.isValid(expr); // FIXME - reachover
	    inp.classed("valid", isValid).classed("invalid", !isValid);
 	    this.form.ids.disabled = true;
	}
    }
    //----------------------------------------------
    addToListExpr (text) {
	let inp = this.root.select('[name="formulaeditor"] [name="formula"]');
	let ielt = inp[0][0];
	let v = ielt.value;
	let splice = function (e,t){
	    let v = e.value;
	    let r = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["f" /* getCaretRange */])(e);
	    e.value = v.slice(0,r[0]) + t + v.slice(r[1]);
	    Object(__WEBPACK_IMPORTED_MODULE_0__utils__["m" /* setCaretPosition */])(e, r[0]+t.length);
	    e.focus();
	}
	let range = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["f" /* getCaretRange */])(ielt);
	if (range[0] === range[1]) {
	    // no current selection
	    splice(ielt, text);
	    if (text === "()") 
		Object(__WEBPACK_IMPORTED_MODULE_0__utils__["h" /* moveCaretPosition */])(ielt, -1);
	}
	else {
	    // there is a current selection
	    if (text === "()")
		// surround current selection with parens, then move caret after
		text = '(' + v.slice(range[0],range[1]) + ')';
	    splice(ielt, text)
	}
	this.validateExpr();
    }
} // end class ListEditor




/***/ }),
/* 18 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FacetManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Facet__ = __webpack_require__(19);


//----------------------------------------------
class FacetManager {
    constructor (app) {
	this.app = app;
	this.facets = [];
	this.name2facet = {}
    }
    addFacet (name, valueFcn) {
	if (this.name2facet[name]) throw "Duplicate facet name. " + name;
	let facet = new __WEBPACK_IMPORTED_MODULE_0__Facet__["a" /* Facet */](name, this, valueFcn);
        this.facets.push( facet );
	this.name2facet[name] = facet;
	return facet
    }
    test (f) {
        let vals = this.facets.map( facet => facet.test(f) );
	return vals.reduce((accum, val) => accum && val, true);
    }
    applyAll () {
	let show = null;
	let hide = "none";
	// FIXME: major reachover
	this.app.zoomView.svgMain.select("g.strips").selectAll('.feature')
	    .style("display", f => this.test(f) ? show : hide);
    }
} // end class FacetManager




/***/ }),
/* 19 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Facet; });
//----------------------------------------------
class Facet {
    constructor (name, manager, valueFcn) {
	this.manager = manager;
        this.name = name;
	this.values = [];
	this.valueFcn = valueFcn;
    }
    setValues (values, quietly) {
        this.values = values;
	if (! quietly) {
	    this.manager.applyAll();
	    this.manager.app.zoomView.highlight();
	}
    }
    test (f) {
        return !this.values || this.values.length === 0 || this.values.indexOf( this.valueFcn(f) ) >= 0;
    }
} // end class Facet




/***/ }),
/* 20 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BTManager; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__BlockTranslator__ = __webpack_require__(21);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__KeyStore__ = __webpack_require__(3);




//----------------------------------------------
// BlockTranslator manager class. For any given pair of genomes, A and B, loads the single block file
// for translating between them, and indexes it "from both directions":
// 	A->B-> [AB_BlockFile] <-A<-B
//
class BTManager {
    constructor (app) {
        this.app = app;
	this.rcBlocks = {};
	this.blockStore = new __WEBPACK_IMPORTED_MODULE_2__KeyStore__["a" /* KeyStore */]('synteny-blocks');
    }

    //----------------------------------------------
    registerBlocks (aGenome, bGenome, blocks) {
	let aname = aGenome.name;
	let bname = bGenome.name;
	console.log(`Registering blocks: ${aname} vs ${bname}`, `#blocks=${blocks.length}`);
	let blkFile = new __WEBPACK_IMPORTED_MODULE_1__BlockTranslator__["a" /* BlockTranslator */](aGenome,bGenome,blocks);
	if( ! this.rcBlocks[aname]) this.rcBlocks[aname] = {};
	if( ! this.rcBlocks[bname]) this.rcBlocks[bname] = {};
	this.rcBlocks[aname][bname] = blkFile;
	this.rcBlocks[bname][aname] = blkFile;
    }

    //----------------------------------------------
    // Loads the synteny block file for genomes aGenome and bGenome.
    // 
    getBlockFile (aGenome, bGenome) {
	// Be a little smart about the order we try the names...
	if (bGenome.name < aGenome.name) {
	    let tmp = aGenome; aGenome = bGenome; bGenome = tmp;
	}
	// First, see if we already have this pair
	let aname = aGenome.name;
	let bname = bGenome.name;
	let bf = (this.rcBlocks[aname] || {})[bname];
	if (bf)
	    return Promise.resolve(bf);
	
	// Second, try local disk cache
	let key = aname + '-' + bname;
	return this.blockStore.get(key).then(data => {
	    if (data) {
		console.log("Found blocks in cache.");
	        return this.registerBlocks(aGenome, bGenome, data);
	    }
	    else if (this.serverRequest) {
	        // if there is an outstanding request, wait until it's done and try again.
		return this.serverRequest.then(()=>this.getBlockFile(aGenome, bGenome));
	    }
	    else {
		// Third, load from server.
		let fn = `./data/blocks.tsv`
		console.log("Requesting block file from: " + fn);
		this.serverRequest = Object(__WEBPACK_IMPORTED_MODULE_0__utils__["d" /* d3tsv */])(fn).then(blocks => {
		    let rbs = blocks.reduce( (a,b) => {
			let k = b.aGenome + '-' + b.bGenome;
			if (!(k in a)) a[k] = [];
			    a[k].push(b);
			    return a;
			}, {});
		    for (let n in rbs) {
		        this.blockStore.set(n, rbs[n]);
		    }
		}).then(() => this.getBlockFile(aGenome, bGenome));
		return this.serverRequest;
	    }
	});
    }

    //----------------------------------------------
    // Returns a promise that is fulfilled when the translator has loaded all the data needed
    // for translating coordinates between the current ref strain and the current comparison strains.
    //
    ready () {
	let promises = this.app.cGenomes.map(cg => this.getBlockFile(this.app.rGenome, cg));
	return Promise.all(promises)
    }

    //----------------------------------------------
    // Returns the synteny block translator that maps the current ref genome to the specified comparison genome.
    //
    getBlocks (fromGenome, toGenome) {
        let blkTrans = this.rcBlocks[fromGenome.name][toGenome.name];
	return blkTrans.getBlocks(fromGenome)
    }

    //----------------------------------------------
    // Translates the given coordinate range from the specified fromGenome to the specified toGenome.
    // Returns a list of zero or more coordinate ranges in the toGenome.
    //
    translate (fromGenome, chr, start, end, toGenome, inverted) {
	// get the right block file
	let blkTrans = this.rcBlocks[fromGenome.name][toGenome.name];
	if (!blkTrans) throw "Internal error. No block file found in index."
	// translate!
	let ranges = blkTrans.translate(fromGenome, chr, start, end, inverted);
	return ranges;
    }
    //----------------------------------------------
    clearCachedData () {
	console.log("BTManager: Cache cleared.")
        return this.blockStore.clear();
    }
} // end class BTManager




/***/ }),
/* 21 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return BlockTranslator; });
// ---------------------------------------------
// Something that knows how to translate coordinates between two genomes.
//
//
class BlockTranslator {
    constructor(aGenome, bGenome, blocks){
	this.aGenome = aGenome;
	this.bGenome = bGenome;
	this.blocks = blocks.map(b => this.processBlock(b))
	this.currSort = "a"; // either 'a' or 'b'
    }
    processBlock (blk) { 
        blk.aIndex = parseInt(blk.aIndex);
        blk.bIndex = parseInt(blk.bIndex);
        blk.aStart = parseInt(blk.aStart);
        blk.bStart = parseInt(blk.bStart);
        blk.aEnd   = parseInt(blk.aEnd);
        blk.bEnd   = parseInt(blk.bEnd);
	blk.abMap = d3.scale.linear()
	    .domain([blk.aStart,blk.aEnd])
	    .range( blk.blockOri==="-" ? [blk.bEnd,blk.bStart] : [blk.bStart,blk.bEnd]);
	blk.baMap = blk.abMap.invert
	return blk;
    }
    setSort (which) {
	if (which !== 'a' && which !== 'b') throw "Bad argument:" + which;
	let sortCol = which + "Index";
	let cmp = (x,y) => x[sortCol] - y[sortCol];
	this.blocks.sort(cmp);
	this.currSort = which;
    }
    flipSort () {
	this.setSort(this.currSort === "a" ? "b" : "a");
    }
    // Given a genome (either the a or b genome) and a coordinate range,
    // returns the equivalent coordinate range(s) in the other genome
    translate (fromGenome, chr, start, end, invert) {
	//
	end = end === undefined ? start : end;
	// from = "a" or "b", depending on which genome is given.
        let from = (fromGenome === this.aGenome ? "a" : fromGenome === this.bGenome ? "b" : null);
	if (!from) throw "Bad argument. Genome neither A nor B.";
	// to = "b" or "a", opposite of from
	let to = (from === "a" ? "b" : "a");
	// make sure the blocks are sorted by the from genome
	this.setSort(from);
	//
	let fromC = from+"Chr";
	let fromS = from+"Start";
	let fromE = from+"End";
	let fromI = from+"Index";
	let toC = to+"Chr";
	let toS = to+"Start";
	let toE = to+"End";
	let toI = to+"Index";
	let mapper = from+to+"Map";
	// 
	let blks = this.blocks
	    // First filter for blocks that overlap the given coordinate range in the from genome
	    .filter(blk => blk[fromC] === chr && blk[fromS] <= end && blk[fromE] >= start)
	    // map each block. 
	    .map(blk => {
		// coord range on the from side.
		let s = Math.max(start, blk[fromS]);
		let e = Math.min(end, blk[fromE]);
		// coord range on the to side.
		let s2 = Math.ceil(blk[mapper](s));
		let e2 = Math.floor(blk[mapper](e));
	        return invert ? {
		    chr:   blk[fromC],
		    start: s,
		    end:   e,
		    ori:   blk.blockOri,
		    index: blk[fromI],
		    // also return the fromGenome coords for this piece of the translation
		    fChr:   blk[toC],
		    fStart: Math.min(s2,e2),
		    fEnd:   Math.max(s2,e2),
		    fIndex: blk[toI],
		    // include the block id and full block coords
		    blockId: blk.blockId,
		    blockStart: blk[fromS],
		    blockEnd: blk[fromE]
		} : {
		    chr:   blk[toC],
		    start: Math.min(s2,e2),
		    end:   Math.max(s2,e2),
		    ori:   blk.blockOri,
		    index: blk[toI],
		    // also return the fromGenome coords for this piece of the translation
		    fChr:   blk[fromC],
		    fStart: s,
		    fEnd:   e,
		    fIndex: blk[fromI],
		    // include the block id and full block coords
		    blockId: blk.blockId,
		    blockStart: blk[toS],
		    blockEnd: blk[toE]
		};
	    });
	if (!invert) {
	    // Look for 1-block gaps and fill them in. 
	    blks.sort((a,b) => a.index - b.index);
	    let nbs = [];
	    blks.forEach( (b, i) => {
		if (i === 0) return;
		if (blks[i].index - blks[i - 1].index === 2) {
		    let blk = this.blocks.filter( b => b[toI] === blks[i].index - 1 )[0];
		    nbs.push({
			chr:   blk[toC],
			start: blk[toS],
			end:   blk[toE],
			ori:   blk.blockOri,
			index: blk[toI],
			// also return the fromGenome coords for this piece of the translation
			fChr:   blk[fromC],
			fStart: blk[fromS],
			fEnd:   blk[fromE],
			fIndex: blk[fromI],
			// include the block id and full block coords
			blockId: blk.blockId,
			blockStart: blk[toS],
			blockEnd: blk[toE]
		    });
		}
	    });
	    blks = blks.concat(nbs);
	}
	blks.sort((a,b) => a.fIndex - b.fIndex);
	return blks;
    }
    // Given a genome (either the a or b genome)
    // returns the blocks for translating to the other (b or a) genome.
    //
    getBlocks (fromGenome) {
	// from = "a" or "b", depending on which genome is given.
        let from = (fromGenome === this.aGenome ? "a" : fromGenome === this.bGenome ? "b" : null);
	if (!from) throw "Bad argument. Genome neither A nor B.";
	// to = "b" or "a", opposite of from
	let to = (from === "a" ? "b" : "a");
	// make sure the blocks are sorted by the from genome
	this.setSort(from);
	//
	let fromC = from+"Chr";
	let fromS = from+"Start";
	let fromE = from+"End";
	let fromI = from+"Index";
	let toC = to+"Chr";
	let toS = to+"Start";
	let toE = to+"End";
	let toI = to+"Index";
	let mapper = from+to+"Map";
	// 
	let blks = this.blocks
	    .map(blk => {
	        return {
		    blockId:   blk.blockId,
		    ori:       blk.blockOri,
		    fromChr:   blk[fromC],
		    fromStart: blk[fromS],
		    fromEnd:   blk[fromE],
		    fromIndex: blk[fromI],
		    toChr:     blk[toC],
		    toStart:   blk[toS],
		    toEnd:     blk[toE],
		    toIndex:   blk[toI]
		};
	    })
	// 
	return blks;
    }
}




/***/ }),
/* 22 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return GenomeView; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__SVGView__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils__ = __webpack_require__(0);



// ---------------------------------------------
class GenomeView extends __WEBPACK_IMPORTED_MODULE_0__SVGView__["a" /* SVGView */] {
    //----------------------------------------------
    constructor (app, elt, width, height) {
        super(app, elt, width, height);
	this.openWidth = this.outerWidth;
	this.openHeight= this.outerHeight;
	this.totalChrWidth = 40; // total width of one chromosome (backbone+blocks+feats)
	this.cwidth = 20;        // chromosome width
	this.tickLength = 10;	 // feature tick mark length
	this.brushChr = null;	 // which chr has the current brush
	this.bwidth = this.cwidth/2;  // block width
	this.currBlocks = null;
	this.currTicks = null;
	this.gChromosomes = this.svgMain.append('g').attr("name", "chromosomes");
	this.title    = this.svgMain.append('text').attr("class", "title");
	this.scrollAmount = 0;
	//
	this.initDom();
    }
    //----------------------------------------------
    fitToWidth (w){
        super.fitToWidth(w);
	this.openWidth = this.outerWidth;
    }
    //----------------------------------------------
    initDom () {
	this.root.select('.button.close')
	    .on('click', () => this.redraw());
	this.svg.on("wheel", () => {
	    if (!this.root.classed("closed")) return;
	    this.scrollWheel(d3.event.deltaY)
	    d3.event.preventDefault();
	});
	let sbs = this.root.select('[name="svgcontainer"] > [name="scrollbuttons"]')
	sbs.select('.button[name="up"]').on("click", () => this.scrollChromosomesUp());
	sbs.select('.button[name="dn"]').on("click", () => this.scrollChromosomesDown());
    }

    //----------------------------------------------
    setBrushCoords (coords) {
	this.clearBrushes();
	this.gChromosomes.select(`.chromosome[name="${coords.chr}"] g[name="brush"]`)
	  .each(function(chr){
	    chr.brush.extent([coords.start,coords.end]);
	    chr.brush(d3.select(this));
	});
    }
    //----------------------------------------------
    brushstart (chr){
	this.clearBrushes(chr.brush);
	this.brushChr = chr;
    }

    //----------------------------------------------
    brushend (){
	if(!this.brushChr) return;
	let cc = this.app.coords;
	var xtnt = this.brushChr.brush.extent();
	if (Math.abs(xtnt[0] - xtnt[1]) <= 10){
	    // user clicked
	    let w = cc.end - cc.start + 1;
	    xtnt[0] -= w/2;
	    xtnt[1] += w/2;
	}
	let coords = { chr:this.brushChr.name, start:Math.floor(xtnt[0]), end: Math.floor(xtnt[1]) };
	this.app.setContext(coords);
    }

    //----------------------------------------------
    clearBrushes (except){
	this.gChromosomes.selectAll('[name="brush"]').each(function(chr){
	    if (chr.brush !== except) {
		chr.brush.clear();
		chr.brush(d3.select(this));
	    }
	});
    }

    //----------------------------------------------
    getX (chr) {
	let x = this.app.rGenome.xscale(chr);
	if (isNaN(x)) throw "x is NaN"
	return x;
    }
    //----------------------------------------------
    getY (pos) {
	let y = this.app.rGenome.yscale(pos);
	if (isNaN(y)) throw "y is NaN"
	return y;
    }
    
    //----------------------------------------------
    redraw () {
        this.draw(this.currTicks, this.currBlocks);
    }

    //----------------------------------------------
    draw (tickData, blockData) {
	this.drawChromosomes();
	this.drawBlocks(blockData);
	this.drawTicks(tickData);
	this.drawTitle();
	this.setBrushCoords(this.app.coords);
    }

    // ---------------------------------------------
    // Draws the chromosomes of the reference genome.
    // Includes backbones, labels, and brushes.
    // The backbones are drawn as vertical line sements,
    // distributed horizontally. Ordering is defined by
    // the model (Genome object).
    // Labels are drawn above the backbones.
    //
    // Modification:
    // Draws the scene in one of two states: open or closed.
    // The open state is as described - all chromosomes shown.
    // In the closed state: 
    //     * only one chromosome shows (the current one)
    //     * drawn horizontally and positioned beside the "Genome View" title
    //
    drawChromosomes () {
	let self = this;

	let rg = this.app.rGenome; // ref genome
	let rChrs = rg.chromosomes;

        // Chromosome groups
	let chrs = this.gChromosomes.selectAll(".chromosome")
	    .data(rChrs, c => c.name);
	let newchrs = chrs.enter().append("g")
	    .attr("class", "chromosome")
	    .attr("name", c => c.name);
	
	newchrs.append("text").attr("name","label");
	newchrs.append("line").attr("name","backbone");
	newchrs.append("g").attr("name","synBlocks");
	newchrs.append("g").attr("name","ticks");
	newchrs.append("g").attr("name","brush");


	let closed = this.root.classed("closed");
	// set direction of the resize cursor.
	chrs.selectAll('g[name="brush"] g.resize').style('cursor', closed ? 'ew-resize' : 'ns-resize')
	//
	if (closed) {
	    // Reset the SVG size to be 1-chromosome wide.
	    // Translate the chromosomes group so that the current chromosome appears in the svg area.
	    // Turn it 90 deg.

	    // Set the height of the SVG area to 1 chromosome's width
	    this.setGeom({ height: this.totalChrWidth, rotation: -90, translation: [-this.totalChrWidth/2+10,30] });
	    // 
	    let delta = 10;
	    rg.xscale = d3.scale.ordinal()
		 .domain(rChrs.map(function(x){return x.name;}))
		 // in closed mode, the chromosomes have fixed spacing
		 .rangePoints([delta, delta+this.totalChrWidth*(rChrs.length-1)]);
	    //
	    rg.yscale = d3.scale.linear()
		 .domain([1,rg.maxlen])
		 .range([0, this.width]);

	    // translate each chromosome into position
	    chrs.attr("transform", c => `translate(${rg.xscale(c.name)}, 0)`);
            // translate the chromosomes group.
	    this.scrollChromosomesTo(-rg.xscale(this.app.coords.chr));
	    this.scrollChromosomesSnap();
	}
	else {
	    // When open, draw all the chromosomes. Each chrom is a vertical line.
	    // Chroms are distributed evenly across the available horizontal space.
	    this.setGeom({ width: this.openWidth, height: this.openHeight, rotation: 0, translation: [0,0] });
	    // 
	    rg.xscale = d3.scale.ordinal()
		 .domain(rChrs.map(function(x){return x.name;}))
		 // in closed mode, the chromosomes spread to fill the space
		 .rangePoints([0, this.openWidth - 30], 0.5);
	    rg.yscale = d3.scale.linear()
		 .domain([1,rg.maxlen])
		 .range([0, this.height]);

	    // translate each chromosome into position
	    chrs.attr("transform", c => `translate(${rg.xscale(c.name)}, 0)`);
            // translate the chromosomes group.
	    this.scrollChromosomesTo(0);
	}

	rChrs.forEach(chr => {
	    var sc = d3.scale.linear()
		.domain([1,chr.length])
		.range([0, rg.yscale(chr.length)]);
	    chr.brush = d3.svg.brush().y(sc)
	       .on("brushstart", chr => this.brushstart(chr))
	       .on("brushend", () => this.brushend());
	  }, this);


        chrs.select('[name="label"]')
	    .text(c=>c.name)
	    .attr("x", 0) 
	    .attr("y", -2)
	    ;

	chrs.select('[name="backbone"]')
	    .attr("x1", 0)
	    .attr("y1", 0)
	    .attr("x2", 0)
	    .attr("y2", c => rg.yscale(c.length))
	    ;
	   
	chrs.select('[name="brush"]')
	    .each(function(d){d3.select(this).call(d.brush);})
	    .selectAll('rect')
	     .attr('width',16)
	     .attr('x', -8)
	    ;

	chrs.exit().remove();
	
    }

    // ---------------------------------------------
    // Scroll wheel event handler.
    scrollWheel (dy) {
	// Add dy to total scroll amount. Then translate the chromosomes group.
	this.scrollChromosomesBy(dy);
	// After a 200 ms pause in scrolling, snap to nearest chromosome
	this.tout && window.clearTimeout(this.tout);
	this.tout = window.setTimeout(()=>this.scrollChromosomesSnap(), 200);
    }
    scrollChromosomesTo (x) {
        if (x === undefined) x = this.scrollAmount;
	this.scrollAmount = Math.max(Math.min(x,15), -this.totalChrWidth * (this.app.rGenome.chromosomes.length-1));
	this.gChromosomes.attr("transform", `translate(${this.scrollAmount},0)`);
    }
    scrollChromosomesBy (dx) {
        this.scrollChromosomesTo(this.scrollAmount + dx);
    }
    scrollChromosomesSnap () {
	let i = Math.round(this.scrollAmount / this.totalChrWidth)
	this.scrollChromosomesTo(i*this.totalChrWidth);
    }
    scrollChromosomesUp () {
        this.scrollChromosomesBy(-this.totalChrWidth);
	this.scrollChromosomesSnap();
    }
    scrollChromosomesDown () {
        this.scrollChromosomesBy(this.totalChrWidth);
	this.scrollChromosomesSnap();
    }
    // ---------------------------------------------
    drawTitle () {
	let refg = this.app.rGenome.label;
	let blockg = this.currBlocks ? 
	    this.currBlocks.comp !== this.app.rGenome ?
	        this.currBlocks.comp.label
		:
		null
	    :
	    null;
	let lst = this.app.currList ? this.app.currList.name : null;

	this.root.select("label span.title").text(refg);

	let lines = [];
	blockg && lines.push(`Blocks vs. ${blockg}`);
	lst && lines.push(`Features from list "${lst}"`);
	let subt = lines.join(" :: ");
	this.root.select("label span.subtitle").text((subt ? ":: " : "") + subt);
    }

    // ---------------------------------------------
    // Draws the outlines of synteny blocks of the ref genome vs.
    // the given genome.
    // Passing null erases all synteny blocks.
    // Args:
    //    data == { ref:Genome, comp:Genome, blocks: list of synteny blocks }
    //    Each sblock === { blockId:int, ori:+/-, fromChr, fromStart, fromEnd, toChr, toStart, toEnd }
    drawBlocks (data) {
	//
        let sbgrps = this.gChromosomes.selectAll(".chromosome").select('[name="synBlocks"]');
	if (!data || !data.blocks || data.blocks.length === 0) {
	    this.currBlocks = null;
	    sbgrps.html('');
	    this.drawTitle();
	    return;
	}
	this.currBlocks = data;
	// reorganize data to reflect SVG structure we want, ie, grouped by chromosome
        let dx = data.blocks.reduce((a,sb) => {
		if (!a[sb.fromChr]) a[sb.fromChr] = [];
		a[sb.fromChr].push(sb);
		return a;
	    }, {});
	sbgrps.each(function(c){
	    d3.select(this).datum({chr: c.name, blocks: dx[c.name] || [] });
	});

	let bwidth = 10;
        let sblocks = sbgrps.selectAll('rect.sblock').data(b=>b.blocks);
        let newbs = sblocks.enter().append('rect').attr('class','sblock');
	sblocks
	    .attr("x", -bwidth/2 )
	    .attr("y", b => this.getY(b.fromStart))
	    .attr("width", bwidth)
	    .attr("height", b => Math.max(0,this.getY(b.fromEnd - b.fromStart + 1)))
	    .classed("inversion", b => b.ori === "-")
	    .classed("translocation", b => b.fromChr !== b.toChr)
	    ;

        sblocks.exit().remove();

	this.drawTitle();
    }

    // ---------------------------------------------
    drawTicks (ids) {
	this.currTicks = ids || [];
	this.app.featureManager.getFeaturesById(this.app.rGenome, this.currTicks)
	    .then( feats => { this._drawTicks(feats); });
    }
    // ---------------------------------------------
    _drawTicks (features) {
	let rg = this.app.rGenome; // ref genome
	// feature tick marks
	if (!features || features.length === 0) {
	    this.gChromosomes.selectAll('[name="ticks"]').selectAll(".feature").remove();
	    return;
	}

	//
	let tGrps = this.gChromosomes.selectAll(".chromosome").select('[name="ticks"]');

	// group features by chromosome
        let fix = features.reduce((a,f) => { 
	    if (! a[f.chr]) a[f.chr] = [];
	    a[f.chr].push(f);
	    return a;
	}, {})
	tGrps.each(function(c) {
	    d3.select(this).datum( { chr: c, features: fix[c.name]  || []} );
	});

	// the tick elements
        let feats = tGrps.selectAll(".feature")
	    .data(d => d.features, d => d.ID);
	//
	let xAdj = f => (f.strand === "+" ? this.tickLength : -this.tickLength);
	//
	let shape = "circle";  // "circle" or "line"
	//
	let newfs = feats.enter()
	    .append(shape)
	    .attr("class","feature")
	    .on('click', (f) => {
		let i = f.canonical||f.ID;
	        this.app.setContext({landmark:i, highlight:[i]});
	    }) ;
	newfs.append("title")
		.text(f=>f.symbol || f.id);
	if (shape === "line") {
	    feats.attr("x1", f => xAdj(f) + 5)
	    feats.attr("y1", f => rg.yscale(f.start))
	    feats.attr("x2", f => xAdj(f) + this.tickLength + 5)
	    feats.attr("y2", f => rg.yscale(f.start))
	}
	else {
	    feats.attr("cx", f => xAdj(f))
	    feats.attr("cy", f => rg.yscale(f.start))
	    feats.attr("r",  this.tickLength / 2);
	}
	//
	feats.exit().remove()
    }
} // end class GenomeView




/***/ }),
/* 23 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return FeatureDetails; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Component__ = __webpack_require__(2);


class FeatureDetails extends __WEBPACK_IMPORTED_MODULE_0__Component__["a" /* Component */] {
    //----------------------------------------------
    constructor (app, elt) {
        super(app, elt);
	this.initDom ();
    }

    //----------------------------------------------
    initDom () {
	//
	this.root.select (".button.close")
	    .on("click.extra", () => this.update());
    }

    //----------------------------------------------
    //
    update(f) {
	// if called with no args, update using the previous feature
	f = f || this.lastFeature;
	if (!f) {
	   // FIXME: major reachover in this section
	   //
	   // fallback. take the first highlighted.
	   let r = this.app.zoomView.svgMain.select("rect.feature.highlight")[0][0];
	   // fallback. take the first feature
	   if (!r) r = this.app.zoomView.svgMain.select("rect.feature")[0][0];
	   if (r) f = r.__data__;
	}
	// remember
        if (!f) throw "Cannot update feature details. No feature.";
	this.lastFeature = f;

	// list of features to show in details area.
	// the given feature and all equivalents in other genomes.
	let flist = [f];
	if (f.canonical) {
	    // FIXME: reachover
	    flist = this.app.featureManager.getCachedFeaturesByCanonicalId(f.canonical);
	}
	// Got the list. Now order it the same as the displayed genomes
	// build index of genome name -> feature in flist
	let ix = flist.reduce((acc,f) => { acc[f.genome.name] = f; return acc; }, {})
	let genomeOrder = ([this.app.rGenome].concat(this.app.cGenomes));
	flist = genomeOrder.map(g => ix[g.name] || null);
	//
	let colHeaders = [
	    // columns headers and their % widths
	    ["Canonical id"     ,10],
	    ["Canonical symbol" ,10],
	    ["Genome"     ,9],
	    ["ID"     ,17],
	    ["Type"       ,10.5],
	    ["BioType"    ,18.5],
	    ["Coordinates",18],
	    ["Length"     ,7]
	];
	// In the closed state, only show the header and the row for the passed feature
	if (this.root.classed('closed'))
	    flist = flist.filter( (ff, i) => ff === f );
	// Draw the table
	let t = this.root.select('table');
	let rows = t.selectAll('tr').data( [colHeaders].concat(flist) );
	rows.enter().append('tr')
	  .on("mouseenter", (f,i) => i !== 0 && this.app.zoomView.highlight(f, true))
	  .on("mouseleave", (f,i) => i !== 0 && this.app.zoomView.highlight());
	      
	rows.exit().remove();
	rows.classed("highlight", (ff, i) => (i !== 0 && ff === f));
	//
	// Given a feature, returns a list of strings for populating a table row.
	// If i===0, then f is not a feature, but a list columns names+widths.
	// 
	let cellData = function (f, i) {
	    if (i === 0) {
		return f;
	    }
	    let cellData = [ ".", ".", genomeOrder[i-1].label, ".", ".", ".", ".", "." ];
	    // f is null if it doesn't exist for genome i 
	    if (f) {
		let link = "";
		let canonical = f.canonical || "";
		if (canonical) {
		    let url = `http://www.informatics.jax.org/accession/${canonical}`;
		    link = `<a target="_blank" href="${url}">${canonical}</a>`;
		}
		cellData = [
		    link || canonical,
		    f.symbol,
		    f.genome.label,
		    f.ID,
		    f.type,
		    f.biotype,
		    `${f.chr}:${f.start}..${f.end} (${f.strand})`,
		    `${f.end - f.start + 1} bp`
		];
	    }
	    return cellData;
	};
	let cells = rows.selectAll("td")
	    .data((f,i) => cellData(f,i));
	cells.enter().append("td");
	cells.exit().remove();
	cells.html((d,i,j) => {
	    return j === 0 ? d[0] : d
	})
	.style("width", (d,i,j) => j === 0 ? `${d[1]}%` : null);
    }
}




/***/ }),
/* 24 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return ZoomView; });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__config__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__SVGView__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Feature__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils__ = __webpack_require__(0);





// ---------------------------------------------
class ZoomView extends __WEBPACK_IMPORTED_MODULE_1__SVGView__["a" /* SVGView */] {
    //
    constructor (app, elt, width, height, initialCoords, initialHi) {
      super(app, elt, width, height);
      //
      let self = this;
      //
      this.drawCount = 0;
      this.cfg = __WEBPACK_IMPORTED_MODULE_0__config__["a" /* default */].ZoomView;
      this.dmode = 'comparison';// drawing mode. 'comparison' or 'reference'
      // A feature may be rendered in one of two ways: as a simple rect, or as a group containing the 
      // rect and other stuff like text, an axis line, etc.
      this._showFeatureDetails = false; // if true, show transcript/exon structure
      this._showAllLabels = true; // if true, show all feature labels (only if showFeatureDetail = true)
      this.clearAll = false; // if true, remove/rerender all existing features on next draw
      //
      // IDs of Features we're highlighting. May be feature's ID  or canonical IDr./
      // hiFeats is an obj whose keys are the IDs
      this.hiFeats = (initialHi || []).reduce( (a,v) => { a[v]=v; return a; }, {} );
      this.dragging = null;
      this.dragger = this.getDragger();
      //
	// Config for menu under menu button
	this.cxtMenuCfg = [{
	    name: 'linkToSnps',
	    label: 'MGI SNPs', 
	    icon: 'open_in_new',
	    tooltip: 'View SNPs at MGI for the current strains in the current region. (Some strains not available.)',
	    handler: ()=> this.app.linkToMgiSnpReport()
	},{
	    name: 'linkToQtl',
	    label: 'MGI QTLs', 
	    icon:  'open_in_new',
	    tooltip: 'View QTL at MGI that overlap the current region.',
	    handler: ()=> this.app.linkToMgiQTLs()
	},{
	    name: 'linkToJbrowse',
	    label: 'MGI JBrowse', 
	    icon: 'open_in_new',
	    tooltip: 'Open MGI JBrowse (C57BL/6J GRCm38) with the current coordinate range.',
	    handler: ()=> this.app.linkToMgiJBrowse()
	},{
	    name: 'clearCache',
	    label: 'Clear cache', 
	    icon: 'delete_sweep',
	    tooltip: 'Delete cached features. Data will be reloaded from the server on next use.',
	    handler: ()=> this.app.clearCachedData(true)
	}];

	// config for a feature's context menu
	this.fcxtMenuCfg = [{
	    name: 'menuTitle',
	    label: (d) => `${d.symbol || d.ID}`, 
	    cls: 'menuTitle'
	},{
	    name: 'lineUpOnFeature',
	    label: 'Align on this feature.',
	    icon: 'format_align_center',
	    tooltip: 'Aligns the displayed genomes around this feature.',
	    handler: (f) => {
		let ids = (new Set(Object.keys(this.hiFeats))).add(f.id);
	        this.app.setContext({landmark:f.id, delta:0, highlight:Array.from(ids)})
	    }
	},{
	    name: 'toMGI',
	    label: 'Feature@MGI', 
	    icon: 'open_in_new',
	    tooltip: 'See details for this feature at MGI.',
	    handler: (f) => { window.open(`http://www.informatics.jax.org/accession/${f.id}`, '_blank') }
	},{
	    name: 'toMouseMine',
	    label: 'Feature@MouseMine', 
	    icon: 'open_in_new',
	    tooltip: 'See details for this feature at MouseMine.',
	    handler: (f) => this.app.linkToReportPage(f)
	},{
	    name: 'genomicSeqDownload',
	    label: 'Genomic sequences', 
	    icon: 'cloud_download',
	    tooltip: 'Download genomic sequences for this feature from currently displayed genomes.',
	    handler: (f) => { 
		this.app.downloadFasta(f, 'genomic', this.app.vGenomes.map(vg=>vg.label));
	    }
	},{
	    name: 'txpSeqDownload',
	    label: 'Transcript sequences', 
	    icon: 'cloud_download',
	    tooltip: 'Download transcript sequences of this feature from currently displayed genomes.',
	    handler: (f) => { 
		this.app.downloadFasta(f, 'transcript', this.app.vGenomes.map(vg=>vg.label));
	    }
	},{
	    name: 'cdsSeqDownload',
	    label: 'CDS sequences', 
	    icon: 'cloud_download',
	    tooltip: 'Download coding sequences of this feature from currently displayed genomes.',
	    disabler: (f) => f.biotype.indexOf('protein') === -1, // disable if f is not protein coding
	    handler: (f) => { 
		this.app.downloadFasta(f, 'cds', this.app.vGenomes.map(vg=>vg.label));
	    }
	},{
	    name: 'exonSeqDownload',
	    label: 'Exon sequences', 
	    icon: 'cloud_download',
	    tooltip: 'Download exon sequences of this feature from currently displayed genomes.',
	    disabler: (f) => f.type.indexOf('gene') === -1,
	    handler: (f) => { 
		this.app.downloadFasta(f, 'exon', this.app.vGenomes.map(vg=>vg.label));
	    }
	}];
      //
      this.initDom();
    }
    //
    initDom () {
        let self = this;
	let r = this.root;
	let a = this.app;
        //
        this.fiducials = this.svg.insert('g',':first-child')
          .attr('class','fiducials');
        this.stripsGrp = this.svgMain.append('g')
          .attr('class','strips');
        this.axis = this.svgMain.append('g')
          .attr('class','axis');
	// 
        this.floatingText = this.svgMain.append('g')
          .attr('class','floatingText');
	this.floatingText.append('rect');
	this.floatingText.append('text');
	//
        this.cxtMenu = this.root.select('[name="cxtMenu"]');
	//
	r.select('.button.close')
	    .on('click', () => this.update());

	// zoom controls
	r.select('#zoomOut').on('click',
	    () => { a.zoom(a.defaultZoom) });
	r.select('#zoomIn') .on('click',
	    () => { a.zoom(1/a.defaultZoom) });
	r.select('#zoomOutMore').on('click',
	    () => { a.zoom(2*a.defaultZoom) });
	r.select('#zoomInMore') .on('click',
	    () => { a.zoom(1/(2*a.defaultZoom)) });

	// pan controls
	r.select('#panLeft') .on('click',
	    () => { a.pan(-a.defaultPan) });
	r.select('#panRight').on('click',
	    () => { a.pan(+a.defaultPan) });
	r.select('#panLeftMore') .on('click',
	    () => { a.pan(-5*a.defaultPan) });
	r.select('#panRightMore').on('click',
	    () => { a.pan(+5*a.defaultPan) });

	//
	this.root
	  .on('click', () => {
	      // click on background => hide context menu
	      let tgt = d3.event.target;
	      if (tgt.tagName.toLowerCase() === 'i' && tgt.innerHTML === 'menu')
		  // exception: the context menu button itself
	          return;
	      else
		  this.hideContextMenu()
	  });

	// Feature mouse event handlers.
	//
	let fClickHandler = function (f, evt, preserve) {
	    let id = f.id;
	    if (evt.ctrlKey) {
	        let cx = d3.event.clientX;
	        let cy = d3.event.clientY;
	        let bb = this.root.select('[name="zoomcontrols"] > .menu > .button').node().getBoundingClientRect();
		evt.stopPropagation();
		evt.preventDefault();
		this.showContextMenu(this.fcxtMenuCfg, f, cx-bb.x, cy-bb.y);
	    }
	    else if (evt.shiftKey) {
		if (this.hiFeats[id])
		    delete this.hiFeats[id]
		else
		    this.hiFeats[id] = id;
	    }
	    else {
		if (!preserve) this.hiFeats = {};
		this.hiFeats[id] = id;
	    }
	    // FIXME: reachover
	    this.app.featureDetails.update(f);
	}.bind(this);
	//
	let fMouseOverHandler = function(f) {
		if (d3.event.altKey) {
		    // If user is holding the alt key, select everything touched.
		    fClickHandler(f, d3.event, true);
		    this.highlight();
		    // Don't register context changes until user has paused for at least 1s.
		    if (this.timeout) window.clearTimeout(this.timeout);
		    this.timeout = window.setTimeout(function(){ this.app.contextChanged(); }.bind(this), 1000);
		}
		else {
		    this.highlight(f);
		    if (d3.event.ctrlKey)
		        this.app.featureDetails.update(f);
		}
	}.bind(this);
	//
	let fMouseOutHandler = function(f) {
		this.highlight(); 
	}.bind(this);

	// Handle key events
	d3.select(window).on('keypress', () => {
	    let e = d3.event;
            let tname = e.target.tagName.toLowerCase();
	    if (tname === 'input' || tname === 'textarea')
	        return;
	    if (e.key === 'x' || e.code === 'KeyX'){
	        this.spreadTranscripts = ! this.spreadTranscripts;
	    }
	    else if (e.key === 't' || e.code === 'KeyT'){
	        this.showAllLabels = ! this.showAllLabels;
	    }
	    else if (e.key === '+' || e.code === 'Equal' && e.shiftKey) {
		if (e.ctrlKey)
		    this.laneGap = this.laneGap + 2;
		else
		    this.featHeight = this.featHeight + 2;
	    }
	    else if (e.key === '-' || e.code === 'Minus') {
		if (e.ctrlKey)
		    this.laneGap = Math.max(2, this.laneGap - 2);
		else
		    this.featHeight = Math.max(2, this.featHeight - 2);
	    }
	})

	// 
        this.svg
	  .on('dblclick', () => {
	      let t = d3.event.target;
	      let tgt = d3.select(t);
	      let felt = t.closest('.feature');
	      if (felt) {
		  // user double clicked on a feature
		  // make it the landmark
		  let f = felt.__data__;
		  this.app.setContext({landmark:f.id, ref:f.genome.name, delta: 0});
	      }
	  })
	  .on('click', () => {
	      let t = d3.event.target;
	      let tgt = d3.select(t);
	      if (this.dealWithUnwantedClickEvent) {
	          this.dealWithUnwantedClickEvent = false;
		  return;
	      }
	      let felt = t.closest('.feature');
	      if (felt) {
		  // user clicked on a feature
		  fClickHandler(felt.__data__, d3.event);
		  this.highlight();
	          this.app.contextChanged();
	      }
	      else if (!d3.event.shiftKey && 
	          (t.tagName === 'svg' 
		  || t.tagName == 'rect' && t.classList.contains('block')
		  || t.tagName == 'rect' && t.classList.contains('underlay')
		  )){
		  // user clicked on background
		  this.hiFeats = {};
		  this.highlight();
		  this.app.contextChanged();
	      }
	  })
	  .on('contextmenu', () => {
	      let tgt = d3.select(d3.event.target);
	      let f = tgt.data()[0];
	      f = f ? f.feature || f : f;
	      if (f instanceof __WEBPACK_IMPORTED_MODULE_2__Feature__["a" /* Feature */]) {
		  fClickHandler(f, d3.event);
	      }
	      d3.event.stopPropagation();
	      d3.event.preventDefault();
	  })
	  .on('mouseover', () => {
	      let tgt = d3.select(d3.event.target);
	      let f = tgt.data()[0];
	      f = f ? f.feature || f : f;
	      if (f instanceof __WEBPACK_IMPORTED_MODULE_2__Feature__["a" /* Feature */]) {
		  fMouseOverHandler(f);
	      }
	  })
	  .on('mouseout', () => {
	      let tgt = d3.select(d3.event.target);
	      let f = tgt.data()[0];
	      f = f ? f.feature || f : f;
	      if (f instanceof __WEBPACK_IMPORTED_MODULE_2__Feature__["a" /* Feature */]) {
		  fMouseOutHandler(f);
	      }
	  })
	  .on('wheel', function(d) {
	    let e = d3.event;
	    // let the browser handler vertical motion
	    if (Math.abs(e.deltaX) < Math.abs(e.deltaY))
	        return;
	    // we handle horizontal motion.
	    e.stopPropagation();
	    e.preventDefault();
	    // filter out tiny motions
	    if (Math.abs(e.deltaX) < self.cfg.wheelThreshold) 
	        return;
	    // get the zoom strip target, if it exists, else the ref zoom strip.
	    let z = e.target.closest('g.zoomStrip') || d3.select('g.zoomStrip.reference')[0][0];
	    if (!z) return;

	    let db = e.deltaX / self.ppb; // delta in bases for this event
	    let zd = z.__data__;
	    if (e.ctrlKey) {
		// Ctrl-wheel simply slides the strip horizontally (temporary)
		// For comparison genomes, just translate the blocks by the wheel amount, so the user can 
		// see everything.
		zd.deltaB += db;
	        d3.select(z).select('g[name="sBlocks"]').attr('transform',`translate(${-zd.deltaB * self.ppb},0)scale(${zd.xScale},1)`);
		self.drawFiducials();
		return;
	    }

	    // Normal wheel event = pan the view.
	    //
	    let c  = self.app.coords;
	    // Limit delta by chr ends
	    // Delta in bases:
	    zd.deltaB = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["a" /* clip */])(zd.deltaB + db, -c.start, c.chromosome.length - c.end)
	    // translate
	    d3.select(this).selectAll('g.zoomStrip > g[name="sBlocks"]')
		.attr('transform', cz => `translate(${-zd.deltaB * self.ppb},0)scale(${cz.xScale},1)`);
	    self.drawFiducials();
	    // Wait until wheel events have stopped for a while, then scroll the view.
	    if (self.timeout){
	        window.clearTimeout(self.timeout);
	    }
	    self.timeout = window.setTimeout(() => {
		self.timeout = null;
		let ccxt = self.app.getContext();
		let ncxt;
		if (ccxt.landmark) {
		    ncxt = { delta: ccxt.delta + zd.deltaB };
		}
		else {
		    ncxt = { start: ccxt.start + zd.deltaB, end: ccxt.end + zd.deltaB };
		}
		self.app.setContext(ncxt);
		zd.deltaB = 0;
	    }, self.cfg.wheelContextDelay);
	});

	// Button: Drop down menu in zoom view
	this.root.select('.menu > .button')
	  .on('click', function () {
	      // show context menu at mouse event coordinates
	      let cx = d3.event.clientX;
	      let cy = d3.event.clientY;
	      let bb = d3.select(this)[0][0].getBoundingClientRect();
	      d3.event.stopPropagation();
	      self.showContextMenu(self.cxtMenuCfg, null, cx-bb.left, cy-bb.top);
	  });
	// zoom coordinates box
	this.root.select('#zoomCoords')
	    .call(zcs => zcs[0][0].value = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["e" /* formatCoords */])(this.app.coords))
	    .on('click', function () { this.select(); })
	    .on('change', function () { self.app.setCoordinates(this.value); });

	// zoom window size box
	this.root.select('#zoomWSize')
	    .on('click', function () { this.select(); })
	    .on('change', function() {
	        let ws = parseInt(this.value);
		let c = self.app.coords;
		if (isNaN(ws) || ws < 100) {
		    alert('Invalid window size. Please enter an integer >= 100.');
		    this.value = Math.round(c.end - c.start + 1);
		}
		else {
		    let mid = (c.start + c.end) / 2;
		    let news = Math.round(mid - ws/2);
		    let newe = news + ws - 1;
		    self.app.setContext({
		        chr: c.chr,
			start: news,
			end: newe,
			length: newe-news+1
		    });
		}
	    });
	// zoom drawing mode 
	this.root.selectAll('div[name="zoomDmode"] .button')
	    .on('click', function() {
		if (d3.select(this).attr('disabled'))
		    return;
		let r = self.root;
		let isC = r.classed('comparison');
		r.classed('comparison', !isC);
		r.classed('reference', isC);
		self.app.setContext({dmode: r.classed('comparison') ? 'comparison' : 'reference'});
	    });
    }
    //----------------------------------------------
    initContextMenu (items,obj) {
	this.cxtMenu.selectAll('.menuItem').remove(); // in case of re-init
        let mitems = this.cxtMenu
	  .selectAll('.menuItem')
	  .data(items);
	let news = mitems.enter()
	  .append('div')
	  .attr('class', (d) => `menuItem flexrow ${d.cls||''}`)
	  .classed('disabled', d => d.disabler ? d.disabler(obj) : false)
	  .attr('name', d => d.name || null )
	  .attr('title', d => d.tooltip || null );

	let handler = d => {
	      if (d.disabler && d.disabler(obj))
	          return;
	      d.handler && d.handler(obj);
	      this.hideContextMenu();
	      d3.event.stopPropagation();
	      d3.event.preventDefault();
	};
	news.append('label')
	  .text(d => typeof(d.label) === 'function' ? d.label(obj) : d.label)
	  .on('click', handler)
	  .on('contextmenu', handler);
	news.append('i')
	  .attr('class', 'material-icons')
	  .text( d=>d.icon );
    }
    //----------------------------------------------
    showContextMenu (cfg,f,x,y) {
        this.initContextMenu(cfg, f);
        this.cxtMenu
	    .classed('showing', true)
	    .style('left', `${x}px`)
	    .style('top', `${y}px`)
	    ;
	if (f) {
	    this.cxtMenu.on('mouseenter', ()=>this.highlight(f));
	    this.cxtMenu.on('mouseleave', ()=> {
	        this.highlight();
		this.hideContextMenu();
	    });
	}
    }
    //----------------------------------------------
    hideContextMenu () {
        this.cxtMenu.classed('showing', false);
	this.cxtMenu.on('mouseenter', null);
	this.cxtMenu.on('mouseleave', null);
    }

    //----------------------------------------------
    // Args:
    //     gs (list of Genomes)
    // Side effects:
    //     For each Genome, sets g.zoomY 
    set genomes (gs) {
       let offset = this.cfg.topOffset;
       gs.forEach( g => {
           g.zoomY = offset;
	   offset += this.cfg.minStripHeight + this.cfg.stripGap;
       });
       this._genomes = gs;
    }
    get genomes () {
       return this._genomes;
    }
    //----------------------------------------------
    // Returns the names of the currently displayed genomes (stripes) in top-to-bottom order.
    //
    getGenomeYOrder () {
        let strips = this.svgMain.selectAll('.zoomStrip');
        let ss = strips[0].map(g=> {
	    let bb = g.getBoundingClientRect();
	    return [bb.y, g.__data__.genome.name];
        });
        let ns = ss.sort( (a,b) => a[0] - b[0] ).map( x => x[1] )
	return ns;
    }
    //----------------------------------------------
    // Sets the top-to-bottom order of the currently displayed genomes according to 
    // the given name list of names. Because we can't guarantee the given names correspond
    // to actual zoom strips, or that all strips are represented, etc.
    // Therefore, the list is preprecessed as follows:
    //     * duplicate names, if they exist, are removed
    //     * names that do not correspond to existing zoomStrips are removed
    //     * names of existing zoom strips that don't appear in the list are added to the end
    // The result is a list of names with these properties:
    //     * there is a 1:1 correspondence between names and actual zoom strips
    //     * the name order is consistent with the input list
    // This is the list used to (re)order the zoom strips.
    //
    // Given the list order: 
    //     * a Y-position is assigned to each genome
    //     * zoom strips that are NOT CURRENTLY BEING DRAGGED are translated to their new locations
    //
    // Args:
    //     ns (list of strings) Names of the genomes.
    // Returns:
    //     nothing
    // Side effects:
    //     Recalculates the Y-coordinates for each strip based on the given order, then translates
    //     each strip to its new position.
    //
    setGenomeYOrder (ns) {
	this.genomes = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["l" /* removeDups */])(ns).map(n=> this.app.name2genome[n] ).filter(x=>x);
	let o = this.cfg.topOffset;
        this.genomes.forEach( (g,i) => {
	    let strip = d3.select(`#zoomView .zoomStrip[name="${g.name}"]`);
	    if (!strip.classed('dragging'))
	        strip.attr('transform', gd => `translate(0,${o + gd.zeroOffset})`);
	    o += strip.data()[0].stripHeight + this.cfg.stripGap;
	});
    }

    //----------------------------------------------
    // Returns a dragger (d3.behavior.drag) to be attached to each zoom strip.
    // Allows strips to be reordered by dragging.
    getDragger () {  
      let self = this;
      return d3.behavior.drag()
	  .origin(function(d,i){
	      return this.getBoundingClientRect();
	  })
          .on('dragstart.z', function(g) {
	      let t = d3.event.sourceEvent.target;
	      if (d3.event.sourceEvent.shiftKey || ! d3.select(t).classed('zoomStripHandle')){
	          return false;
	      }
	      d3.event.sourceEvent.stopPropagation();
	      let strip = this.closest('.zoomStrip');
	      self.dragging = d3.select(strip).classed('dragging', true);
	  })
	  .on('drag.z', function (g) {
	      if (!self.dragging) return;
	      let mx = d3.mouse(self.svgMain[0][0])[0];
	      let my = d3.mouse(self.svgMain[0][0])[1];
	      self.dragging.attr('transform', `translate(0, ${my})`);
	      self.setGenomeYOrder(self.getGenomeYOrder());
	      self.drawFiducials();
	  })
	  .on('dragend.z', function (g) {
	      if (!self.dragging) return;
	      //
	      self.dragging.classed('dragging', false);
	      self.dragging = null;
	      self.setGenomeYOrder(self.getGenomeYOrder());
	      self.app.setContext({ genomes: self.getGenomeYOrder() });
	      window.setTimeout( self.drawFiducials.bind(self), 50 );
	  })
	  ;
    }

    //----------------------------------------------
    clearBrushes () {
	this.root.selectAll('g.brush')
	    .each( function (b) {
	        b.brush.clear();
		d3.select(this).call(b.brush);
	    });
    }

    //----------------------------------------------
    // Returns the current brush coordinates, translated (if needed) to ref genome coordinates.
    bbGetRefCoords () {
      let rg = this.app.rGenome;
      let blk = this.brushing;
      let ext = blk.brush.extent();
      let r = { chr: blk.chr, start: ext[0], end: ext[1], blockId:blk.blockId };
      let tr = this.app.translator;
      if( blk.genome !== rg ) {
         // user is brushing a comp genomes so first translate
	 // coordinates to ref genome
	 let rs = this.app.translator.translate(blk.genome, r.chr, r.start, r.end, rg);
	 if (rs.length === 0) return;
	 r = rs[0];
      }
      else {
          r.blockId = rg.name;
      }
      return r;
    }
    //----------------------------------------------
    // handler for the start of a brush action by the user on a block
    bbStart (blk,bElt) {
      this.brushing = blk;
    }
    //----------------------------------------------
    bbBrush () {
        let ev = d3.event.sourceEvent;
	let xt = this.brushing.brush.extent();
	let s = Math.round(xt[0]);
	let e = Math.round(xt[1]);
	this.showFloatingText(`${this.brushing.chr}:${s}..${e}`, ev.clientX, ev.clientY);
    }
    //----------------------------------------------
    bbEnd () {
      let se = d3.event.sourceEvent;
      let xt = this.brushing.brush.extent();
      let g = this.brushing.genome.label;
      //
      this.hideFloatingText();
      //
      if (se.ctrlKey || se.altKey || se.metaKey) {
	  this.clearBrushes();
	  this.brushing = null;
          return;
      }
      //
      if (Math.abs(xt[0] - xt[1]) <= 10) {
	  // User clicked. Recenter view on the clicked coordinate. 
	  // Whichever genome the user clicked in becomes the reference.
	  // The clicked coordinate:
	  let xmid = (xt[0] + xt[1])/2;
	  // size of view
	  let w = this.app.coords.end - this.app.coords.start + 1;
	  // starting coordinate in clicked genome of new view
	  let s = Math.round(xmid - w/2);
	  //
	  let newContext = { ref:g, chr: this.brushing.chr, start: s, end: s + w - 1 };
	  if (this.cmode === 'landmark') {
	      let lmf = this.context.landmarkFeats.filter(f => f.genome === this.brushing.genome)[0];
	      if (lmf) {
		  let m = (this.brushing.end + this.brushing.start) / 2;
		  let dx = xmid - m;
		  newContext = { ref:g, delta: this.context.delta+dx };
	      }
	  }
	  this.app.setContext(newContext);
      }
      else {
	  // User dragged. Zoom in or out.
	  this.app.setContext({ ref:g, chr: this.brushing.chr, start:xt[0], end:xt[1] });
      }
      this.clearBrushes();
      this.brushing = null;
      this.dealWithUnwantedClickEvent = true;
    }
    //----------------------------------------------
    highlightStrip (g, elt) {
	if (g === this.currentHLG) return;
	this.currentHLG = g;
	//
	this.svgMain.selectAll('.zoomStrip')
	    .classed('highlighted', d => d.genome === g);
	this.app.showBlocks(g);
    }

    //----------------------------------------------
    // Updates the ZoomView to show the given coordinate range from the reg genome and the corresponding
    // range(s) in each comparison genome.
    //
    updateViaMappedCoordinates (coords) {
	let c = (coords || this.app.coords);
	d3.select('#zoomCoords')[0][0].value = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["e" /* formatCoords */])(c.chr, c.start, c.end);
	d3.select('#zoomWSize')[0][0].value = Math.round(c.end - c.start + 1)
	//
        let mgv = this.app;
	// Issue requests for features. One request per genome, each request specifies one or more
	// coordinate ranges.
	// Wait for all the data to become available, then draw.
	//
	let promises = [];

	//
	this.showFeatureDetails = (c.end - c.start + 1) <= this.cfg.featureDetailThreshold;

	// First request is for the the reference genome. Get all the features in the range.
	promises.push(mgv.featureManager.getFeaturesByRange(mgv.rGenome, [{
	    // Need to simulate the results from calling the translator. 
	    // 
	    chr    : c.chr,
	    start  : c.start,
	    end    : c.end,
	    index  : 0,
	    fChr   : c.chr,
	    fStart : c.start,
	    fEnd   : c.end,
	    fIndex  : 0,
	    ori    : '+',
	    blockId: mgv.rGenome.name
	}], this.showFeatureDetails));
	if (! this.root.classed('closed')) {
	    // Add a request for each comparison genome, using translated coordinates. 
	    mgv.cGenomes.forEach(cGenome => {
		let ranges = mgv.translator.translate( mgv.rGenome, c.chr, c.start, c.end, cGenome );
		let p = mgv.featureManager.getFeaturesByRange(cGenome, ranges, this.showFeatureDetails);
		promises.push(p);
	    });
	}
	return Promise.all(promises)
    }
    // Updates the ZoomView to show the region around a landmark in each genome.
    //
    // coords = {
    //     landmark : id of a feature to use as a reference
    //     flank|width : specify one of flank or width. 
    //         flank = amount of flanking region (bp) to include at both ends of the landmark, 
    //         so the total viewing region = flank + length(landmark) + flank.
    //         width = total viewing region width. If both width and flank are specified, flank is ignored.
    //     delta : amount to shift the view left/right
    // }
    // 
    // The landmark must exist in the current reference genome. 
    //
    updateViaLandmarkCoordinates (coords) {
	let c = coords;
	let mgv = this.app;
        let self = this;
	let rf = coords.landmarkRefFeat;
	let feats = coords.landmarkFeats;
	if (this.root.classed('closed'))
	    feats = feats.filter(f => f.genome === this.app.rGenome);
	let delta = coords.delta || 0;

	// compute ranges around landmark in each genome
	let ranges = feats.map(f => {
	    let flank = c.length ? (c.length - f.length) / 2 : c.flank;
	    let clength = f.genome.getChromosome(f.chr).length;
	    let w     = c.length ? c.length : (f.length + 2*flank);
	    let sign = f.strand === '-' ? -1 : 1;
	    let start = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["a" /* clip */])(Math.round(delta + f.start - flank), 1, clength);
	    let end   = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["a" /* clip */])(Math.round(start + w), start, clength)
	    let fdelta = f.length / 2;
	    let range = {
		genome:	    f.genome,
		chr:	    f.chr,
		chromosome: f.genome.getChromosome(f.chr),
		start:      start - sign * fdelta,
		end:        end   - sign * fdelta
	    } ;
	    if (f.genome === mgv.rGenome) {
		let c = this.app.coords = range;
		d3.select('#zoomCoords')[0][0].value = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["e" /* formatCoords */])(c.chr, c.start, c.end);
		d3.select('#zoomWSize')[0][0].value = Math.round(c.end - c.start + 1)
	    }
	    return range;
	});
	let seenGenomes = new Set();
	let rCoords;
	// Get (promises for) the features in each range.
	let promises = ranges.map(r => {
            let rrs;
	    seenGenomes.add(r.genome);
	    if (r.genome === mgv.rGenome){
		// the ref genome range
		rCoords = r;
		//
		this.showFeatureDetails = (r.end - r.start + 1) <= this.cfg.featureDetailThreshold;
		//
	        rrs = [{
		    chr    : r.chr,
		    start  : r.start,
		    end    : r.end,
		    index  : 0,
		    fChr   : r.chr,
		    fStart : r.start,
		    fEnd   : r.end,
		    fIndex  : 0,
		    ori    : '+',
		    blockId: mgv.rGenome.name
		}];
	    }
	    else { 
		// turn the single range into a range for each overlapping synteny block with the ref genome
	        rrs = mgv.translator.translate(r.genome, r.chr, r.start, r.end, mgv.rGenome, true);
	    }
	    return mgv.featureManager.getFeaturesByRange(r.genome, rrs, this.showFeatureDetails);
	});
	// For each genome where the landmark does not exist, compute a mapped range (as in mapped cmode).
	if (!this.root.classed('closed'))
	    mgv.cGenomes.forEach(g => {
		if (! seenGenomes.has(g)) {
		    let rrs = mgv.translator.translate(mgv.rGenome, rCoords.chr, rCoords.start, rCoords.end, g);
		    promises.push( mgv.featureManager.getFeaturesByRange(g, rrs, this.showFeatureDetails) );
		}
	    });
	// When all the data is ready, draw.
	return Promise.all(promises);
    }
    //
    update (context) {
	this.context = context || this.context;
	this.highlighted = this.context.highlight;
	this.genomes = this.context.genomes;
	this.dmode = this.context.dmode;
	this.cmode = this.context.cmode;
	let p;
	if (this.cmode === 'mapped')
	    p = this.updateViaMappedCoordinates(this.app.coords);
	else
	    p = this.updateViaLandmarkCoordinates(this.app.lcoords);
	p.then( data => {
	    this.draw(this.mungeData(data));
	});
	return p;
    }

    // ------------------------------------
    //
    mergeSblockRuns (data) {
	// -----
	// Reducer function. Will be called with these args:
	//   nblcks (list) New blocks. (current accumulator value)
	//   	A list of lists of synteny blocks.
	//   blk (synteny block) the current synteny block
	//   i (int) The iteration count.
	// Returns:
	//   list of lists of blocks
	let merger = (nblks, b, i) => {
	    let initBlk = function (bb) {
		let nb = Object.assign({}, bb);
		nb.superBlock = true;
		nb.features = bb.features.concat();
		nb.sblocks = [bb];
		nb.ori = '+'
		return nb;
	    };
	    if (i === 0){
		nblks.push(initBlk(b));
		return nblks;
	    }
	    let lastBlk = nblks[nblks.length - 1];
	    if (b.chr !== lastBlk.chr || b.index - lastBlk.index !== 1) {
	        nblks.push(initBlk(b));
		return nblks;
	    }
	    // merge
	    lastBlk.index = b.index;
	    lastBlk.end = b.end;
	    lastBlk.blockEnd = b.blockEnd;
	    lastBlk.features = lastBlk.features.concat(b.features);
	    let lastSb = lastBlk.sblocks[lastBlk.sblocks.length - 1];
	    let d = b.start - lastSb.end;
	    lastSb.end += d/2;
	    b.start -= d/2;
	    lastBlk.sblocks.push(b);
	    return nblks;
	};
	// -----
        data.forEach((gdata,i) => {
	    if (this.dmode === 'comparison') {
		gdata.blocks.sort( (a,b) => a.index - b.index );
		gdata.blocks = gdata.blocks.reduce(merger,[]);
	    }
	    else {
		// first sort by ref genome order
		gdata.blocks.sort( (a,b) => a.fIndex - b.fIndex );
		// Sub-group into runs of same comp genome chromosome.
		let tmp = gdata.blocks.reduce((nbs, b, i) => {
		    if (i === 0 || nbs[nbs.length - 1][0].chr !== b.chr)
			nbs.push([b]);
		    else
			nbs[nbs.length - 1].push(b);
		    return nbs;
		}, []);
		// Sort each subgroup into comparison genome order
		tmp.forEach( subgrp => subgrp.sort((a,b) => a.index - b.index) );
		// Flatten the list
		tmp = tmp.reduce((lst, curr) => lst.concat(curr), []);
		// Now create the supergroups.
		gdata.blocks = tmp.reduce(merger,[]);
	    }
	});
	return data;
    }

    // ---------------------------------------------------
    //
    uniqifyBlocks (blocks) {
	// helper function. When sblock relationship between genomes is confused, requesting one
	// region in genome A can end up requesting the same region in genome B multiple times.
	// This function avoids drawing the same sblock twice. (NB: Really not sure where this 
	// check is best done. Could push it farther upstream.)
	let seen = new Set();
	return blocks.filter( b => { 
	    if (seen.has(b.index)) return false;
	    seen.add(b.index);
	    return true;
	});
    };
    //----------------------------------------------
    // Applies several transformation steps on the data as returned by the server to prepare for drawing.
    // Input data is structured as follows:
    //     data = [ zoomStrip_data ]
    //     zoomStrip_data = { genome [ zoomBlock_data ] }
    //     zoomBlock_data = { xscale, chr, start, end, index, fChr, fStart, fEnd, fIndex, ori, [ feature_data ] }
    //     feature_data = { ID, canonical, symbol, chr, start, end, strand, type, biotype }
    //
    // Again, in English:
    //  - data is a list of items, one per strip to be displayed. Item[0] is data for the ref genome.
    //    Items[1+] are data for the comparison genome.
    //  - each strip item is an object containing a genome and a list of blocks. Item[0] always has 
    //    a single block.
    //  - each block is an object containing a chromosome, start, end, orientation, etc, and a list of features.
    //  - each feature has chr,start,end,strand,type,biotype,ID
    //
    // Because SBlocks can be very fragmented, one contiguous region in the ref genome can turn into 
    // a bazillion tiny blocks in the comparison. The resulting rendering is jarring and unusable.
    // The drawing routine modifies the data by merging runs of consecutive blocks in each comp genome.
    // The data change is to insert a grouping layer on top of the sblocks, specifically, 
    //     zoomStrip_data = { genome [ zoomBlock_data ] }
    // becomes
    //     zoomStrip_data = { genome [ zoomSuperBlock_data ] }
    //     zoomSuperBlock_data = { chr start end blocks [ zoomBlock_data ] }
    //
    mungeData (data) {
        data.forEach(gData => {
	    gData.blocks = this.uniqifyBlocks(gData.blocks)
	    // Each strip is independently scrollable. Init its offset (in bytes).
	    gData.deltaB = 0;
	    // Each strip is independently scalable. Init scale.
	    gData.xScale = 1.0;
	});
	data = this.mergeSblockRuns(data);
	// 
	data.forEach( gData => {
	  // 
	  gData.maxLanesP = 0;
	  gData.maxLanesN = 0;
	  gData.maxLanes = 0;
	  gData.blocks.forEach( sb=> {
	    sb.features.forEach(f => {
		gData.maxLanes = Math.max(gData.maxLanes, f.lane2 + f.transcript_count);
		if (f.lane > 0)
		    gData.maxLanesP = Math.max(gData.maxLanesP, f.lane)
		else
		    gData.maxLanesN = Math.max(gData.maxLanesN, -f.lane)
	    });
	  });
	  if (gData.blocks.length > 1)
	      gData.blocks = gData.blocks.filter(b=>b.features.length > 0);
	  if (this.showFeatureDetails && this.spreadTranscripts) {
	      gData.stripHeight = 15 + this.cfg.laneHeightMinor * gData.maxLanes;
	      gData.zeroOffset = 0;
	  }
	  else {
	      gData.stripHeight = 15 + this.cfg.laneHeight * (gData.maxLanesP + gData.maxLanesN);
	      gData.zeroOffset = this.cfg.laneHeight * gData.maxLanesP;
	  }
	});
	return data;
    }

    //----------------------------------------------
    // Lays out the features within an sblock
    layoutSBFeatures (sb) {
	let fx = function(f) {
	    f.x = sb.xscale(Math.max(f.start,sb.start))
	    f.width = Math.abs(sb.xscale(Math.min(f.end,sb.end)) - sb.xscale(Math.max(f.start,sb.start))) + 1;
	    if (f.end < sb.start || f.start > sb.end) f.width = 0;
	}
	let fy = f => {
	    if (this.showFeatureDetails && this.spreadTranscripts) {
	        f.y = f.lane2 * this.cfg.laneHeightMinor;
	    }
	    else {
		// pos strand features above axis line, neg strand below
		f.y = -this.cfg.laneHeight*f.lane - (f.strand === '+' ? 0 : this.cfg.featHeight);
	    }
	}
        sb.features.forEach( f => {
	    fx(f);
	    fy(f);
	    f.transcripts && f.transcripts.forEach( t => {
	        fx(t);
		t.y = f.y;
		t.exons.forEach( e => {
		    fx(e);
		    e.y = f.y;
		});
	    });
	});
    }

    //----------------------------------------------
    // Orders sblocks horizontally within each genome. Translates them into position.
    //
    layoutSBlocks (sblocks) {
	// Sort the sblocks in each strip according to the current drawing mode.
	let cmpField = this.dmode === 'comparison' ? 'index' : 'fIndex';
	let cmpFunc = (a,b) => a.__data__[cmpField]-b.__data__[cmpField];
	sblocks.forEach( strip => strip.sort( cmpFunc ) );
	let pstart = []; // offset (in pixels) of start position of next block, by strip index (0===ref)
	let bstart = []; // block start pos (in bp) assoc with pstart
	let cchr = null;
	let self = this;
	let GAP  = 16;   // length of gap between blocks of diff chroms.
	let dx;
	let pend;
	sblocks.each( function (b,i,j) { // b=block, i=index within strip, j=strip index
	    let gd = this.__data__.genome;
	    let blen = self.ppb * (b.end - b.start + 1); // total screen width of this sblock
	    b.xscale = d3.scale.linear().domain([b.start, b.end]).range( [0, blen] );
	    //
	    if (i===0) {
		// first block in each strip inits
		pstart[j] = 0;
		gd.pwidth = blen;
		bstart[j] = b.start;
		dx = 0;
		cchr = b.chr;
	    }
	    else {
		gd.pwidth += blen;
		dx = b.chr === cchr ? pstart[j] + self.ppb * (b.start - bstart[j]) : Infinity;
		if (dx < 0 || dx > self.cfg.maxSBgap) {
		    // Changed chr or jumped a large gap
		    pstart[j] = pend + GAP;
		    bstart[j] = b.start;
		    gd.pwidth += GAP;
		    dx = pstart[j];
		    cchr = b.chr;
		}
	    }
	    pend = dx + blen;
	    d3.select(this).attr('transform', `translate(${dx},0)`);
	    //
	    self.layoutSBFeatures(b);
	});
	this.squish();
    }

    //----------------------------------------------
    // Scales each zoom strip horizontally to fit the width. Only scales down.
    squish () {
        let sbs = d3.selectAll('.zoomStrip [name="sBlocks"]');
	let self = this;
	sbs.each(function (sb,i) {
	    if (sb.genome.pwidth > self.width) {
	        let s = self.width / sb.genome.pwidth;
		sb.xScale = s;
		let t = d3.select(this);
		t.attr('transform', ()=> `translate(${-sb.deltaB * self.ppb},0)scale(${sb.xScale},1)`);
	    }
	});
    }
    //----------------------------------------------
    // Draws the zoom view panel with the given data.
    //
    draw (data) {
	//
	this.drawCount += 1;
	//
	let self = this;
        // Is ZoomView currently closed?
	let closed = this.root.classed('closed');
	// Show ref genome name
	d3.select('#zoomView .zoomCoords label')
	    .text(this.app.rGenome.label + ' coords');
	// Show landmark label, if applicable
	let lmtxt = '';
	if (this.cmode === 'landmark') {
	    let rf = this.app.lcoords.landmarkRefFeat;
	    let d = this.app.lcoords.delta;
	    let dtxt = d ? ` (${d > 0 ? '+' : ''}${Object(__WEBPACK_IMPORTED_MODULE_3__utils__["k" /* prettyPrintBases */])(d)})` : '';
	    lmtxt = `Aligned on ${rf.symbol || rf.id}${dtxt}`;
	}
	// display landmark text
	d3.select('#zoomView .zoomCoords div[name="lmtxt"] span')
	    .text(lmtxt);
	d3.select('#zoomView .zoomCoords div[name="lmtxt"] i')
	    .text(lmtxt?'highlight_off':'')
	    .style('font-size','12px')
	    .style('color','red')
	    .on('click', () => {
		this.app.setContext(this.app.coords);
	    })
	    ;
	// disable the R/C button in landmark mode
	this.root.selectAll('[name="zoomcontrols"] [name="zoomDmode"] .button')
	    .attr('disabled', this.cmode === 'landmark' || null);
	
	// the reference genome block (always just 1 of these).
	let rData = data.filter(dd => dd.genome === this.app.rGenome)[0];
	let rBlock = rData.blocks[0];

	// x-scale and x-axis based on the ref genome.
	this.xscale = d3.scale.linear()
	    .domain([rBlock.start,rBlock.end])
	    .range([0,this.width]);
	//
	// pixels per base
	this.ppb = this.width / (this.app.coords.end - this.app.coords.start + 1);

        // -----------------------------------------------------
	// draw the coordinate axis
        // -----------------------------------------------------
	this.axisFunc = d3.svg.axis()
	    .scale(this.xscale)
	    .orient('top')
	    .outerTickSize(2)
	    .ticks(5)
	    .tickSize(5)
	    ;
	this.axis.call(this.axisFunc);

        // -----------------------------------------------------
	// zoom strips (one per genome)
        // -----------------------------------------------------
        let zstrips = this.stripsGrp
	        .selectAll('g.zoomStrip')
		.data(data, d => d.genome.name);
	// Create the group
	let newzs = zstrips.enter()
	        .append('g')
		.attr('class','zoomStrip')
		.attr('name', d => d.genome.name)
		.on('click', function (g) {
		    self.highlightStrip(g.genome, this);
		})
		.call(this.dragger)
		;
	//
	// Strip label
	newzs.append('text')
	    .attr('name', 'genomeLabel')
	    ;
	// Strip underlay
	newzs.append('rect')
	    .attr('class','underlay')
	    .style('width','100%')
	    .style('opacity',0)
	    ;
	    
	// Group for sBlocks
	newzs.append('g')
	    .attr('name', 'sBlocks');
	// Strip end cap
	newzs.append('rect')
	    .attr('class', 'material-icons zoomStripEndCap')
	    ;
	// Strip drag-handle
	newzs.append('text')
	    .attr('class', 'material-icons zoomStripHandle')
	    .text('drag_indicator')
	    .append('title')
	        .text('Drag up/down to reorder the genomes.')
	    ;
	// Updates
	zstrips.select('.zoomStripEndCap')
	    .attr('x', -15)
	    .attr('width', 15)
	    .attr('y', d => -d.zeroOffset)
	    .attr('height', d => d.stripHeight + 10)
	    ;
	zstrips.select('text.zoomStripHandle')
	    .style('font-size', '18px')
	    .attr('x', -15)
	    .attr('y', d => d.stripHeight / 2 - d.zeroOffset + 10)
	    ;
	zstrips.select('[name="genomeLabel"]')
	    .text(d => d.genome.label)
	    .attr('x', 0)
	    .attr('y', d => d.stripHeight - d.zeroOffset + 20)
	    .attr('font-family','sans-serif')
	    .attr('font-size', 10)
	    ;
	zstrips.select('.underlay')
	    .attr('y', d => -d.zeroOffset)
	    .attr('height', d => d.stripHeight)
	    ;
	    
	// translate strips into position
	let offset = this.cfg.topOffset;
	let rHeight = 0;
	this.app.vGenomes.forEach( vg => {
	    let s = this.stripsGrp.select(`.zoomStrip[name="${vg.name}"]`);
	    s.classed('reference', d => d.genome === this.app.rGenome)
	        .attr('transform', d => {
		    if (d.genome === this.app.rGenome)
		        rHeight = d.stripHeight + d.zeroOffset + 10;
		    let o = offset + d.zeroOffset;
		    d.zoomY = offset;
		    offset += d.stripHeight + this.cfg.stripGap + 10;
		    return `translate(0,${closed ? this.cfg.topOffset+d.zeroOffset : o})`
		});
	});
	// reset the svg size based on strip widths
	this.svg.attr('height', (closed ? rHeight : offset) + 25);

        zstrips.exit()
	    .on('.drag', null)
	    .remove();
	//
        zstrips.select('g[name="sBlocks"]')
	    .attr('transform', g => `translate(${g.deltaB * this.ppb},0)`)
	    ;
	// ---- Synteny super blocks ----
        let sblocks = zstrips.select('[name="sBlocks"]').selectAll('g.sBlock')
	    .data(d=>d.blocks, b => b.blockId);
	let newsbs = sblocks.enter()
	    .append('g')
	    .attr('class', 'sBlock')
	    .attr('name', b=>b.index)
	    ;
	let l0 = newsbs.append('g').attr('name', 'layer0');
	let l1 = newsbs.append('g').attr('name', 'layer1');

	//
	this.layoutSBlocks(sblocks);

	// rectangle for each individual synteny block
	let sbrects = sblocks.select('g[name="layer0"]').selectAll('rect.block').data(d=> {
	    d.sblocks.forEach(b=>b.xscale = d.xscale);
	    return d.sblocks
	    }, sb=>sb.index);
        sbrects.enter().append('rect').append('title');
	sbrects.exit().remove();
	sbrects
	   .attr('class', b => 'block ' + 
	       (b.ori==='+' ? 'plus' : b.ori==='-' ? 'minus': 'confused') + 
	       (b.chr !== b.fChr ? ' translocation' : ''))
	   .attr('x',     b => b.xscale(b.start))
	   .attr('y',     function(b) {
	       let bb = this.closest('.zoomStrip').__data__;
	       return -bb.zeroOffset;
	   })
	   .attr('width', b => Math.max(4, Math.abs(b.xscale(b.end)-b.xscale(b.start))))
	   .attr('height', function (b) {
	       let bb = this.closest('.zoomStrip').__data__;
	       return bb.stripHeight;
	   });
	   ;
	sbrects.select('title')
	   .text( b => {
	       let adjectives = [];
	       b.ori === '-' && adjectives.push('inverted');
	       b.chr !== b.fChr && adjectives.push('translocated');
	       return adjectives.length ? adjectives.join(', ') + ' block' : '';
	   });

	// the axis line
	l0.append('line').attr('class','axis');
	//
	sblocks.select('line.axis')
	    .attr('x1', b => b.xscale(b.start))
	    .attr('y1', 0)
	    .attr('x2', b => b.xscale(this.showFeatureDetails && this.spreadTranscripts ? b.start : b.end))
	    .attr('y2', 0)
	    ;
	// sequence
	l0.append('text')
	    .attr('class','sequence')
	    .style('font-family','monospace')
	    ;
	sblocks.select('text.sequence')
	    .each( function (b) {
		let blen = b.end - b.start + 1;
		if (blen < 2*self.width) {
		    let adm = self.app.queryManager.auxDataManager;
		    let p = adm.sequenceSlice(b.genome.label, b.chr, Math.floor(b.start), Math.floor(b.end));
		    p.then(s => {
			//console.log(s);
			let bases = s.seq.split('');
			d3.select(this)
			    .html(bases.map(b => `<tspan class="${b}">${blen >= self.width ? '.' : b}</tspan>`).join(''))
			    .style('font-size', '10px')
			    ;
			d3.select(this)
			    .attr('transform',`scale(${self.width/this.getBBox().width},1)`)
		    });
		}
		else
		    d3.select(this).text('');
	    })
	    ;

	// label
	l0.append('text')
	    .attr('class','blockLabel') ;
	// brush
	l0.append('g').attr('class','brush');
	//
	sblocks.exit().remove();

	// synteny block labels
	sblocks.select('text.blockLabel')
	    .text( b => b.chr )
	    .attr('x', b => (b.xscale(b.start) + b.xscale(b.end))/2 )
	    .attr('y', function (b) {
		let bb = this.closest('.zoomStrip').__data__;
	        return bb.stripHeight - bb.zeroOffset + 10
	    })
	    ;

	// brush
	sblocks.select('g.brush')
	    .attr('transform', function(b) {
		let bb = this.closest('.zoomStrip').__data__;
		return `translate(0,${ bb.stripHeight - bb.zeroOffset })`;
	    })
	    .on('mousemove', function(b) {
	        let cr = this.getBoundingClientRect();
		let x = d3.event.clientX - cr.x;
		let c = Math.round(b.xscale.invert(x));
		self.showFloatingText(`${b.chr}:${c}`, d3.event.clientX, d3.event.clientY);
	    })
	    .on('mouseout', b => this.hideFloatingText())
	    .each(function(b) {
		if (!b.brush) {
		    b.brush = d3.svg.brush()
			.on('brushstart', function(){ self.bbStart( b, this ); })
			.on('brush',      function(){ self.bbBrush( b, this ); })
			.on('brushend',   function(){ self.bbEnd( b, this ); })
		}
		b.brush.x(b.xscale).clear();
		d3.select(this).call(b.brush);
	    })
	    .selectAll('rect')
		.attr('height', 10);

	this.drawFeatures(sblocks);

	//
	this.app.facetManager.applyAll();

	// We need to let the view render before doing the highlighting, since it depends on
	// the positions of rectangles in the scene.
	window.setTimeout(() => {
	    this.highlight();
	    window.setTimeout(() => {
		this.highlight();
	    }, 150);
	}, 150);
    };

    //----------------------------------------------
    // Draws the features (rectangles) for the specified synteny blocks.
    // Args:
    //     sblocks (D3 selection of g.sblock nodes) - multilevel selection.
    //        Array (corresponding to strips) of arrays of synteny blocks.
    //     detailed (boolean) if true, draws each feature in full detail (ie,
    //        show exon structure if available). Otherwise (the default), draw
    //        each feature as just a rectangle.
    //
    drawFeatures (sblocks) {
	// before doing anything else...
	if (this.clearAll) {
	    // if we are changing between detailed and simple features, have to delete existing rendered features first
	    // because the structures are incompatible. Ugh. 
	    sblocks.selectAll('.feature').remove();
	}
	// ok, now that's taken care of...
        let self = this;
	//
	// never draw the same feature twice in one rendering pass
	// Can happen in complex sblocks where the relationship in not 1:1
	let drawn = new Set();	// set of IDs of drawn features
	let filterDrawn = function (f) {
	    // returns true if we've not seen this one before.
	    // registers that we've seen it.
	    let fid = f.ID;
	    let v = ! drawn.has(fid);
	    drawn.add(fid);
	    return v;
	};
	//
	let feats = sblocks.select('[name="layer1"]').selectAll('.feature')
	    .data(d=>d.features.filter(filterDrawn), d=>d.ID);
	feats.exit().remove();
	//
	let newFeats;
	if (this.showFeatureDetails) {
	    // draw detailed features
	    newFeats = feats.enter().append('g')
		.attr('class', f => 'feature detailed ' + (f.strand==='-' ? ' minus' : ' plus'))
		.attr('name', f => f.ID)
		;
	    newFeats.append('rect')
		.style('fill', f => self.app.cscale(f.getMungedType()))
		;
	    newFeats.append('g')
	        .attr('class','transcripts')
		.attr('transform','translate(0,0)')
		;
	    newFeats.append('text')
	        .attr('class','label')
		;
	}
	else {
	    // simple style: draw features as just a rectangle
	    newFeats = feats.enter().append('rect')
		.attr('class', f => 'feature' + (f.strand==='-' ? ' minus' : ' plus'))
		.attr('name', f => f.ID)
		.style('fill', f => self.app.cscale(f.getMungedType()))
		;
	}
	// NB: if you are looking for click handlers, they are at the svg level (see initDom above).

	// Set position and size attributes of the overall feature rect.
	(this.showFeatureDetails ? feats.select('rect') : feats)
	  .attr('x', f => f.x)
	  .attr('y', 0)
	  .attr('width', f => f.width)
	  .attr('height', this.cfg.featHeight)
	  ;
	//
        feats.attr('transform', f => {
	    if (isNaN(f.y)) 
	        console.log('What?', f);
	    return `translate(0,${f.y})`
	})

	// draw detailed feature
	if (this.showFeatureDetails) {
	    //
	    // feature labels
	    feats.select('text.label')
	        .attr('x', f => f.x + f.width / 2)
		.attr('y', f => -1)
		.style('font-size', this.laneGap)
		.style('text-anchor', 'middle')
		.text(f => this.showAllLabels ? (f.symbol || f.ID) : '')
		;
	    // draw transcripts
	    let tgrps = feats.select('g.transcripts');
	    let transcripts = tgrps.selectAll('.transcript')
	        .data( f => f.transcripts, t => t.ID )
		;
	    let newts = transcripts.enter().append('g')
	        .attr('class','transcript')
		;
	    newts.append('polyline');
	    newts.append('g').attr('class','exons');
	    newts.append('rect').attr('class','overlay');

	    transcripts.exit().remove();
	    // draw transcript axis lines
	    transcripts.select('polyline')
	        //.attr('x1', t => t.x)
		//.attr('y1', 0)
		//.attr('x2', t => t.x + t.width - 1)
		//.attr('y2', 0)
		.attr('points', t => {
		    let ext = 10;
		    let h   = 3;
		    let x1, x2, y;
		    if (t.strand === '+') {
		        x1 = t.x;
			x2 = t.x + t.width + ext;
			return `${x1} 0 ${x2} 0 ${x2 - ext/2} ${-h} ${x2} 0 ${x2 - ext/2} ${h}`;
		    }
		    else {
			x1 = t.x + t.width;
		        x2 = t.x - ext;
			return `${x1} 0 ${x2} 0 ${x2 + ext/2} ${-h} ${x2} 0 ${x2 + ext/2} ${h}`;
		    }
		})
		.attr('transform',`translate(0,${this.cfg.featHeight/2})`)
		.attr('stroke', t => this.app.cscale(t.feature.getMungedType()))
		.style('fill','none')
		;
	    // draw the transcript rectangle
	    transcripts.select('rect.overlay')
		.attr('x', t => t.x)
		.attr('y', 0)
		.attr('width', t => t.width)
		.attr('height', this.cfg.featHeight)
		.style('fill', t => this.app.cscale(t.feature.getMungedType()))
		.style('fill-opacity', 0)
		.on('mouseenter', function(){ d3.select(this).style('fill-opacity', 0.20) })
		.on('mouseleave', function(){ d3.select(this).style('fill-opacity', 0) })
		.append('title')
		    .text(t => 'transcript: '+t.ID)
		;

	    let egrps = transcripts.select('g.exons');
	    let exons = egrps.selectAll('.exon')
		.data(f => f.exons || [])
		;
	    exons.enter().append('rect')
		.attr('class','exon')
		.style('fill', e => this.app.cscale(e.feature.getMungedType()))
		    ;
	    exons.exit().remove();
	    exons.attr('name', e => e.primaryIdentifier)
	        .attr('x', e => e.x)
	        .attr('y', 0)
	        .attr('width', e => e.width)
	        .attr('height', this.cfg.featHeight)
		;
            // translate each transcript into position
            let xps = this.svgMain.selectAll('.feature .transcripts').selectAll('.transcript');
            xps.attr('transform', (xp,i) => `translate(0,${ this.spreadTranscripts ? (i * this.cfg.laneHeightMinor) : 0})`);
            // set feature rectangle height
            let frs = this.svgMain.selectAll('.feature > rect')
		.attr('height', (f,i) => {
                    let nLanes = Math.max(1, this.spreadTranscripts ? f.transcripts.length : 1);
		    let h = nLanes * this.cfg.featHeight + (nLanes - 1) * this.cfg.laneGapMinor;
		    f.h = h;
                    return h;
                })
		//.attr('transform', f => `translate(0,${-(f.h-this.cfg.laneHeightMinor)})`)

                ;

	}
    }

    //----------------------------------------------
    // Updates feature highlighting in the current zoom view.
    // Features to be highlighted include those in the hiFeats list plus the feature
    // corresponding to the rectangle argument, if given. (The mouseover feature.)
    //
    // Draws fiducials for features in this list that:
    // 1. overlap the current zoomView coord range
    // 2. are not rendered invisible by current facet settings
    //
    // Args:
    //    current (rect element) Optional. Add'l rectangle element, e.g., that was moused-over. Highlighting
    //        will include the feature corresponding to this rect along with those in the highlight list.
    //    pulseCurrent (boolean) If true and current is given, cause it to pulse briefly.
    //
    highlight (current, pulseCurrent) {
	let self = this;
	// current feature
	let currFeat = current ? (current instanceof __WEBPACK_IMPORTED_MODULE_2__Feature__["a" /* Feature */] ? current : current.__data__) : null;
	// create local copy of hiFeats, with current feature added
	let hiFeats = Object.assign({}, this.hiFeats, this.app.currListIndex ||{});
	if (currFeat) {
	    hiFeats[currFeat.id] = currFeat.id;
	}

	// Filter all features (rectangles) in the scene for those being highlighted.
	// Along the way, build index mapping feature id to its 'stack' of equivalent features,
	// i.e. a list of its genologs sorted by y coordinate.
	//
	this.stacks = {}; // fid -> [ rects ] 
	let dh = this.cfg.blockHeight/2 - this.cfg.featHeight;
        let feats = this.svgMain.selectAll('.feature')
	  // filter rect.features for those in the highlight list
	  .filter(function(ff){
	      // highlight ff if either id is in the list AND it's not been hidden
	      let mgi = hiFeats[ff.canonical];
	      let mgp = hiFeats[ff.ID];
	      let showing = d3.select(this).style('display') !== 'none';
	      let hl = showing && (mgi || mgp);
	      if (hl) {
		  // for each highlighted feature, add its rectangle to the list
		  let k = ff.id;
		  if (!self.stacks[k]) self.stacks[k] = []
		  // if showing feature details, .feature is a group with the rect as the 1st child.
		  // otherwise, .feature is the rect itself.
		  self.stacks[k].push(this.tagName === 'g' ? this.childNodes[0] : this)
	      }
	      // 
	      d3.select(this)
		  .classed('highlight', hl)
		  .classed('current', hl && currFeat && this.__data__.id === currFeat.id)
		  .classed('extra', pulseCurrent && ff === currFeat)
	      return hl;
	  })
	  ;

	this.drawFiducials(currFeat);

    }

    //----------------------------------------------
    // Draws polygons that connect highlighted features in the view
    //
    drawFiducials (currFeat) {
	// build data array for drawing fiducials between equivalent features
	let data = [];
	for (let k in this.stacks) {
	    // for each highlighted feature, sort the rectangles in its list by Y-coordinate
	    let rects = this.stacks[k];
	    rects.sort( (a,b) => parseFloat(a.getAttribute('y')) - parseFloat(b.getAttribute('y')) );
	    rects.sort( (a,b) => {
		return a.__data__.genome.zoomY - b.__data__.genome.zoomY;
	    });
	    // Want a polygon between each successive pair of items. The following creates a list of
	    // n pairs, where rect[i] is paired with rect[i+1]. The last pair consists of the last
	    // rectangle paired with undefined. (We want this.)
	    let pairs = rects.map((r, i) => [r,rects[i+1]]);
	    // Add a class ('current') for the polygons associated with the mouseover feature so they
	    // can be distinguished from others.
	    data.push({ fid: k, rects: pairs, cls: (currFeat && currFeat.id === k ? 'current' : '') });
	}

	let self = this;
	//
	// put fiducial marks in their own group 
	let fGrp = this.fiducials.classed('hidden', false);

	// Bind first level data to 'featureMarks' groups
	let ffGrps = fGrp.selectAll('g.featureMarks')
	    .data(data, d => d.fid);
	ffGrps.enter().append('g')
	    .attr('name', d => d.fid);
	ffGrps.exit().remove();
	//
	ffGrps.attr('class', d => {
            let classes = ['featureMarks'];
	    d.cls && classes.push(d.cls);
	    this.app.currListIndex[d.fid] && classes.push('listItem')
	    return classes.join(' ');
	});

	// -------------------------------------
	// Draw the connector polygons.
	// Bind second level data (rectangle pairs) to polygons in the group
	let pgons = ffGrps.selectAll('polygon')
	    .data(d=>d.rects.filter(r => r[0] && r[1]));
	pgons.enter().append('polygon')
	    .attr('class','fiducial')
	    ;
	//
	pgons.attr('points', r => {
	    try {
	    // polygon connects bottom corners of 1st rect to top corners of 2nd rect
	    let c1 = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["b" /* coordsAfterTransform */])(r[0]); // transform coords for 1st rect
	    let c2 = Object(__WEBPACK_IMPORTED_MODULE_3__utils__["b" /* coordsAfterTransform */])(r[1]);  // transform coords for 2nd rect
	    r.tcoords = [c1,c2];
	    // four polygon points
	    let s = `${c1.x},${c1.y+c1.height} ${c2.x},${c2.y} ${c2.x+c2.width},${c2.y} ${c1.x+c1.width},${c1.y+c1.height}`
	    return s;
	    }
	    catch (e) {
	        console.log("Caught error:", e);
		return '';
	    }
	})
	// mousing over the fiducial highlights (as if the user had moused over the feature itself)
	.on('mouseover', (p) => {
	    this.highlight(p[0]);
	})
	.on('mouseout',  (p) => {
	    this.highlight();
	});
	//
	pgons.exit().remove();
	// -------------------------------------
	// Draw feature labels. Each label is drawn once, above the first rectangle in its list.
	// The exception is the current (mouseover) feature, where the label is drawn above that feature.
	let labels = ffGrps.selectAll('text.featLabel')
	    .data(d => {
		let r = d.rects[0][0];
		if (currFeat && (d.fid === currFeat.ID || d.fid === currFeat.canonical)){
		    let r2 = d.rects.map( rr =>
		       rr[0].__data__ === currFeat ? rr[0] : rr[1]&&rr[1].__data__ === currFeat ? rr[1] : null
		       ).filter(x=>x)[0];
		    r = r2 ? r2 : r;
		}
	        return [{
		    fid: d.fid,
		    rect: r,
		    trect: Object(__WEBPACK_IMPORTED_MODULE_3__utils__["b" /* coordsAfterTransform */])(r)
		}];
	    });

	// Draw the text.
	labels.enter().append('text').attr('class','featLabel');
	labels.exit().remove();
	labels
	  .attr('x', d => d.trect.x + d.trect.width/2 )
	  .attr('y', d => d.rect.__data__.genome.zoomY+15)
	  .text(d => {
	       let f = d.rect.__data__;
	       let sym = f.symbol || f.ID;
	       return sym;
	  });

	// Put a rectangle behind each label as a background
	let lblBoxData = labels.map(lbl => lbl[0].getBBox())
	let lblBoxes = ffGrps.selectAll('rect.featLabelBox')
	    .data((d,i) => [lblBoxData[i]]);
	lblBoxes.enter().insert('rect','text').attr('class','featLabelBox');
	lblBoxes.exit().remove();
	lblBoxes
	    .attr('x',      bb => bb.x-2)
	    .attr('y',      bb => bb.y-1)
	    .attr('width',  bb => bb.width+4)
	    .attr('height', bb => bb.height+2)
	    ;
	
	// if there is a currFeat, move its fiducials to the end (so they're on top of everyone else)
	if (currFeat) {
	    // get list of group elements from the d3 selection
	    let ffList = ffGrps[0];
	    // find the one whose feature is currFeat
	    let i = -1;
	    ffList.forEach( (g,j) => { if (g.__data__.fid === currFeat.id) i = j; });
	    // if we found it and it's not already the last, move it to the
	    // last position and reorder in the DOM.
	    if (i >= 0) {
		let lasti = ffList.length - 1;
	        let x = ffList[i];
		ffList[i] = ffList[lasti];
		ffList[lasti] = x;
		ffGrps.order();
	    }
	}
	
    }
    //----------------------------------------------
    //----------------------------------------------
    get highlighted () {
        return this.hiFeats ? Object.keys(this.hiFeats) : [];
    }
    set highlighted (hls) {
	if (typeof(hls) === 'string')
	    hls = [hls];
	//
	this.hiFeats = {};
        for(let h of hls){
	    this.hiFeats[h] = h;
	}
    }
    //----------------------------------------------
    get featHeight () {
        return this.cfg.featHeight;
    }
    set featHeight (h) {
        this.cfg.featHeight = h;
	this.cfg.laneHeight = this.cfg.featHeight + this.cfg.laneGap;
	this.cfg.laneHeightMinor = this.cfg.featHeight + this.cfg.laneGapMinor;
	this.cfg.blockHeight = this.cfg.laneHeight * this.cfg.minLanes * 2;
	this.update();
    }
    //----------------------------------------------
    get laneGap () {
        return this.cfg.laneGap;
    }
    set laneGap (g) {
        this.cfg.laneGap = g;
	this.cfg.laneHeight = this.cfg.featHeight + this.cfg.laneGap;
	this.cfg.blockHeight = this.cfg.laneHeight * this.cfg.minLanes * 2;
	this.update();
    }
    //----------------------------------------------
    get stripGap () {
        return this.cfg.stripGap;
    }
    set stripGap (g) {
        this.cfg.stripGap = g;
	this.cfg.topOffset = g;
	this.update();
    }
    //----------------------------------------------
    showFloatingText (text, x, y) {
	let sr = this.svg.node().getBoundingClientRect();
	x = x-sr.x-12;
	y = y-sr.y;
	let anchor = x < 60 ? 'start' : this.width-x < 60 ? 'end' : 'middle';
	this.floatingText.select('text')
	    .text(text)
	    .style('text-anchor',anchor)
	    .attr('x', x)
	    .attr('y', y)
    }
    hideFloatingText () {
	this.floatingText.select('text').text('');
    }
    //----------------------------------------------
    get showFeatureDetails () {
        return this._showFeatureDetails;
    }
    set showFeatureDetails (v) {
	let prev = this.showFeatureDetails;
        this._showFeatureDetails = v ? true : false;
	this.clearAll = prev !== this.showFeatureDetails;
	// 
	this.root.classed('showingAllLabels', this.showingAllLabels);
    }
    //----------------------------------------------
    get showAllLabels () {
        return this._showAllLabels;
    }
    set showAllLabels (v) {
        this._showAllLabels = v ? true : false;
	this.root.classed('showingAllLabels', this.showingAllLabels);
	this.update();
    }
    //----------------------------------------------
    get showingAllLabels () {
        return this.showFeatureDetails && this.showAllLabels;
    }
    //----------------------------------------------
    get spreadTranscripts () {
        return this._spreadTranscripts;
    }
    set spreadTranscripts (v) {
	let self = this;
        this._spreadTranscripts = v ? true : false;
	this.update();
    }
    //----------------------------------------------
    hideFiducials () {
	this.svgMain.select('g.fiducials')
	    .classed('hidden', true);
    }
} // end class ZoomView




/***/ })
/******/ ]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgN2E5NjAxNjhiYmRkZmRiYjZjZTUiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL3V0aWxzLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9jb25maWcuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0NvbXBvbmVudC5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvS2V5U3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0ZlYXR1cmUuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0xpc3RGb3JtdWxhUGFyc2VyLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9TVkdWaWV3LmpzIiwid2VicGFjazovLy8uL3d3dy9qcy92aWV3ZXIuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL01HVkFwcC5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvR2Vub21lLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9GZWF0dXJlTWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaWRiLWtleXZhbC9kaXN0L2lkYi1rZXl2YWwubWpzIiwid2VicGFjazovLy8uL3d3dy9qcy9MYXlvdXQuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL1F1ZXJ5TWFuYWdlci5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvQXV4RGF0YU1hbmFnZXIuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0xpc3RNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9MaXN0Rm9ybXVsYUV2YWx1YXRvci5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvTGlzdEVkaXRvci5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvRmFjZXRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9GYWNldC5qcyIsIndlYnBhY2s6Ly8vLi93d3cvanMvQlRNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9CbG9ja1RyYW5zbGF0b3IuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0dlbm9tZVZpZXcuanMiLCJ3ZWJwYWNrOi8vLy4vd3d3L2pzL0ZlYXR1cmVEZXRhaWxzLmpzIiwid2VicGFjazovLy8uL3d3dy9qcy9ab29tVmlldy5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1DQUEyQiwwQkFBMEIsRUFBRTtBQUN2RCx5Q0FBaUMsZUFBZTtBQUNoRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw4REFBc0QsK0RBQStEOztBQUVySDtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDNURBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFvRDtBQUNoRixTQUFTO0FBQ1QsS0FBSyxFO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG9EQUFvRDtBQUNoRixTQUFTO0FBQ1QsS0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7Ozs7Ozs7QUNoRUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVROzs7Ozs7Ozs7O0FDckJvQzs7QUFFNUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQkFBb0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxJQUFJO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFUTs7Ozs7Ozs7QUNyRFI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVROzs7Ozs7OztBQy9EUjtBQUFBO0FBQ0E7QUFDQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSx5QkFBeUIsd0JBQXdCLEVBQUU7O0FBRW5EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQSxHQUFHO0FBQ0gsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQkFBc0Isa0JBQWtCO0FBQ3hDLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFLEVBQUU7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsTUFBTTtBQUNOLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxvQkFBb0I7QUFDckQsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsUUFBUSxVQUFVLEVBQUUsSUFBSTtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0I7QUFDcEI7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7O0FBRU87Ozs7Ozs7Ozs7Ozs7QUMzUlI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRVE7Ozs7Ozs7Ozs7OztBQzlEUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1QkFBdUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixFQUFFO0FBQ2xCLGlCQUFpQixLQUFLLEdBQUcsRUFBRTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQixHQUFHLGdCQUFnQixHQUFHLGFBQWE7QUFDcEUsaUJBQWlCLGNBQWMsR0FBRyxnQkFBZ0IsR0FBRyxnQkFBZ0I7QUFDckU7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTs7QUFFQSxDQUFDOztBQUVPOzs7Ozs7Ozs7O0FDN1NvQjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRVE7Ozs7Ozs7Ozs7OztBQ25FcUQ7QUFDekM7QUFDUTs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTzs7Ozs7Ozs7OztBQ2pPUTs7QUFFaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVPOzs7Ozs7OztBQzdCUjtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRU87Ozs7Ozs7Ozs7OztBQ3BCUTtBQUNVO0FBQ1A7O0FBRW5CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsTUFBTSxNQUFNLE1BQU0sY0FBYyxjQUFjO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbUJBQW1CO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUFJO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTzs7Ozs7Ozs7QUM5R1I7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSx3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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OztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLFc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0IsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0EsNkJBQTZCO0FBQzdCLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxNQUFNO0FBQ04sRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFTyIsImZpbGUiOiJtZ3YuYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gNyk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgN2E5NjAxNjhiYmRkZmRiYjZjZTUiLCJcbi8vID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuLy8gICAgICAgICAgICAgICAgICAgIFVUSUxTXG4vLyA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyAoUmUtKUluaXRpYWxpemVzIGFuIG9wdGlvbiBsaXN0LlxuLy8gQXJnczpcbi8vICAgc2VsZWN0b3IgKHN0cmluZyBvciBOb2RlKSBDU1Mgc2VsZWN0b3Igb2YgdGhlIGNvbnRhaW5lciA8c2VsZWN0PiBlbGVtZW50LiBPciB0aGUgZWxlbWVudCBpdHNlbGYuXG4vLyAgIG9wdHMgKGxpc3QpIExpc3Qgb2Ygb3B0aW9uIGRhdGEgb2JqZWN0cy4gTWF5IGJlIHNpbXBsZSBzdHJpbmdzLiBNYXkgYmUgbW9yZSBjb21wbGV4LlxuLy8gICB2YWx1ZSAoZnVuY3Rpb24gb3IgbnVsbCkgRnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgPG9wdGlvbj4gdmFsdWUgZnJvbSBhbiBvcHRzIGl0ZW1cbi8vICAgICAgIERlZmF1bHRzIHRvIHRoZSBpZGVudGl0eSBmdW5jdGlvbiAoeD0+eCkuXG4vLyAgIGxhYmVsIChmdW5jdGlvbiBvciBudWxsKSBGdW5jdGlvbiB0byBwcm9kdWNlIHRoZSA8b3B0aW9uPiBsYWJlbCBmcm9tIGFuIG9wdHMgaXRlbVxuLy8gICAgICAgRGVmYXVsdHMgdG8gdGhlIHZhbHVlIGZ1bmN0aW9uLlxuLy8gICBtdWx0aSAoYm9vbGVhbikgU3BlY2lmaWVzIGlmIHRoZSBsaXN0IHN1cHBvcnQgbXVsdGlwbGUgc2VsZWN0aW9ucy4gKGRlZmF1bHQgPSBmYWxzZSlcbi8vICAgc2VsZWN0ZWQgKGZ1bmN0aW9uIG9yIG51bGwpIEZ1bmN0aW9uIHRvIGRldGVybWluZSBpZiBhIGdpdmVuIG9wdGlvbiBpcyBzZWxlY3RkLlxuLy8gICAgICAgRGVmYXVsdHMgdG8gZD0+RmFsc2UuIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG9ubHkgYXBwbGllZCB0byBuZXcgb3B0aW9ucy5cbi8vICAgc29ydEJ5IChmdW5jdGlvbikgT3B0aW9uYWwuIElmIHByb3ZpZGVkLCBhIGNvbXBhcmlzb24gZnVuY3Rpb24gdG8gdXNlIGZvciBzb3J0aW5nIHRoZSBvcHRpb25zLlxuLy8gICBcdCBUaGUgY29tcGFyaXNvbiBmdW5jdGlvbiBpcyBwYXNzZXMgdGhlIGRhdGEgb2JqZWN0cyBjb3JyZXNwb25kaW5nIHRvIHR3byBvcHRpb25zIGFuZCBzaG91bGRcbi8vICAgXHQgcmV0dXJuIC0xLCAwIG9yICsxLiBJZiBub3QgcHJvdmlkZWQsIHRoZSBvcHRpb24gbGlzdCB3aWxsIGhhdmUgdGhlIHNhbWUgc29ydCBvcmRlciBhcyB0aGUgb3B0cyBhcmd1bWVudC5cbi8vIFJldHVybnM6XG4vLyAgIFRoZSBvcHRpb24gbGlzdCBpbiBhIEQzIHNlbGVjdGlvbi5cbmZ1bmN0aW9uIGluaXRPcHRMaXN0KHNlbGVjdG9yLCBvcHRzLCB2YWx1ZSwgbGFiZWwsIG11bHRpLCBzZWxlY3RlZCwgc29ydEJ5KSB7XG5cbiAgICAvLyBzZXQgdXAgdGhlIGZ1bmN0aW9uc1xuICAgIGxldCBpZGVudCA9IGQgPT4gZDtcbiAgICB2YWx1ZSA9IHZhbHVlIHx8IGlkZW50O1xuICAgIGxhYmVsID0gbGFiZWwgfHwgdmFsdWU7XG4gICAgc2VsZWN0ZWQgPSBzZWxlY3RlZCB8fCAoeCA9PiBmYWxzZSk7XG5cbiAgICAvLyB0aGUgPHNlbGVjdD4gZWx0XG4gICAgbGV0IHMgPSBkMy5zZWxlY3Qoc2VsZWN0b3IpO1xuXG4gICAgLy8gbXVsdGlzZWxlY3RcbiAgICBzLnByb3BlcnR5KCdtdWx0aXBsZScsIG11bHRpIHx8IG51bGwpIDtcblxuICAgIC8vIGJpbmQgdGhlIG9wdHMuXG4gICAgbGV0IG9zID0gcy5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAgICAgLmRhdGEob3B0cywgbGFiZWwpO1xuICAgIG9zLmVudGVyKClcbiAgICAgICAgLmFwcGVuZChcIm9wdGlvblwiKSBcbiAgICAgICAgLmF0dHIoXCJ2YWx1ZVwiLCB2YWx1ZSlcbiAgICAgICAgLnByb3BlcnR5KFwic2VsZWN0ZWRcIiwgbyA9PiBzZWxlY3RlZChvKSB8fCBudWxsKVxuICAgICAgICAudGV4dChsYWJlbCkgXG4gICAgICAgIDtcbiAgICAvL1xuICAgIG9zLmV4aXQoKS5yZW1vdmUoKSA7XG5cbiAgICAvLyBzb3J0IHRoZSByZXN1bHRzXG4gICAgaWYgKCFzb3J0QnkpIHNvcnRCeSA9IChhLGIpID0+IHtcbiAgICBcdGxldCBhaSA9IG9wdHMuaW5kZXhPZihhKTtcblx0bGV0IGJpID0gb3B0cy5pbmRleE9mKGIpO1xuXHRyZXR1cm4gYWkgLSBiaTtcbiAgICB9XG4gICAgb3Muc29ydChzb3J0QnkpO1xuXG4gICAgLy9cbiAgICByZXR1cm4gcztcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcm9taXNpZmllcyBhIGNhbGwgdG8gZDMudHN2LlxuLy8gQXJnczpcbi8vICAgdXJsIChzdHJpbmcpIFRoZSB1cmwgb2YgdGhlIHRzdiByZXNvdXJjZVxuLy8gUmV0dXJuczpcbi8vICAgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGxpc3Qgb2Ygcm93IG9iamVjdHNcbmZ1bmN0aW9uIGQzdHN2KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZDMudHN2KHVybCwgZnVuY3Rpb24oZXJyb3IsIHZhbCl7XG4gICAgICAgICAgICBlcnJvciA/IHJlamVjdCh7IHN0YXR1czogZXJyb3Iuc3RhdHVzLCBzdGF0dXNUZXh0OiBlcnJvci5zdGF0dXNUZXh0fSkgOiByZXNvbHZlKHZhbCk7XG4gICAgICAgIH0pICBcbiAgICB9KTsgXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUHJvbWlzaWZpZXMgYSBjYWxsIHRvIGQzLmpzb24uXG4vLyBBcmdzOlxuLy8gICB1cmwgKHN0cmluZykgVGhlIHVybCBvZiB0aGUganNvbiByZXNvdXJjZVxuLy8gUmV0dXJuczpcbi8vICAgYSBwcm9taXNlIHRoYXQgcmVzb2x2ZXMgdG8gdGhlIGpzb24gb2JqZWN0IHZhbHVlLCBvciByZWplY3RzIHdpdGggYW4gZXJyb3JcbmZ1bmN0aW9uIGQzanNvbih1cmwpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGQzLmpzb24odXJsLCBmdW5jdGlvbihlcnJvciwgdmFsKXtcbiAgICAgICAgICAgIGVycm9yID8gcmVqZWN0KHsgc3RhdHVzOiBlcnJvci5zdGF0dXMsIHN0YXR1c1RleHQ6IGVycm9yLnN0YXR1c1RleHR9KSA6IHJlc29sdmUodmFsKTtcbiAgICAgICAgfSkgIFxuICAgIH0pOyBcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQcm9taXNpZmllcyBhIGNhbGwgdG8gZDMudGV4dC5cbi8vIEFyZ3M6XG4vLyAgIHVybCAoc3RyaW5nKSBUaGUgdXJsIG9mIHRoZSB0ZXh0IHJlc291cmNlXG4vLyBSZXR1cm5zOlxuLy8gICBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB0byB0aGUganNvbiBvYmplY3QgdmFsdWUsIG9yIHJlamVjdHMgd2l0aCBhbiBlcnJvclxuZnVuY3Rpb24gZDN0ZXh0KHVybCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZDMudGV4dCh1cmwsICd0ZXh0L3BsYWluJywgZnVuY3Rpb24oZXJyb3IsIHZhbCl7XG4gICAgICAgICAgICBlcnJvciA/IHJlamVjdCh7IHN0YXR1czogZXJyb3Iuc3RhdHVzLCBzdGF0dXNUZXh0OiBlcnJvci5zdGF0dXNUZXh0fSkgOiByZXNvbHZlKHZhbCk7XG4gICAgICAgIH0pICBcbiAgICB9KTsgXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmV0dXJucyBhIGRlZXAgY29weSBvZiBvYmplY3Qgby4gXG4vLyBBcmdzOlxuLy8gICBvICAob2JqZWN0KSBNdXN0IGJlIGEgSlNPTiBvYmplY3QgKG5vIGN1cmN1bGFyIHJlZnMsIG5vIGZ1bmN0aW9ucykuXG4vLyBSZXR1cm5zOlxuLy8gICBhIGRlZXAgY29weSBvZiBvXG5mdW5jdGlvbiBkZWVwYyhvKSB7XG4gICAgaWYgKCFvKSByZXR1cm4gbztcbiAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkobykpO1xufVxuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFBhcnNlcyBhIHN0cmluZyBvZiB0aGUgZm9ybSBcImNocjpzdGFydC4uZW5kXCIuXG4vLyBSZXR1cm5zOlxuLy8gICBvYmplY3QgY29udGluaW5nIHRoZSBwYXJzZWQgZmllbGRzLlxuLy8gRXhhbXBsZTpcbi8vICAgcGFyc2VDb29yZHMoXCIxMDoxMDAwMDAwMC4uMjAwMDAwMDBcIikgLT4ge2NocjpcIjEwXCIsIHN0YXJ0OjEwMDAwMDAwLCBlbmQ6MjAwMDAwMDB9XG5mdW5jdGlvbiBwYXJzZUNvb3JkcyAoY29vcmRzKSB7XG4gICAgbGV0IHJlID0gLyhbXjpdKyk6KFxcZCspXFwuXFwuKFxcZCspLztcbiAgICBsZXQgbSA9IGNvb3Jkcy5tYXRjaChyZSk7XG4gICAgcmV0dXJuIG0gPyB7Y2hyOm1bMV0sIHN0YXJ0OnBhcnNlSW50KG1bMl0pLCBlbmQ6cGFyc2VJbnQobVszXSl9IDogbnVsbDtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBGb3JtYXRzIGEgY2hyb21vc29tZSBuYW1lLCBzdGFydCBhbmQgZW5kIHBvc2l0aW9uIGFzIGEgc3RyaW5nLlxuLy8gQXJncyAoZm9ybSAxKTpcbi8vICAgY29vcmRzIChvYmplY3QpIE9mIHRoZSBmb3JtIHtjaHI6c3RyaW5nLCBzdGFydDppbnQsIGVuZDppbnR9XG4vLyBBcmdzIChmb3JtIDIpOlxuLy8gICBjaHIgc3RyaW5nXG4vLyAgIHN0YXJ0IGludFxuLy8gICBlbmQgaW50XG4vLyBSZXR1cm5zOlxuLy8gICAgIHN0cmluZ1xuLy8gRXhhbXBsZTpcbi8vICAgICBmb3JtYXRDb29yZHMoXCIxMFwiLCAxMDAwMDAwMCwgMjAwMDAwMDApIC0+IFwiMTA6MTAwMDAwMDAuLjIwMDAwMDAwXCJcbmZ1bmN0aW9uIGZvcm1hdENvb3JkcyAoY2hyLCBzdGFydCwgZW5kKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0bGV0IGMgPSBjaHI7XG5cdGNociA9IGMuY2hyO1xuXHRzdGFydCA9IGMuc3RhcnQ7XG5cdGVuZCA9IGMuZW5kO1xuICAgIH1cbiAgICByZXR1cm4gYCR7Y2hyfToke01hdGgucm91bmQoc3RhcnQpfS4uJHtNYXRoLnJvdW5kKGVuZCl9YFxufVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBSZXR1cm5zIHRydWUgaWZmIHRoZSB0d28gcmFuZ2VzIG92ZXJsYXAgYnkgYXQgbGVhc3QgMS5cbi8vIEVhY2ggcmFuZ2UgbXVzdCBoYXZlIGEgY2hyLCBzdGFydCwgYW5kIGVuZC5cbi8vXG5mdW5jdGlvbiBvdmVybGFwcyAoYSwgYikge1xuICAgIHJldHVybiBhLmNociA9PT0gYi5jaHIgJiYgYS5zdGFydCA8PSBiLmVuZCAmJiBhLmVuZCA+PSBiLnN0YXJ0O1xufVxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBHaXZlbiB0d28gcmFuZ2VzLCBhIGFuZCBiLCByZXR1cm5zIGEgLSBiLlxuLy8gVGhlIHJlc3VsdCBpcyBhIGxpc3Qgb2YgMCwgMSBvciAyIG5ldyByYW5nZXMsIGRlcGVuZGluZyBvbiBhIGFuZCBiLlxuZnVuY3Rpb24gc3VidHJhY3QoYSwgYikge1xuICAgIGlmIChhLmNociAhPT0gYi5jaHIpIHJldHVybiBbIGEgXTtcbiAgICBsZXQgYWJMZWZ0ID0geyBjaHI6YS5jaHIsIHN0YXJ0OmEuc3RhcnQsICAgICAgICAgICAgICAgICAgICBlbmQ6TWF0aC5taW4oYS5lbmQsIGIuc3RhcnQtMSkgfTtcbiAgICBsZXQgYWJSaWdodD0geyBjaHI6YS5jaHIsIHN0YXJ0Ok1hdGgubWF4KGEuc3RhcnQsIGIuZW5kKzEpLCBlbmQ6YS5lbmQgfTtcbiAgICBsZXQgYW5zID0gWyBhYkxlZnQsIGFiUmlnaHQgXS5maWx0ZXIoIHIgPT4gci5zdGFydCA8PSByLmVuZCApO1xuICAgIHJldHVybiBhbnM7XG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gQ3JlYXRlcyBhIGxpc3Qgb2Yga2V5LHZhbHVlIHBhaXJzIGZyb20gdGhlIG9iai5cbmZ1bmN0aW9uIG9iajJsaXN0IChvKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG8pLm1hcChrID0+IFtrLCBvW2tdXSkgICAgXG59XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmV0dXJucyB0cnVlIGlmZiB0aGUgdHdvIGxpc3RzIGhhdmUgdGhlIHNhbWUgY29udGVudHMgKGJhc2VkIG9uIGluZGV4T2YpLlxuLy8gQnJ1dGUgZm9yY2UgYXBwcm9hY2guIEJlIGNhcmVmdWwgd2hlcmUgeW91IHVzZSB0aGlzLlxuZnVuY3Rpb24gc2FtZSAoYWxzdCxibHN0KSB7XG4gICByZXR1cm4gYWxzdC5sZW5ndGggPT09IGJsc3QubGVuZ3RoICYmIFxuICAgICAgIGFsc3QucmVkdWNlKChhY2MseCkgPT4gKGFjYyAmJiBibHN0LmluZGV4T2YoeCk+PTApLCB0cnVlKTtcbn1cblxuLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEFkZCBiYXNpYyBzZXQgb3BzIHRvIFNldCBwcm90b3R5cGUuXG4vLyBMaWZ0ZWQgZnJvbTogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvU2V0XG5TZXQucHJvdG90eXBlLnVuaW9uID0gZnVuY3Rpb24oc2V0Qikge1xuICAgIHZhciB1bmlvbiA9IG5ldyBTZXQodGhpcyk7XG4gICAgZm9yICh2YXIgZWxlbSBvZiBzZXRCKSB7XG4gICAgICAgIHVuaW9uLmFkZChlbGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuaW9uO1xufVxuXG5TZXQucHJvdG90eXBlLmludGVyc2VjdGlvbiA9IGZ1bmN0aW9uKHNldEIpIHtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gbmV3IFNldCgpO1xuICAgIGZvciAodmFyIGVsZW0gb2Ygc2V0Qikge1xuICAgICAgICBpZiAodGhpcy5oYXMoZWxlbSkpIHtcbiAgICAgICAgICAgIGludGVyc2VjdGlvbi5hZGQoZWxlbSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbjtcbn1cblxuU2V0LnByb3RvdHlwZS5kaWZmZXJlbmNlID0gZnVuY3Rpb24oc2V0Qikge1xuICAgIHZhciBkaWZmZXJlbmNlID0gbmV3IFNldCh0aGlzKTtcbiAgICBmb3IgKHZhciBlbGVtIG9mIHNldEIpIHtcbiAgICAgICAgZGlmZmVyZW5jZS5kZWxldGUoZWxlbSk7XG4gICAgfVxuICAgIHJldHVybiBkaWZmZXJlbmNlO1xufVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5mdW5jdGlvbiBnZXRDYXJldFJhbmdlIChlbHQpIHtcbiAgICAvLyBGSVhNRTogZG9lcyBub3Qgd29yayBmb3IgSUVcbiAgICByZXR1cm4gW2VsdC5zZWxlY3Rpb25TdGFydCwgZWx0LnNlbGVjdGlvbkVuZF07XG59XG5mdW5jdGlvbiBzZXRDYXJldFJhbmdlIChlbHQsIHJhbmdlKSB7XG4gICAgLy8gRklYTUU6IGRvZXMgbm90IHdvcmsgZm9yIElFXG4gICAgZWx0LnNlbGVjdGlvblN0YXJ0ID0gcmFuZ2VbMF07XG4gICAgZWx0LnNlbGVjdGlvbkVuZCAgID0gcmFuZ2VbMV07XG59XG5mdW5jdGlvbiBzZXRDYXJldFBvc2l0aW9uIChlbHQsIHBvcykge1xuICAgIHNldENhcmV0UmFuZ2UoZWx0LCBbcG9zLHBvc10pO1xufVxuZnVuY3Rpb24gbW92ZUNhcmV0UG9zaXRpb24gKGVsdCwgZGVsdGEpIHtcbiAgICBzZXRDYXJldFBvc2l0aW9uKGVsdCwgZ2V0Q2FyZXRQb3NpdGlvbihlbHQpICsgZGVsdGEpO1xufVxuZnVuY3Rpb24gZ2V0Q2FyZXRQb3NpdGlvbiAoZWx0KSB7XG4gICAgbGV0IHIgPSBnZXRDYXJldFJhbmdlKGVsdCk7XG4gICAgcmV0dXJuIHJbMV07XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmV0dXJucyB0aGUgc2NyZWVuIGNvb3JkaW5hdGVzIG9mIGFuIFNWRyBzaGFwZSAoY2lyY2xlLCByZWN0LCBwb2x5Z29uLCBsaW5lKVxuLy8gYWZ0ZXIgYWxsIHRyYW5zZm9ybXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG4vL1xuLy8gQXJnczpcbi8vICAgICBzaGFwZSAobm9kZSkgVGhlIFNWRyBzaGFwZS5cbi8vXG4vLyBSZXR1cm5zOlxuLy8gICAgIFRoZSBmb3JtIG9mIHRoZSByZXR1cm5lZCB2YWx1ZSBkZXBlbmRzIG9uIHRoZSBzaGFwZS5cbi8vICAgICBjaXJjbGU6ICB7IGN4LCBjeSwgciB9XG4vLyAgICAgICAgIHJldHVybnMgdGhlIHRyYW5zZm9ybWVkIGNlbnRlciBwb2ludCBhbmQgdHJhbnNmb3JtZWQgcmFkaXVzICAgICAgICAgXG4vLyAgICAgbGluZTpcdHsgeDEsIHkxLCB4MiwgeTIgfVxuLy8gICAgICAgICByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCBlbmRwb2ludHNcbi8vICAgICByZWN0Olx0eyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH1cbi8vICAgICAgICAgcmV0dXJucyB0aGUgdHJhbnNmb3JtZWQgY29ybmVyIHBvaW50IGFuZCB0cmFuc2Zvcm1lZCB3aWR0aCtoZWlnaHQuXG4vLyAgICAgcG9seWdvbjogWyB7eCx5fSwge3gseX0gLCAuLi4gXVxuLy8gICAgICAgICByZXR1cm5zIHRoZSB0cmFuc2Zvcm1lZCBsaXN0IG9mIHBvaW50c1xuLy9cbi8vIEFkYXB0ZWQgZnJvbTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvNjg1ODQ3OS9yZWN0YW5nbGUtY29vcmRpbmF0ZXMtYWZ0ZXItdHJhbnNmb3JtP3JxPTFcbi8vXG5mdW5jdGlvbiBjb29yZHNBZnRlclRyYW5zZm9ybSAoc2hhcGUpIHtcbiAgICAvL1xuICAgIGxldCBkc2hhcGUgPSBkMy5zZWxlY3Qoc2hhcGUpO1xuICAgIGxldCBzdmcgPSBzaGFwZS5jbG9zZXN0KFwic3ZnXCIpO1xuICAgIGlmICghc3ZnKSByZXR1cm4gbnVsbDtcbiAgICBsZXQgc3R5cGUgPSBzaGFwZS50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgbGV0IG1hdHJpeCA9IHNoYXBlLmdldENUTSgpO1xuICAgIGxldCBwID0gc3ZnLmNyZWF0ZVNWR1BvaW50KCk7XG4gICAgbGV0IHAyPSBzdmcuY3JlYXRlU1ZHUG9pbnQoKTtcbiAgICAvL1xuICAgIHN3aXRjaCAoc3R5cGUpIHtcbiAgICAvL1xuICAgIGNhc2UgJ2NpcmNsZSc6XG5cdHAueCAgPSBwYXJzZUZsb2F0KGRzaGFwZS5hdHRyKFwiY3hcIikpO1xuXHRwLnkgID0gcGFyc2VGbG9hdChkc2hhcGUuYXR0cihcImN5XCIpKTtcblx0cDIueCA9IHAueCArIHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJyXCIpKTtcblx0cDIueSA9IHAueTtcblx0cCAgICA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cdHAyICAgPSBwMi5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblx0Ly8gY2FsYyBuZXcgcmFkaXVzIGFzIGRpc3RhbmNlIGJldHdlZW4gdHJhbnNmb3JtZWQgcG9pbnRzXG5cdGxldCBkeCA9IE1hdGguYWJzKHAueCAtIHAyLngpO1xuXHRsZXQgZHkgPSBNYXRoLmFicyhwLnkgLSBwMi55KTtcblx0bGV0IHIgPSBNYXRoLnNxcnQoZHgqZHggKyBkeSpkeSk7XG4gICAgICAgIHJldHVybiB7IGN4OiBwLngsIGN5OiBwLnksIHI6ciB9O1xuICAgIC8vXG4gICAgY2FzZSAncmVjdCc6XG5cdC8vIEZJWE1FOiBkb2VzIG5vdCBoYW5kbGUgcm90YXRpb25zIGNvcnJlY3RseS4gVG8gZml4LCB0cmFuc2xhdGUgY29ybmVyIHBvaW50cyBzZXBhcmF0ZWx5IGFuZCB0aGVuXG5cdC8vIGNhbGN1bGF0ZSB0aGUgdHJhbnNmb3JtZWQgd2lkdGggYW5kIGhlaWdodC4gQXMgYSBjb252ZW5pZW5jZSB0byB0aGUgdXNlciwgbWlnaHQgYmUgbmljZSB0byByZXR1cm5cblx0Ly8gdGhlIHRyYW5zZm9ybWVkIGNvcm5lciBwb2ludHMgYW5kIHBvc3NpYmx5IHRoZSBmaW5hbCBhbmdsZSBvZiByb3RhdGlvbi5cblx0cC54ICA9IHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJ4XCIpKTtcblx0cC55ICA9IHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJ5XCIpKTtcblx0cDIueCA9IHAueCArIHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJ3aWR0aFwiKSk7XG5cdHAyLnkgPSBwLnkgKyBwYXJzZUZsb2F0KGRzaGFwZS5hdHRyKFwiaGVpZ2h0XCIpKTtcblx0Ly9cblx0cCAgPSBwLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXHRwMiA9IHAyLm1hdHJpeFRyYW5zZm9ybShtYXRyaXgpO1xuXHQvL1xuICAgICAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSwgd2lkdGg6IHAyLngtcC54LCBoZWlnaHQ6IHAyLnktcC55IH07XG4gICAgLy9cbiAgICBjYXNlICdwb2x5Z29uJzpcbiAgICAgICAgbGV0IHB0cyA9IGRzaGFwZS5hdHRyKFwicG9pbnRzXCIpLnRyaW0oKS5zcGxpdCgvICsvKTtcblx0cmV0dXJuIHB0cy5tYXAoIHB0ID0+IHtcblx0ICAgIGxldCB4eSA9IHB0LnNwbGl0KFwiLFwiKTtcblx0ICAgIHAueCA9IHBhcnNlRmxvYXQoeHlbMF0pXG5cdCAgICBwLnkgPSBwYXJzZUZsb2F0KHh5WzFdKVxuXHQgICAgcCA9IHAubWF0cml4VHJhbnNmb3JtKG1hdHJpeCk7XG5cdCAgICByZXR1cm4geyB4OiBwLngsIHk6IHAueSB9O1xuXHR9KTtcbiAgICAvL1xuICAgIGNhc2UgJ2xpbmUnOlxuXHRwLnggICA9IHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJ4MVwiKSk7XG5cdHAueSAgID0gcGFyc2VGbG9hdChkc2hhcGUuYXR0cihcInkxXCIpKTtcblx0cDIueCAgPSBwYXJzZUZsb2F0KGRzaGFwZS5hdHRyKFwieDJcIikpO1xuXHRwMi55ICA9IHBhcnNlRmxvYXQoZHNoYXBlLmF0dHIoXCJ5MlwiKSk7XG5cdHAgICAgID0gcC5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcblx0cDIgICAgPSBwMi5tYXRyaXhUcmFuc2Zvcm0obWF0cml4KTtcbiAgICAgICAgcmV0dXJuIHsgeDE6IHAueCwgeTE6IHAueSwgeDI6IHAyLngsIHgyOiBwMi55IH07XG4gICAgLy9cbiAgICAvLyBGSVhNRTogYWRkIGNhc2UgJ3RleHQnXG4gICAgLy9cblxuICAgIGRlZmF1bHQ6XG5cdHRocm93IFwiVW5zdXBwb3J0ZWQgbm9kZSB0eXBlOiBcIiArIHN0eXBlO1xuICAgIH1cblxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIFJlbW92ZXMgZHVwbGljYXRlcyBmcm9tIGEgbGlzdCB3aGlsZSBwcmVzZXJ2aW5nIGxpc3Qgb3JkZXIuXG4vLyBBcmdzOlxuLy8gICAgIGxzdCAobGlzdClcbi8vIFJldHVybnM6XG4vLyAgICAgQSBwcm9jZXNzZWQgY29weSBvZiBsc3QgaW4gd2hpY2ggYW55IGR1cHMgaGF2ZSBiZWVuIHJlbW92ZWQuXG5mdW5jdGlvbiByZW1vdmVEdXBzIChsc3QpIHtcbiAgICBsZXQgbHN0MiA9IFtdO1xuICAgIGxldCBzZWVuID0gbmV3IFNldCgpO1xuICAgIGxzdC5mb3JFYWNoKHggPT4ge1xuXHQvLyByZW1vdmUgZHVwcyB3aGlsZSBwcmVzZXJ2aW5nIG9yZGVyXG5cdGlmIChzZWVuLmhhcyh4KSkgcmV0dXJuO1xuXHRsc3QyLnB1c2goeCk7XG5cdHNlZW4uYWRkKHgpO1xuICAgIH0pO1xuICAgIHJldHVybiBsc3QyO1xufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIENsaXBzIGEgdmFsdWUgdG8gYSByYW5nZS5cbmZ1bmN0aW9uIGNsaXAgKG4sIG1pbiwgbWF4KSB7XG4gICAgcmV0dXJuIE1hdGgubWluKG1heCwgTWF0aC5tYXgobWluLCBuKSk7XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gUmV0dXJucyB0aGUgZ2l2ZW4gYmFzZXBhaXIgYW1vdW50IFwicHJldHR5IHByaW50ZWRcIiB0byBhbiBhcHBvcnByaWF0ZSBzY2FsZSwgcHJlY2lzaW9uLCBhbmQgdW5pdHMuXG4vLyBFZywgIFxuLy8gICAgMTI3ID0+ICcxMjcgYnAnXG4vLyAgICAxMjM0NTY3ODkgPT4gJzEyMy41IE1iJ1xuZnVuY3Rpb24gcHJldHR5UHJpbnRCYXNlcyAobikge1xuICAgIGxldCBhYnNuID0gTWF0aC5hYnMobik7XG4gICAgaWYgKGFic24gPCAxMDAwKSB7XG4gICAgICAgIHJldHVybiBgJHtufSBicGA7XG4gICAgfVxuICAgIGlmIChhYnNuID49IDEwMDAgJiYgYWJzbiA8IDEwMDAwMDApIHtcbiAgICAgICAgcmV0dXJuIGAkeyhuLzEwMDApLnRvRml4ZWQoMil9IGtiYDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBgJHsobi8xMDAwMDAwKS50b0ZpeGVkKDIpfSBNYmA7XG4gICAgfVxuICAgIHJldHVybiBcbn1cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5leHBvcnQge1xuICAgIGluaXRPcHRMaXN0LFxuICAgIGQzdHN2LFxuICAgIGQzanNvbixcbiAgICBkM3RleHQsXG4gICAgZGVlcGMsXG4gICAgcGFyc2VDb29yZHMsXG4gICAgZm9ybWF0Q29vcmRzLFxuICAgIG92ZXJsYXBzLFxuICAgIHN1YnRyYWN0LFxuICAgIG9iajJsaXN0LFxuICAgIHNhbWUsXG4gICAgZ2V0Q2FyZXRSYW5nZSxcbiAgICBzZXRDYXJldFJhbmdlLFxuICAgIHNldENhcmV0UG9zaXRpb24sXG4gICAgbW92ZUNhcmV0UG9zaXRpb24sXG4gICAgZ2V0Q2FyZXRQb3NpdGlvbixcbiAgICBjb29yZHNBZnRlclRyYW5zZm9ybSxcbiAgICByZW1vdmVEdXBzLFxuICAgIGNsaXAsXG4gICAgcHJldHR5UHJpbnRCYXNlc1xufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL3V0aWxzLmpzXG4vLyBtb2R1bGUgaWQgPSAwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBNR1ZBcHAgOiB7XG5cdG5hbWUgOlx0XCJNdWx0aXBsZSBHZW5vbWUgVmlld2VyIChNR1YpXCIsXG5cdHZlcnNpb24gOlx0XCIxLjAuMFwiLCAvLyB1c2Ugc2VtYW50aWMgdmVyc2lvbmluZ1xuICAgIH0sXG4gICAgRmVhdHVyZU1hbmFnZXIgOiB7XG4gICAgICAgIHRyYW5zY3JpcHRCbG9ja1NpemUgOiAyMDAwMDAwXG4gICAgfSxcbiAgICBBdXhEYXRhTWFuYWdlciA6IHtcblx0bW91c2VtaW5lIDogJ3Rlc3QnLFxuXHRhbGxNaW5lcyA6IHtcblx0ICAgICdkZXYnIDogJ2h0dHA6Ly9iaG1naW1tLWRldjo4MDgwL21vdXNlbWluZScsXG5cdCAgICAndGVzdCc6ICdodHRwOi8vdGVzdC5tb3VzZW1pbmUub3JnL21vdXNlbWluZScsXG5cdCAgICAncHVibGljJyA6ICdodHRwOi8vd3d3Lm1vdXNlbWluZS5vcmcvbW91c2VtaW5lJyxcblx0fVxuICAgIH0sXG4gICAgU1ZHVmlldyA6IHtcblx0b3V0ZXJXaWR0aCA6IDEwMCxcblx0d2lkdGggOiAxMDAsXG5cdG91dGVySGVpZ2h0IDogMTAwLFxuXHRoZWlnaHQgOiAxMDAsXG5cdG1hcmdpbnMgOiB7dG9wOiAxOCwgcmlnaHQ6IDEyLCBib3R0b206IDEyLCBsZWZ0OiAxMn1cbiAgICB9LFxuICAgIFpvb21WaWV3IDoge1xuXHR0b3BPZmZzZXQgOiAyMCxcdFx0Ly8gWSBvZmZzZXQgdG8gZmlyc3Qgc3RyaXAgKHNob3VsZCA9IHN0cmlwR2FwLCBzbyB0ZWNobmljYWxseSByZWR1bmRhbnQpXG5cdGZlYXRIZWlnaHQgOiA4LFx0XHQvLyBoZWlnaHQgb2YgYSByZWN0YW5nbGUgcmVwcmVzZW50aW5nIGEgZmVhdHVyZVxuXHRsYW5lR2FwIDogOCxcdCAgICAgICAgLy8gc3BhY2UgYmV0d2VlbiBzd2ltIGxhbmVzLCBhbHNvIGRlZmluZXMgZm9udCBzaXplXG5cdGxhbmVIZWlnaHQgOiAxOCxcdC8vID09IGZlYXRIZWlnaHQgKyBsYW5lR2FwXG5cdGxhbmVHYXBNaW5vciA6IDIsXHQvLyBzcGFjZSBiZXR3ZWVuIG1pbm9yIGxhbmVzIChiZXR3ZWVuIHRyYW5zY3JpcHRzKVxuXHRsYW5lSGVpZ2h0TWlub3IgOiAxMCxcdC8vID09IGZlYXRIZWlnaHQgKyBsYW5lR2FwTWlub3Jcblx0bWluTGFuZXMgOiAzLFx0XHQvLyBtaW5pbXVtIG51bWJlciBvZiBzd2ltIGxhbmVzIChlYWNoIHN0cmFuZClcblx0YmxvY2tIZWlnaHQgOiA2MCxcdC8vID09IDIgKiBtaW5MYW5lcyAqIGxhbmVIZWlnaHRcblx0bWluU3RyaXBIZWlnaHQgOiA3NSwgICAgLy8gaGVpZ2h0IHBlciBnZW5vbWUgaW4gdGhlIHpvb20gdmlld1xuXHRzdHJpcEdhcCA6IDIwLFx0ICAgICAgICAvLyBzcGFjZSBiZXR3ZWVuIHN0cmlwc1xuXHRtYXhTQmdhcCA6IDIwLFx0ICAgICAgICAvLyBtYXggZ2FwIGFsbG93ZWQgYmV0d2VlbiBibG9ja3MuXG5cdGRtb2RlIDogJ2NvbXBhcmlzb24nLCAgIC8vIGluaXRpYWwgZHJhd2luZyBtb2RlLiAnY29tcGFyaXNvbicgb3IgJ3JlZmVyZW5jZSdcblx0d2hlZWxUaHJlc2hvbGQgOiAzLFx0Ly8gbWluaW11bSB3aGVlbCBkaXN0YW5jZSBcblx0ZmVhdHVyZURldGFpbFRocmVzaG9sZCA6IDIwMDAwMDAsIC8vIGlmIHdpZHRoIDw9IHRocmVzaCwgZHJhdyBmZWF0dXJlIGRldGFpbHMuXG5cdHNlcXVlbmNlRGlzcGxheVRocmVzaG9sZDogMSwgLy8gZGlzcGxheSBzZXF1ZW5jZSBpZiBwaXhlbHMgcGVyIGJhc2UgaXMgYXQgbGVhc3QgdGhpc1xuXHR3aGVlbENvbnRleHREZWxheSA6IDMwMCwvLyBtcyBkZWxheSBhZnRlciBsYXN0IHdoZWVsIGV2ZW50IGJlZm9yZSBjaGFuZ2luZyBjb250ZXh0XG4gICAgfSxcbiAgICBRdWVyeU1hbmFnZXIgOiB7XG5cdHNlYXJjaFR5cGVzIDogW3tcblx0ICAgIG1ldGhvZDogXCJmZWF0dXJlc0J5UGhlbm90eXBlXCIsXG5cdCAgICBsYWJlbDogXCIuLi5ieSBwaGVub3R5cGUgb3IgZGlzZWFzZVwiLFxuXHQgICAgdGVtcGxhdGU6IFwiXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJQaGVuby9kaXNlYXNlIChNUC9ETykgdGVybSBvciBJRHNcIlxuXHR9LHtcblx0ICAgIG1ldGhvZDogXCJmZWF0dXJlc0J5RnVuY3Rpb25cIixcblx0ICAgIGxhYmVsOiBcIi4uLmJ5IGNlbGx1bGFyIGZ1bmN0aW9uXCIsXG5cdCAgICB0ZW1wbGF0ZTogXCJcIixcblx0ICAgIHBsYWNlaG9sZGVyOiBcIkdlbmUgT250b2xvZ3kgKEdPKSB0ZXJtcyBvciBJRHNcIlxuXHR9LHtcblx0ICAgIG1ldGhvZDogXCJmZWF0dXJlc0J5UGF0aHdheVwiLFxuXHQgICAgbGFiZWw6IFwiLi4uYnkgcGF0aHdheVwiLFxuXHQgICAgdGVtcGxhdGU6IFwiXCIsXG5cdCAgICBwbGFjZWhvbGRlcjogXCJSZWFjdG9tZSBwYXRod2F5cyBuYW1lcywgSURzXCJcblx0fSx7XG5cdCAgICBtZXRob2Q6IFwiZmVhdHVyZXNCeUlkXCIsXG5cdCAgICBsYWJlbDogXCIuLi5ieSBzeW1ib2wvSURcIixcblx0ICAgIHRlbXBsYXRlOiBcIlwiLFxuXHQgICAgcGxhY2Vob2xkZXI6IFwiTUdJIG5hbWVzLCBzeW5vbnltcywgZXRjLlwiXG5cdH1dXG4gICAgfVxufTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL2NvbmZpZy5qc1xuLy8gbW9kdWxlIGlkID0gMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIENvbXBvbmVudCB7XG4gICAgLy8gYXBwIC0gdGhlIG93bmluZyBhcHAgb2JqZWN0XG4gICAgLy8gZWx0IC0gY29udGFpbmVyLiBtYXkgYmUgYSBzdHJpbmcgKHNlbGVjdG9yKSwgYSBET00gbm9kZSwgb3IgYSBkMyBzZWxlY3Rpb24gb2YgMSBub2RlLlxuICAgIGNvbnN0cnVjdG9yIChhcHAsIGVsdCkge1xuXHR0aGlzLmFwcCA9IGFwcFxuXHRpZiAodHlwZW9mKGVsdCkgPT09IFwic3RyaW5nXCIpXG5cdCAgICAvLyBlbHQgaXMgYSBDU1Mgc2VsZWN0b3Jcblx0ICAgIHRoaXMucm9vdCA9IGQzLnNlbGVjdChlbHQpO1xuXHRlbHNlIGlmICh0eXBlb2YoZWx0LnNlbGVjdEFsbCkgPT09IFwiZnVuY3Rpb25cIilcblx0ICAgIC8vIGVsdCBpcyBhIGQzIHNlbGVjdGlvblxuXHQgICAgdGhpcy5yb290ID0gZWx0O1xuXHRlbHNlIGlmICh0eXBlb2YoZWx0LmdldEVsZW1lbnRzQnlUYWdOYW1lKSA9PT0gXCJmdW5jdGlvblwiKVxuXHQgICAgLy8gZWx0IGlzIGEgRE9NIG5vZGVcblx0ICAgIHRoaXMucm9vdCA9IGQzLnNlbGVjdChlbHQpO1xuICAgIH1cbiAgICBpbml0RG9tICgpIHtcbiAgICAgICAgLy8gb3ZlcnJpZGUgbWVcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbXBvbmVudCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvQ29tcG9uZW50LmpzXG4vLyBtb2R1bGUgaWQgPSAyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IFN0b3JlLCBzZXQsIGdldCwgZGVsLCBjbGVhciwga2V5cyB9IGZyb20gJ2lkYi1rZXl2YWwnO1xuXG5jb25zdCBEQl9OQU1FX1BSRUZJWCA9ICdtZ3YtZGF0YWNhY2hlLSc7XG5cbmNsYXNzIEtleVN0b3JlIHtcbiAgICBjb25zdHJ1Y3RvciAobmFtZSkge1xuXHR0cnkge1xuXHQgICAgdGhpcy5zdG9yZSA9IG5ldyBTdG9yZShEQl9OQU1FX1BSRUZJWCtuYW1lLCBuYW1lKTtcblx0ICAgIHRoaXMuZGlzYWJsZWQgPSBmYWxzZTtcblx0ICAgIGNvbnNvbGUubG9nKGBLZXlTdG9yZTogJHtEQl9OQU1FX1BSRUZJWCtuYW1lfWApO1xuXHR9XG5cdGNhdGNoIChlcnIpIHtcblx0ICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuXHQgICAgdGhpcy5kaXNhYmxlZCA9IHRydWU7XG5cdCAgICB0aGlzLm51bGxQID0gUHJvbWlzZS5yZXNvbHZlKG51bGwpO1xuXHQgICAgY29uc29sZS5sb2coYEtleVN0b3JlOiBlcnJvciBpbiBjb25zdHJ1Y3RvcjogJHtlcnJ9IFxcbiBEaXNhYmxlZC5gKVxuXHR9XG4gICAgfVxuICAgIGdldCAoa2V5KSB7XG5cdGlmICh0aGlzLmRpc2FibGVkKSBcblx0ICAgIHJldHVybiB0aGlzLm51bGxQO1xuICAgICAgICByZXR1cm4gZ2V0KGtleSwgdGhpcy5zdG9yZSk7XG4gICAgfVxuICAgIGRlbCAoa2V5KSB7XG5cdGlmICh0aGlzLmRpc2FibGVkKSBcblx0ICAgIHJldHVybiB0aGlzLm51bGxQO1xuICAgICAgICByZXR1cm4gZGVsKGtleSwgdGhpcy5zdG9yZSk7XG4gICAgfVxuICAgIHNldCAoa2V5LCB2YWx1ZSkge1xuXHRpZiAodGhpcy5kaXNhYmxlZCkgXG5cdCAgICByZXR1cm4gdGhpcy5udWxsUDtcbiAgICAgICAgcmV0dXJuIHNldChrZXksIHZhbHVlLCB0aGlzLnN0b3JlKTtcbiAgICB9XG4gICAgcHV0IChrZXksIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAga2V5cyAoKSB7XG5cdGlmICh0aGlzLmRpc2FibGVkKSBcblx0ICAgIHJldHVybiB0aGlzLm51bGxQO1xuICAgICAgICByZXR1cm4ga2V5cyh0aGlzLnN0b3JlKTtcbiAgICB9XG4gICAgY29udGFpbnMgKGtleSkge1xuXHRpZiAodGhpcy5kaXNhYmxlZCkgXG5cdCAgICByZXR1cm4gdGhpcy5udWxsUDtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KGtleSkudGhlbih4ID0+IHggIT09IHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcblx0aWYgKHRoaXMuZGlzYWJsZWQpIFxuXHQgICAgcmV0dXJuIHRoaXMubnVsbFA7XG4gICAgICAgIHJldHVybiBjbGVhcih0aGlzLnN0b3JlKTtcbiAgICB9XG59O1xuXG5leHBvcnQgeyBLZXlTdG9yZSB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvS2V5U3RvcmUuanNcbi8vIG1vZHVsZSBpZCA9IDNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY2xhc3MgRmVhdHVyZSB7XG4gICAgY29uc3RydWN0b3IgKGdlbm9tZSwgSUQsIGdmZk9iaikge1xuXHR0aGlzLmdlbm9tZSA9IGdlbm9tZVxuXHR0aGlzLmNociAgICA9IGdmZk9ialswXTtcblx0dGhpcy5zdGFydCAgPSBnZmZPYmpbM107XG5cdHRoaXMuZW5kICAgID0gZ2ZmT2JqWzRdO1xuXHR0aGlzLnN0cmFuZCA9IGdmZk9ials2XTtcbiAgICAgICAgdGhpcy50eXBlICAgID0gZ2ZmT2JqWzJdO1xuXHRsZXQgZ2EgPSBnZmZPYmpbOF07XG4gICAgICAgIHRoaXMuYmlvdHlwZSA9IGdhWydiaW90eXBlJ107XG5cdHRoaXMuSUQgICAgICA9IElEO1xuXHR0aGlzLmNhbm9uaWNhbCA9IGdhWydjYW5vbmljYWxfaWQnXTtcbiAgICAgICAgdGhpcy5zeW1ib2wgID0gZ2FbJ2Nhbm9uaWNhbF9zeW1ib2wnXTtcblx0Ly9cblx0dGhpcy50cmFuc2NyaXB0X2NvdW50ID0gZ2FbJ3RyYW5zY3JpcHRfY291bnQnXSB8fCAwO1xuXHR0aGlzLnRyYW5zY3JpcHRzID0gW107XG5cdHRoaXMudHJhbnNjcmlwdHNMb2FkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy9cbiAgICBnZXQgbGVuZ3RoICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5kIC0gdGhpcy5zdGFydCArIDE7XG4gICAgfVxuICAgIC8vXG4gICAgZ2V0IGlkICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2Fub25pY2FsIHx8IHRoaXMuSUQ7XG4gICAgfVxuICAgIC8vXG4gICAgZ2V0IGxhYmVsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3ltYm9sIHx8IHRoaXMuSUQ7XG4gICAgfVxuICAgIC8vXG4gICAgZ2V0TXVuZ2VkVHlwZSAoKSB7XG5cdHJldHVybiB0aGlzLnR5cGUgPT09IFwiZ2VuZVwiID9cblx0ICAgIHRoaXMuYmlvdHlwZS5pbmRleE9mKCdwcm90ZWluJykgPj0gMCA/XG5cdFx0XCJwcm90ZWluX2NvZGluZ19nZW5lXCJcblx0XHQ6XG5cdFx0dGhpcy5iaW90eXBlLmluZGV4T2YoXCJwc2V1ZG9nZW5lXCIpID49IDAgP1xuXHRcdCAgICBcInBzZXVkb2dlbmVcIlxuXHRcdCAgICA6XG5cdFx0ICAgICh0aGlzLmJpb3R5cGUuaW5kZXhPZihcIlJOQVwiKSA+PSAwIHx8IHRoaXMuYmlvdHlwZS5pbmRleE9mKFwiYW50aXNlbnNlXCIpID49IDApID9cblx0XHRcdFwibmNSTkFfZ2VuZVwiXG5cdFx0XHQ6XG5cdFx0XHR0aGlzLmJpb3R5cGUuaW5kZXhPZihcInNlZ21lbnRcIikgPj0gMCA/XG5cdFx0XHQgICAgXCJnZW5lX3NlZ21lbnRcIlxuXHRcdFx0ICAgIDpcblx0XHRcdCAgICBcIm90aGVyX2dlbmVcIlxuXHQgICAgOlxuXHQgICAgdGhpcy50eXBlID09PSBcInBzZXVkb2dlbmVcIiA/XG5cdFx0XCJwc2V1ZG9nZW5lXCJcblx0XHQ6XG5cdFx0dGhpcy50eXBlLmluZGV4T2YoXCJnZW5lX3NlZ21lbnRcIikgPj0gMCA/XG5cdFx0ICAgIFwiZ2VuZV9zZWdtZW50XCJcblx0XHQgICAgOlxuXHRcdCAgICB0aGlzLnR5cGUuaW5kZXhPZihcIlJOQVwiKSA+PSAwID9cblx0XHRcdFwibmNSTkFfZ2VuZVwiXG5cdFx0XHQ6XG5cdFx0XHR0aGlzLnR5cGUuaW5kZXhPZihcImdlbmVcIikgPj0gMCA/XG5cdFx0XHQgICAgXCJvdGhlcl9nZW5lXCJcblx0XHRcdCAgICA6XG5cdFx0XHQgICAgXCJvdGhlcl9mZWF0dXJlX3R5cGVcIjtcbiAgICB9XG59XG5cbmV4cG9ydCB7IEZlYXR1cmUgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL0ZlYXR1cmUuanNcbi8vIG1vZHVsZSBpZCA9IDRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vLyBQYXJzZXMgYSBsaXN0IG9wZXJhdG9yIGV4cHJlc3Npb24sIGVnIFwiKGEgKyBiKSpjIC0gZFwiXG4vLyBSZXR1cm5zIGFuIGFic3RyYWN0IHN5bnRheCB0cmVlLlxuLy8gICAgIExlYWYgbm9kZXMgPSBsaXN0IG5hbWVzLiBUaGV5IGFyZSBzaW1wbGUgc3RyaW5ncy5cbi8vICAgICBJbnRlcmlvciBub2RlcyA9IG9wZXJhdGlvbnMuIFRoZXkgbG9vayBsaWtlOiB7bGVmdDpub2RlLCBvcDpzdHJpbmcsIHJpZ2h0Om5vZGV9XG4vLyBcbmNsYXNzIExpc3RGb3JtdWxhUGFyc2VyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG5cdHRoaXMucl9vcCAgICA9IC9bKy1dLztcblx0dGhpcy5yX29wMiAgID0gL1sqXS87XG5cdHRoaXMucl9vcHMgICA9IC9bKCkrKi1dLztcblx0dGhpcy5yX2lkZW50ID0gL1thLXpBLVpfXVthLXpBLVowLTlfXSovO1xuXHR0aGlzLnJfcXN0ciAgPSAvXCJbXlwiXSpcIi87XG5cdHRoaXMucmUgPSBuZXcgUmVnRXhwKGAoJHt0aGlzLnJfb3BzLnNvdXJjZX18JHt0aGlzLnJfcXN0ci5zb3VyY2V9fCR7dGhpcy5yX2lkZW50LnNvdXJjZX0pYCwgJ2cnKTtcblx0Ly90aGlzLnJlID0gLyhbKCkrKi1dfFwiW15cIl0rXCJ8W2EtekEtWl9dW2EtekEtWjAtOV9dKikvZ1xuXHR0aGlzLl9pbml0KFwiXCIpO1xuICAgIH1cbiAgICBfaW5pdCAocykge1xuICAgICAgICB0aGlzLmV4cHIgPSBzO1xuXHR0aGlzLnRva2VucyA9IHRoaXMuZXhwci5tYXRjaCh0aGlzLnJlKSB8fCBbXTtcblx0dGhpcy5pID0gMDtcbiAgICB9XG4gICAgX3BlZWtUb2tlbigpIHtcblx0cmV0dXJuIHRoaXMudG9rZW5zW3RoaXMuaV07XG4gICAgfVxuICAgIF9uZXh0VG9rZW4gKCkge1xuXHRsZXQgdDtcbiAgICAgICAgaWYgKHRoaXMuaSA8IHRoaXMudG9rZW5zLmxlbmd0aCkge1xuXHQgICAgdCA9IHRoaXMudG9rZW5zW3RoaXMuaV07XG5cdCAgICB0aGlzLmkgKz0gMTtcblx0fVxuXHRyZXR1cm4gdDtcbiAgICB9XG4gICAgX2V4cHIgKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX3Rlcm0oKTtcblx0bGV0IG9wID0gdGhpcy5fcGVla1Rva2VuKCk7XG5cdGlmIChvcCA9PT0gXCIrXCIgfHwgb3AgPT09IFwiLVwiKSB7XG5cdCAgICB0aGlzLl9uZXh0VG9rZW4oKTtcblx0ICAgIG5vZGUgPSB7IGxlZnQ6bm9kZSwgb3A6b3A9PT1cIitcIj9cInVuaW9uXCI6XCJkaWZmZXJlbmNlXCIsIHJpZ2h0OiB0aGlzLl9leHByKCkgfVxuXHQgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH0gICAgICAgICAgICAgICBcblx0ZWxzZSBpZiAob3AgPT09IFwiKVwiIHx8IG9wID09PSB1bmRlZmluZWQgfHwgb3AgPT09IG51bGwpXG5cdCAgICByZXR1cm4gbm9kZTtcblx0ZWxzZVxuXHQgICAgdGhpcy5fZXJyb3IoXCJVTklPTiBvciBJTlRFUlNFQ1RJT04gb3IgKSBvciBOVUxMXCIsIG9wKTtcbiAgICB9XG4gICAgX3Rlcm0gKCkge1xuICAgICAgICBsZXQgbm9kZSA9IHRoaXMuX2ZhY3RvcigpO1xuXHRsZXQgb3AgPSB0aGlzLl9wZWVrVG9rZW4oKTtcblx0aWYgKG9wID09PSBcIipcIikge1xuXHQgICAgdGhpcy5fbmV4dFRva2VuKCk7XG5cdCAgICBub2RlID0geyBsZWZ0Om5vZGUsIG9wOlwiaW50ZXJzZWN0aW9uXCIsIHJpZ2h0OiB0aGlzLl9mYWN0b3IoKSB9XG5cdH1cblx0cmV0dXJuIG5vZGU7XG4gICAgfVxuICAgIF9mYWN0b3IgKCkge1xuICAgICAgICBsZXQgdCA9IHRoaXMuX25leHRUb2tlbigpO1xuXHRpZiAodCA9PT0gXCIoXCIpe1xuXHQgICAgbGV0IG5vZGUgPSB0aGlzLl9leHByKCk7XG5cdCAgICBsZXQgbnQgPSB0aGlzLl9uZXh0VG9rZW4oKTtcblx0ICAgIGlmIChudCAhPT0gXCIpXCIpIHRoaXMuX2Vycm9yKFwiJyknXCIsIG50KTtcblx0ICAgIHJldHVybiBub2RlO1xuXHR9XG5cdGVsc2UgaWYgKHQgJiYgKHQuc3RhcnRzV2l0aCgnXCInKSkpIHtcblx0ICAgIHJldHVybiB0LnN1YnN0cmluZygxLCB0Lmxlbmd0aC0xKTtcblx0fVxuXHRlbHNlIGlmICh0ICYmIHQubWF0Y2goL1thLXpBLVpfXS8pKSB7XG5cdCAgICByZXR1cm4gdDtcblx0fVxuXHRlbHNlXG5cdCAgICB0aGlzLl9lcnJvcihcIkVYUFIgb3IgSURFTlRcIiwgdHx8XCJOVUxMXCIpO1xuXHRyZXR1cm4gdDtcblx0ICAgIFxuICAgIH1cbiAgICBfZXJyb3IgKGV4cGVjdGVkLCBzYXcpIHtcbiAgICAgICAgdGhyb3cgYFBhcnNlIGVycm9yOiBleHBlY3RlZCAke2V4cGVjdGVkfSBidXQgc2F3ICR7c2F3fS5gO1xuICAgIH1cbiAgICAvLyBQYXJzZXMgdGhlIHN0cmluZyBhbmQgcmV0dXJucyB0aGUgYWJzdHJhY3Qgc3ludGF4IHRyZWUuXG4gICAgLy8gVGhyb3dzIGFuIGV4Y2VwdGlvbiBpZiB0aGVyZSBpcyBhIHN5bnRheCBlcnJvci5cbiAgICBwYXJzZSAocykge1xuXHR0aGlzLl9pbml0KHMpO1xuXHRyZXR1cm4gdGhpcy5fZXhwcigpO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRydWUgaWZmIHN0cmluZyBpcyBzeW50YWN0aWNhbGx5IHZhbGlkXG4gICAgaXNWYWxpZCAocykge1xuICAgICAgICB0cnkge1xuXHQgICAgdGhpcy5wYXJzZShzKTtcblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGNhdGNoIChlKSB7XG5cdCAgICByZXR1cm4gZmFsc2U7XG5cdH1cbiAgICB9XG59XG5cbmV4cG9ydCB7IExpc3RGb3JtdWxhUGFyc2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9MaXN0Rm9ybXVsYVBhcnNlci5qc1xuLy8gbW9kdWxlIGlkID0gNVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4vQ29tcG9uZW50JztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBTVkdWaWV3IGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAoYXBwLCBlbHQsIHdpZHRoLCBoZWlnaHQsIG1hcmdpbnMsIHJvdGF0aW9uLCB0cmFuc2xhdGlvbikge1xuICAgICAgICBzdXBlcihhcHAsIGVsdCk7XG4gICAgICAgIHRoaXMuc3ZnID0gdGhpcy5yb290LnNlbGVjdChcInN2Z1wiKTtcbiAgICAgICAgdGhpcy5zdmdNYWluID0gdGhpcy5zdmdcbiAgICAgICAgICAgIC5hcHBlbmQoXCJnXCIpICAgIC8vIHRoZSBtYXJnaW4tdHJhbnNsYXRlZCBncm91cFxuICAgICAgICAgICAgLmFwcGVuZChcImdcIilcdCAgLy8gbWFpbiBncm91cCBmb3IgdGhlIGRyYXdpbmdcblx0ICAgIC5hdHRyKFwibmFtZVwiLFwic3ZnbWFpblwiKTtcblx0bGV0IGMgPSBjb25maWcuU1ZHVmlldztcblx0dGhpcy5vdXRlcldpZHRoID0gYy5vdXRlcldpZHRoO1xuXHR0aGlzLndpZHRoID0gYy53aWR0aDtcblx0dGhpcy5vdXRlckhlaWdodCA9IGMub3V0ZXJIZWlnaHQ7XG5cdHRoaXMuaGVpZ2h0ID0gYy5oZWlnaHQ7XG5cdHRoaXMubWFyZ2lucyA9IE9iamVjdC5hc3NpZ24oe30sIGMubWFyZ2lucyk7XG5cdHRoaXMucm90YXRpb24gPSAwO1xuXHR0aGlzLnRyYW5zbGF0aW9uID0gWzAsMF07XG5cdC8vXG4gICAgICAgIHRoaXMuc2V0R2VvbSh7d2lkdGgsIGhlaWdodCwgbWFyZ2lucywgcm90YXRpb24sIHRyYW5zbGF0aW9ufSk7XG4gICAgfVxuICAgIHNldEdlb20gKGNmZykge1xuICAgICAgICB0aGlzLm91dGVyV2lkdGggID0gY2ZnLndpZHRoICAgICAgIHx8IHRoaXMub3V0ZXJXaWR0aDtcbiAgICAgICAgdGhpcy5vdXRlckhlaWdodCA9IGNmZy5oZWlnaHQgICAgICB8fCB0aGlzLm91dGVySGVpZ2h0O1xuICAgICAgICB0aGlzLm1hcmdpbnMgICAgID0gY2ZnLm1hcmdpbnMgICAgIHx8IHRoaXMubWFyZ2lucztcblx0dGhpcy5yb3RhdGlvbiAgICA9IHR5cGVvZihjZmcucm90YXRpb24pID09PSBcIm51bWJlclwiID8gY2ZnLnJvdGF0aW9uIDogdGhpcy5yb3RhdGlvbjtcblx0dGhpcy50cmFuc2xhdGlvbiA9IGNmZy50cmFuc2xhdGlvbiB8fCB0aGlzLnRyYW5zbGF0aW9uO1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLndpZHRoICA9IHRoaXMub3V0ZXJXaWR0aCAgLSB0aGlzLm1hcmdpbnMubGVmdCAtIHRoaXMubWFyZ2lucy5yaWdodDtcbiAgICAgICAgdGhpcy5oZWlnaHQgPSB0aGlzLm91dGVySGVpZ2h0IC0gdGhpcy5tYXJnaW5zLnRvcCAgLSB0aGlzLm1hcmdpbnMuYm90dG9tO1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLnN2Zy5hdHRyKFwid2lkdGhcIiwgdGhpcy5vdXRlcldpZHRoKVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCB0aGlzLm91dGVySGVpZ2h0KVxuICAgICAgICAgICAgLnNlbGVjdCgnZ1tuYW1lPVwic3ZnbWFpblwiXScpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIGB0cmFuc2xhdGUoJHt0aGlzLm1hcmdpbnMubGVmdH0sJHt0aGlzLm1hcmdpbnMudG9wfSkgcm90YXRlKCR7dGhpcy5yb3RhdGlvbn0pIHRyYW5zbGF0ZSgke3RoaXMudHJhbnNsYXRpb25bMF19LCR7dGhpcy50cmFuc2xhdGlvblsxXX0pYCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBzZXRNYXJnaW5zKCB0bSwgcm0sIGJtLCBsbSApIHtcblx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0ICAgIHJtID0gYm0gPSBsbSA9IHRtO1xuXHR9XG5cdGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIpIHtcblx0ICAgIGJtID0gdG07XG5cdCAgICBsbSA9IHJtO1xuXHR9XG5cdGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggIT09IDQpXG5cdCAgICB0aHJvdyBcIkJhZCBhcmd1bWVudHMuXCI7XG4gICAgICAgIC8vXG5cdHRoaXMuc2V0R2VvbSh7dG9wOiB0bSwgcmlnaHQ6IHJtLCBib3R0b206IGJtLCBsZWZ0OiBsbX0pO1xuXHQvL1xuXHRyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcm90YXRlIChkZWcpIHtcbiAgICAgICAgdGhpcy5zZXRHZW9tKHtyb3RhdGlvbjpkZWd9KTtcblx0cmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIHRyYW5zbGF0ZSAoZHgsIGR5KSB7XG4gICAgICAgIHRoaXMuc2V0R2VvbSh7dHJhbnNsYXRpb246W2R4LGR5XX0pO1xuXHRyZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLy8gQXJnczpcbiAgICAvLyAgIHRoZSB3aW5kb3cgd2lkdGhcbiAgICBmaXRUb1dpZHRoICh3aWR0aCkge1xuICAgICAgICBsZXQgciA9IHRoaXMuc3ZnWzBdWzBdLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICB0aGlzLnNldEdlb20oe3dpZHRoOiB3aWR0aCAtIHIueH0pXG5cdHJldHVybiB0aGlzO1xuICAgIH1cbn0gLy8gZW5kIGNsYXNzIFNWR1ZpZXdcblxuZXhwb3J0IHsgU1ZHVmlldyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvU1ZHVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBNR1ZBcHAgfSBmcm9tICcuL01HVkFwcCc7XG5pbXBvcnQgeyByZW1vdmVEdXBzIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4vL1xuLy8gcHFzdHJpbmcgPSBQYXJzZSBxc3RyaW5nLiBQYXJzZXMgdGhlIHBhcmFtZXRlciBwb3J0aW9uIG9mIHRoZSBVUkwuXG4vL1xuZnVuY3Rpb24gcHFzdHJpbmcgKHFzdHJpbmcpIHtcbiAgICAvL1xuICAgIGxldCBjZmcgPSB7fTtcblxuICAgIC8vIEZJWE1FOiBVUkxTZWFyY2hQYXJhbXMgQVBJIGlzIG5vdCBzdXBwb3J0ZWQgaW4gYWxsIGJyb3dzZXJzLlxuICAgIC8vIE9LIGZvciBkZXZlbG9wbWVudCBidXQgbmVlZCBhIGZhbGxiYWNrIGV2ZW50dWFsbHkuXG4gICAgbGV0IHBybXMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKHFzdHJpbmcpO1xuICAgIGxldCBnZW5vbWVzID0gW107XG5cbiAgICAvLyAtLS0tLSBnZW5vbWVzIC0tLS0tLS0tLS0tLVxuICAgIGxldCBwZ2Vub21lcyA9IHBybXMuZ2V0KFwiZ2Vub21lc1wiKSB8fCBcIlwiO1xuICAgIC8vIEZvciBub3csIGFsbG93IFwiY29tcHNcIiBhcyBzeW5vbnltIGZvciBcImdlbm9tZXNcIi4gRXZlbnR1YWxseSwgZG9uJ3Qgc3VwcG9ydCBcImNvbXBzXCIuXG4gICAgcGdlbm9tZXMgPSAocGdlbm9tZXMgKyAgXCIgXCIgKyAocHJtcy5nZXQoXCJjb21wc1wiKSB8fCBcIlwiKSk7XG4gICAgLy9cbiAgICBwZ2Vub21lcyA9IHJlbW92ZUR1cHMocGdlbm9tZXMudHJpbSgpLnNwbGl0KC8gKy8pKTtcbiAgICBwZ2Vub21lcy5sZW5ndGggPiAwICYmIChjZmcuZ2Vub21lcyA9IHBnZW5vbWVzKTtcblxuICAgIC8vIC0tLS0tIHJlZiBnZW5vbWUgLS0tLS0tLS0tLS0tXG4gICAgbGV0IHJlZiA9IHBybXMuZ2V0KFwicmVmXCIpO1xuICAgIHJlZiAmJiAoY2ZnLnJlZiA9IHJlZik7XG5cbiAgICAvLyAtLS0tLSBoaWdobGlnaHQgSURzIC0tLS0tLS0tLS0tLS0tXG4gICAgbGV0IGhscyA9IG5ldyBTZXQoKTtcbiAgICBsZXQgaGxzMCA9IHBybXMuZ2V0KFwiaGlnaGxpZ2h0XCIpO1xuICAgIGlmIChobHMwKSB7XG5cdGhsczAgPSBobHMwLnJlcGxhY2UoL1sgLF0rL2csICcgJykuc3BsaXQoJyAnKS5maWx0ZXIoeD0+eCk7XG5cdGhsczAubGVuZ3RoID4gMCAmJiAoY2ZnLmhpZ2hsaWdodCA9IGhsczApO1xuICAgIH1cblxuICAgIC8vIC0tLS0tIGNvb3JkaW5hdGVzIC0tLS0tLS0tLS0tLS0tXG4gICAgLy9cbiAgICBsZXQgY2hyICAgPSBwcm1zLmdldChcImNoclwiKTtcbiAgICBsZXQgc3RhcnQgPSBwcm1zLmdldChcInN0YXJ0XCIpO1xuICAgIGxldCBlbmQgICA9IHBybXMuZ2V0KFwiZW5kXCIpO1xuICAgIGNociAgICYmIChjZmcuY2hyID0gY2hyKTtcbiAgICBzdGFydCAmJiAoY2ZnLnN0YXJ0ID0gcGFyc2VJbnQoc3RhcnQpKTtcbiAgICBlbmQgICAmJiAoY2ZnLmVuZCA9IHBhcnNlSW50KGVuZCkpO1xuICAgIC8vXG4gICAgbGV0IGxhbmRtYXJrID0gcHJtcy5nZXQoXCJsYW5kbWFya1wiKTtcbiAgICBsZXQgZmxhbmsgICAgPSBwcm1zLmdldChcImZsYW5rXCIpO1xuICAgIGxldCBsZW5ndGggICA9IHBybXMuZ2V0KFwibGVuZ3RoXCIpO1xuICAgIGxldCBkZWx0YSAgICA9IHBybXMuZ2V0KFwiZGVsdGFcIik7XG4gICAgbGFuZG1hcmsgJiYgKGNmZy5sYW5kbWFyayA9IGxhbmRtYXJrKTtcbiAgICBmbGFuayAgICAmJiAoY2ZnLmZsYW5rID0gcGFyc2VJbnQoZmxhbmspKTtcbiAgICBsZW5ndGggICAmJiAoY2ZnLmxlbmd0aCA9IHBhcnNlSW50KGxlbmd0aCkpO1xuICAgIGRlbHRhICAgICYmIChjZmcuZGVsdGEgPSBwYXJzZUludChkZWx0YSkpO1xuICAgIC8vXG4gICAgLy8gLS0tLS0gZHJhd2luZyBtb2RlIC0tLS0tLS0tLS0tLS1cbiAgICBsZXQgZG1vZGUgPSBwcm1zLmdldChcImRtb2RlXCIpO1xuICAgIGRtb2RlICYmIChjZmcuZG1vZGUgPSBkbW9kZSk7XG4gICAgLy9cbiAgICByZXR1cm4gY2ZnO1xufVxuXG5cbi8vIFRoZSBtYWluIHByb2dyYW0sIHdoZXJlaW4gdGhlIGFwcCBpcyBjcmVhdGVkIGFuZCB3aXJlZCB0byB0aGUgYnJvd3Nlci4gXG4vL1xuZnVuY3Rpb24gX19tYWluX18gKHNlbGVjdG9yKSB7XG4gICAgLy8gQmVob2xkLCB0aGUgTUdWIGFwcGxpY2F0aW9uIG9iamVjdC4uLlxuICAgIGxldCBtZ3YgPSBudWxsO1xuXG4gICAgLy8gQ2FsbGJhY2sgdG8gcGFzcyBpbnRvIHRoZSBhcHAgdG8gcmVnaXN0ZXIgY2hhbmdlcyBpbiBjb250ZXh0LlxuICAgIC8vIFVzZXMgdGhlIGN1cnJlbnQgYXBwIGNvbnRleHQgdG8gc2V0IHRoZSBoYXNoIHBhcnQgb2YgdGhlXG4gICAgLy8gYnJvd3NlcidzIGxvY2F0aW9uLiBUaGlzIGFsc28gcmVnaXN0ZXJzIHRoZSBjaGFuZ2UgaW4gXG4gICAgLy8gdGhlIGJyb3dzZXIgaGlzdG9yeS5cbiAgICBmdW5jdGlvbiBzZXRIYXNoICgpIHtcblx0bGV0IG5ld0hhc2ggPSBtZ3YuZ2V0UGFyYW1TdHJpbmcoKTtcblx0aWYgKCcjJytuZXdIYXNoID09PSB3aW5kb3cubG9jYXRpb24uaGFzaClcblx0ICAgIHJldHVybjtcblx0Ly8gdGVtcG9yYXJpbHkgZGlzYWJsZSBwb3BzdGF0ZSBoYW5kbGVyXG5cdGxldCBmID0gd2luZG93Lm9ucG9wc3RhdGU7XG5cdHdpbmRvdy5vbnBvcHN0YXRlID0gbnVsbDtcblx0Ly8gbm93IHNldCB0aGUgaGFzaFxuXHR3aW5kb3cubG9jYXRpb24uaGFzaCA9IG5ld0hhc2g7XG5cdC8vIHJlLWVuYWJsZVxuXHR3aW5kb3cub25wb3BzdGF0ZSA9IGY7XG4gICAgfVxuICAgIC8vIEhhbmRsZXIgY2FsbGVkIHdoZW4gdXNlciBjbGlja3MgdGhlIGJyb3dzZXIncyBiYWNrIG9yIGZvcndhcmQgYnV0dG9ucy5cbiAgICAvLyBTZXRzIHRoZSBhcHAncyBjb250ZXh0IGJhc2VkIG9uIHRoZSBoYXNoIHBhcnQgb2YgdGhlIGJyb3dzZXInc1xuICAgIC8vIGxvY2F0aW9uLlxuICAgIHdpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0bGV0IGNmZyA9IHBxc3RyaW5nKGRvY3VtZW50LmxvY2F0aW9uLmhhc2guc3Vic3RyaW5nKDEpKTtcblx0bWd2LnNldENvbnRleHQoY2ZnLCB0cnVlKTtcbiAgICB9O1xuICAgIC8vIGdldCBpbml0aWFsIHNldCBvZiBjb250ZXh0IHBhcmFtcyBcbiAgICBsZXQgcXN0cmluZyA9IHdpbmRvdy5sb2NhdGlvbi5oYXNoLnN1YnN0cmluZygxKTtcbiAgICBsZXQgY2ZnID0gcHFzdHJpbmcocXN0cmluZyk7XG4gICAgY2ZnLndpZHRoID0gd2luZG93LmlubmVyV2lkdGg7XG4gICAgY2ZnLm9uY29udGV4dGNoYW5nZSA9IHNldEhhc2g7XG5cbiAgICAvLyBjcmVhdGUgdGhlIGFwcFxuICAgIHdpbmRvdy5tZ3YgPSBtZ3YgPSBuZXcgTUdWQXBwKHNlbGVjdG9yLCBjZmcpO1xuICAgIFxuICAgIC8vIGhhbmRsZSByZXNpemUgZXZlbnRzXG4gICAgd2luZG93Lm9ucmVzaXplID0gKCkgPT4ge21ndi5yZXNpemUoKTttZ3Yuc2V0Q29udGV4dCh7fSk7fVxufVxuXG5cbl9fbWFpbl9fKFwiI21ndlwiKTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL3ZpZXdlci5qc1xuLy8gbW9kdWxlIGlkID0gN1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgQ09ORklHICAgICAgICAgICAgICBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBwYXJzZUNvb3JkcywgZm9ybWF0Q29vcmRzLCBkM3RzdiwgZDNqc29uLCBpbml0T3B0TGlzdCwgc2FtZSwgY2xpcCB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgR2Vub21lIH0gICAgICAgICAgZnJvbSAnLi9HZW5vbWUnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gICAgICAgZnJvbSAnLi9Db21wb25lbnQnO1xuaW1wb3J0IHsgRmVhdHVyZU1hbmFnZXIgfSAgZnJvbSAnLi9GZWF0dXJlTWFuYWdlcic7XG5pbXBvcnQgeyBRdWVyeU1hbmFnZXIgfSAgICBmcm9tICcuL1F1ZXJ5TWFuYWdlcic7XG5pbXBvcnQgeyBMaXN0TWFuYWdlciB9ICAgICBmcm9tICcuL0xpc3RNYW5hZ2VyJztcbmltcG9ydCB7IExpc3RFZGl0b3IgfSAgICAgIGZyb20gJy4vTGlzdEVkaXRvcic7XG5pbXBvcnQgeyBGYWNldE1hbmFnZXIgfSAgICBmcm9tICcuL0ZhY2V0TWFuYWdlcic7XG5pbXBvcnQgeyBCVE1hbmFnZXIgfSAgICAgICBmcm9tICcuL0JUTWFuYWdlcic7XG5pbXBvcnQgeyBHZW5vbWVWaWV3IH0gICAgICBmcm9tICcuL0dlbm9tZVZpZXcnO1xuaW1wb3J0IHsgRmVhdHVyZURldGFpbHMgfSAgZnJvbSAnLi9GZWF0dXJlRGV0YWlscyc7XG5pbXBvcnQgeyBab29tVmlldyB9ICAgICAgICBmcm9tICcuL1pvb21WaWV3JztcbmltcG9ydCB7IEtleVN0b3JlIH0gICAgICAgIGZyb20gJy4vS2V5U3RvcmUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbmNsYXNzIE1HVkFwcCBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IgKHNlbGVjdG9yLCBjZmcpIHtcblx0c3VwZXIobnVsbCwgc2VsZWN0b3IpO1xuXHR0aGlzLmdsb2JhbENvbmZpZyA9IENPTkZJRztcblx0Y29uc29sZS5sb2coQ09ORklHKTtcblx0dGhpcy5hcHAgPSB0aGlzO1xuXHR0aGlzLm5hbWUgPSBDT05GSUcuTUdWQXBwLm5hbWU7XG5cdHRoaXMudmVyc2lvbiA9IENPTkZJRy5NR1ZBcHAudmVyc2lvbjtcblx0Ly9cblx0dGhpcy5pbml0aWFsQ2ZnID0gY2ZnO1xuXHQvL1xuXHR0aGlzLmNvbnRleHRDaGFuZ2VkID0gKGNmZy5vbmNvbnRleHRjaGFuZ2UgfHwgZnVuY3Rpb24oKXt9KTtcblx0Ly9cblx0dGhpcy5uYW1lMmdlbm9tZSA9IHt9OyAgLy8gbWFwIGZyb20gZ2Vub21lIG5hbWUgLT4gZ2Vub21lIGRhdGEgb2JqXG5cdHRoaXMubGFiZWwyZ2Vub21lID0ge307IC8vIG1hcCBmcm9tIGdlbm9tZSBsYWJlbCAtPiBnZW5vbWUgZGF0YSBvYmpcblx0dGhpcy5ubDJnZW5vbWUgPSB7fTsgICAgLy8gY29tYmluZXMgaW5kZXhlc1xuXHQvL1xuXHR0aGlzLmFsbEdlbm9tZXMgPSBbXTsgICAvLyBsaXN0IG9mIGFsbCBhdmFpbGFibGUgZ2Vub21lc1xuXHR0aGlzLnJHZW5vbWUgPSBudWxsOyAgICAvLyB0aGUgY3VycmVudCByZWZlcmVuY2UgZ2Vub21lXG5cdHRoaXMuY0dlbm9tZXMgPSBbXTsgICAgIC8vIGN1cnJlbnQgY29tcGFyaXNvbiBnZW5vbWVzIChyR2Vub21lIGlzICpub3QqIGluY2x1ZGVkKS5cblx0dGhpcy52R2Vub21lcyA9IFtdO1x0Ly8gbGlzdCBvZiBhbGwgY3VycmVudHkgdmlld2VkIGdlbm9tZXMgKHJlZitjb21wcykgaW4gWS1vcmRlci5cblx0Ly9cblx0dGhpcy5kdXIgPSAyNTA7ICAgICAgICAgLy8gYW5pbWF0aW9uIGR1cmF0aW9uLCBpbiBtc1xuXHR0aGlzLmRlZmF1bHRab29tID0gMjtcdC8vIG11bHRpcGxpZXIgb2YgY3VycmVudCByYW5nZSB3aWR0aC4gTXVzdCBiZSA+PSAxLiAxID09IG5vIHpvb20uXG5cdFx0XHRcdC8vICh6b29taW5nIGluIHVzZXMgMS90aGlzIGFtb3VudClcblx0dGhpcy5kZWZhdWx0UGFuICA9IDAuMTU7Ly8gZnJhY3Rpb24gb2YgY3VycmVudCByYW5nZSB3aWR0aFxuXHR0aGlzLmN1cnJMaXN0SW5kZXggPSB7fTtcblx0dGhpcy5jdXJyTGlzdENvdW50ZXIgPSAwO1xuXG5cblx0Ly8gQ29vcmRpbmF0ZXMgbWF5IGJlIHNwZWNpZmllZCBpbiBvbmUgb2YgdHdvIHdheXM6IG1hcHBlZCBvciBsYW5kbWFyay4gXG5cdC8vIE1hcHBlZCBjb29yZGluYXRlcyBhcmUgc3BlY2lmaWVkIGFzIGNocm9tb3NvbWUrc3RhcnQrZW5kLiBUaGlzIGNvb3JkaW5hdGUgcmFuZ2UgaXMgZGVmaW5lZCByZWxhdGl2ZSB0byBcblx0Ly8gdGhlIGN1cnJlbnQgcmVmZXJlbmNlIGdlbm9tZSwgYW5kIGlzIG1hcHBlZCB0byB0aGUgY29ycmVzcG9uZGluZyByYW5nZShzKSBpbiBlYWNoIGNvbXBhcmlzb24gZ2Vub21lLlxuXHQvLyBMYW5kbWFyayBjb29yZGluYXRlcyBhcmUgc3BlY2lmaWVkIGFzIGxhbmRtYXJrK1tmbGFua3x3aWR0aF0rZGVsdGEuIFRoZSBsYW5kbWFyayBpcyBsb29rZWQgdXAgaW4gZWFjaCBcblx0Ly8gZ2Vub21lLiBJdHMgY29vcmRpbmF0ZXMsIGNvbWJpbmVkIHdpdGggZmxhbmt8bGVuZ3RoIGFuZCBkZWx0YSwgZGV0ZXJtaW5lIHRoZSBhYnNvbHV0ZSBjb29yZGluYXRlIHJhbmdlXG5cdC8vIGluIHRoYXQgZ2Vub21lLiBJZiB0aGUgbGFuZG1hcmsgZG9lcyBub3QgZXhpc3QgaW4gYSBnaXZlbiBnZW5vbWUsIHRoZW4gbWFwcGVkIGNvb3JkaW5hdGUgYXJlIHVzZWQuXG5cdC8vIFxuXHR0aGlzLmNtb2RlID0gJ21hcHBlZCcgLy8gJ21hcHBlZCcgb3IgJ2xhbmRtYXJrJ1xuXHR0aGlzLmNvb3JkcyA9IHsgY2hyOiAnMScsIHN0YXJ0OiAxMDAwMDAwLCBlbmQ6IDEwMDAwMDAwIH07ICAvLyBtYXBwZWRcblx0dGhpcy5sY29vcmRzID0geyBsYW5kbWFyazogJ1BheDYnLCBmbGFuazogNTAwMDAwLCBkZWx0YTowIH07Ly8gbGFuZG1hcmtcblxuXHR0aGlzLmluaXREb20oKTtcblxuXHQvL1xuXHQvL1xuXHR0aGlzLmdlbm9tZVZpZXcgPSBuZXcgR2Vub21lVmlldyh0aGlzLCAnI2dlbm9tZVZpZXcnLCA4MDAsIDI1MCk7XG5cdHRoaXMuem9vbVZpZXcgICA9IG5ldyBab29tVmlldyAgKHRoaXMsICcjem9vbVZpZXcnLCA4MDAsIDI1MCwgdGhpcy5jb29yZHMpO1xuXHR0aGlzLnJlc2l6ZSgpO1xuICAgICAgICAvL1xuXHR0aGlzLmZlYXR1cmVEZXRhaWxzID0gbmV3IEZlYXR1cmVEZXRhaWxzKHRoaXMsICcjZmVhdHVyZURldGFpbHMnKTtcblxuXHQvLyBDYXRlZ29yaWNhbCBjb2xvciBzY2FsZSBmb3IgZmVhdHVyZSB0eXBlc1xuXHR0aGlzLmNzY2FsZSA9IGQzLnNjYWxlLmNhdGVnb3J5MTAoKS5kb21haW4oW1xuXHQgICAgJ3Byb3RlaW5fY29kaW5nX2dlbmUnLFxuXHQgICAgJ3BzZXVkb2dlbmUnLFxuXHQgICAgJ25jUk5BX2dlbmUnLFxuXHQgICAgJ2dlbmVfc2VnbWVudCcsXG5cdCAgICAnb3RoZXJfZ2VuZScsXG5cdCAgICAnb3RoZXJfZmVhdHVyZV90eXBlJ1xuXHRdKTtcblx0Ly9cblx0Ly9cblx0dGhpcy5saXN0TWFuYWdlciAgICA9IG5ldyBMaXN0TWFuYWdlcih0aGlzLCBcIiNteWxpc3RzXCIpO1xuXHR0aGlzLmxpc3RNYW5hZ2VyLnJlYWR5LnRoZW4oICgpID0+IHRoaXMubGlzdE1hbmFnZXIudXBkYXRlKCkgKTtcblx0Ly9cblx0dGhpcy5saXN0RWRpdG9yID0gbmV3IExpc3RFZGl0b3IodGhpcywgJyNsaXN0ZWRpdG9yJyk7XG5cdC8vXG5cdHRoaXMucXVlcnlNYW5hZ2VyID0gbmV3IFF1ZXJ5TWFuYWdlcih0aGlzLCBcIiNmaW5kR2VuZXNCb3hcIik7XG5cdC8vIFxuXHR0aGlzLnRyYW5zbGF0b3IgICAgID0gbmV3IEJUTWFuYWdlcih0aGlzKTtcblx0dGhpcy5mZWF0dXJlTWFuYWdlciA9IG5ldyBGZWF0dXJlTWFuYWdlcih0aGlzKTtcblx0Ly9cblx0dGhpcy51c2VyUHJlZnNTdG9yZSA9IG5ldyBLZXlTdG9yZShcInVzZXItcHJlZmVyZW5jZXNcIik7XG5cdFxuXHQvL1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIEZhY2V0c1xuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vXG5cdHRoaXMuZmFjZXRNYW5hZ2VyID0gbmV3IEZhY2V0TWFuYWdlcih0aGlzKTtcblx0bGV0IHNlbGYgPSB0aGlzO1xuXG5cdC8vIEZlYXR1cmUtdHlwZSBmYWNldFxuXHRsZXQgZnRGYWNldCAgPSB0aGlzLmZhY2V0TWFuYWdlci5hZGRGYWNldChcIkZlYXR1cmVUeXBlXCIsIGYgPT4gZi5nZXRNdW5nZWRUeXBlKCkpO1xuXHR0aGlzLmluaXRGZWF0VHlwZUNvbnRyb2woZnRGYWNldCk7XG5cblx0Ly8gSGFzLU1HSS1pZCBmYWNldFxuXHRsZXQgbWdpRmFjZXQgPSB0aGlzLmZhY2V0TWFuYWdlci5hZGRGYWNldChcIkhhc0Nhbm9uaWNhbElkXCIsICAgIGYgPT4gZi5jYW5vbmljYWwgID8gXCJ5ZXNcIiA6IFwibm9cIiApO1xuXHRkMy5zZWxlY3RBbGwoJ2lucHV0W25hbWU9XCJtZ2lGYWNldFwiXScpLm9uKFwiY2hhbmdlXCIsIGZ1bmN0aW9uKCl7XG5cdCAgICBtZ2lGYWNldC5zZXRWYWx1ZXModGhpcy52YWx1ZSA9PT0gXCJcIiA/IFtdIDogW3RoaXMudmFsdWVdKTtcblx0ICAgIHNlbGYuem9vbVZpZXcuaGlnaGxpZ2h0KCk7XG5cdH0pO1xuXG5cdC8vIElzLWluLWN1cnJlbnQtbGlzdCBmYWNldFxuXHRsZXQgaW5DdXJyTGlzdEZhY2V0ID0gdGhpcy5mYWNldE1hbmFnZXIuYWRkRmFjZXQoXCJJbkN1cnJMaXN0XCIsIGYgPT4ge1xuXHQgICAgcmV0dXJuIHRoaXMuY3Vyckxpc3RJbmRleFtmLmlkXSA/IFwieWVzXCIgOiBcIm5vXCI7XG5cdH0pO1xuXHRkMy5zZWxlY3RBbGwoJ2lucHV0W25hbWU9XCJpbkN1cnJMaXN0RmFjZXRcIl0nKS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbigpe1xuXHQgICAgaW5DdXJyTGlzdEZhY2V0LnNldFZhbHVlcyh0aGlzLnZhbHVlID09PSBcIlwiID8gW10gOiBbdGhpcy52YWx1ZV0pO1xuXHQgICAgc2VsZi56b29tVmlldy5oaWdobGlnaHQoKTtcblx0fSk7XG5cblx0Ly8gSXMtaGlnaGxpZ2h0ZWQgZmFjZXRcblx0bGV0IGhpRmFjZXQgPSB0aGlzLmZhY2V0TWFuYWdlci5hZGRGYWNldChcIklzSGlcIiwgZiA9PiB7XG5cdCAgICBsZXQgaXNoaSA9IHRoaXMuem9vbVZpZXcuaGlGZWF0c1tmLmlkXSB8fCB0aGlzLmN1cnJMaXN0SW5kZXhbZi5pZF07XG5cdCAgICByZXR1cm4gaXNoaSA/IFwieWVzXCIgOiBcIm5vXCI7XG5cdH0pO1xuXHRkMy5zZWxlY3RBbGwoJ2lucHV0W25hbWU9XCJoaUZhY2V0XCJdJykub24oXCJjaGFuZ2VcIiwgZnVuY3Rpb24oKXtcblx0ICAgIGhpRmFjZXQuc2V0VmFsdWVzKHRoaXMudmFsdWUgPT09IFwiXCIgPyBbXSA6IFt0aGlzLnZhbHVlXSk7XG5cdCAgICBzZWxmLnpvb21WaWV3LmhpZ2hsaWdodCgpO1xuXHR9KTtcblxuXG5cdC8vXG5cdHRoaXMuc2V0VUlGcm9tUHJlZnMoKTtcblxuXHQvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cblx0Ly8gVGhpbmdzIGFyZSBhbGwgd2lyZWQgdXAuIE5vdyBsZXQncyBnZXQgc29tZSBkYXRhLlxuXHQvLyBTdGFydCB3aXRoIHRoZSBmaWxlIG9mIGFsbCB0aGUgZ2Vub21lcy5cblx0dGhpcy5jaGVja1RpbWVzdGFtcCgpLnRoZW4oICgpID0+IHtcblx0ICAgIGQzdHN2KFwiLi9kYXRhL2FsbEdlbm9tZXMudHN2XCIpLnRoZW4oZGF0YSA9PiB7XG5cdFx0Ly8gY3JlYXRlIEdlbm9tZSBvYmplY3RzIGZyb20gdGhlIHJhdyBkYXRhLlxuXHRcdHRoaXMuYWxsR2Vub21lcyAgID0gZGF0YS5tYXAoZyA9PiBuZXcgR2Vub21lKGcpKTtcblx0XHR0aGlzLmFsbEdlbm9tZXMuc29ydCggKGEsYikgPT4ge1xuXHRcdCAgICByZXR1cm4gYS5sYWJlbCA8IGIubGFiZWwgPyAtMSA6IGEubGFiZWwgPiBiLmxhYmVsID8gKzEgOiAwO1xuXHRcdH0pO1xuXHRcdC8vXG5cdFx0Ly8gYnVpbGQgYSBuYW1lLT5HZW5vbWUgaW5kZXhcblx0XHR0aGlzLm5sMmdlbm9tZSA9IHt9OyAvLyBhbHNvIGJ1aWxkIHRoZSBjb21iaW5lZCBsaXN0IGF0IHRoZSBzYW1lIHRpbWUuLi5cblx0XHR0aGlzLm5hbWUyZ2Vub21lICA9IHRoaXMuYWxsR2Vub21lc1xuXHRcdCAgICAucmVkdWNlKChhY2MsZykgPT4geyB0aGlzLm5sMmdlbm9tZVtnLm5hbWVdID0gYWNjW2cubmFtZV0gPSBnOyByZXR1cm4gYWNjOyB9LCB7fSk7XG5cdFx0Ly8gYnVpbGQgYSBsYWJlbC0+R2Vub21lIGluZGV4XG5cdFx0dGhpcy5sYWJlbDJnZW5vbWUgPSB0aGlzLmFsbEdlbm9tZXNcblx0XHQgICAgLnJlZHVjZSgoYWNjLGcpID0+IHsgdGhpcy5ubDJnZW5vbWVbZy5sYWJlbF0gPSBhY2NbZy5sYWJlbF0gPSBnOyByZXR1cm4gYWNjOyB9LCB7fSk7XG5cblx0XHQvLyBOb3cgcHJlbG9hZCBhbGwgdGhlIGNocm9tb3NvbWUgZmlsZXMgZm9yIGFsbCB0aGUgZ2Vub21lc1xuXHRcdGxldCBjZHBzID0gdGhpcy5hbGxHZW5vbWVzLm1hcChnID0+IGQzdHN2KGAuL2RhdGEvJHtnLm5hbWV9L2Nocm9tb3NvbWVzLnRzdmApKTtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwoY2Rwcyk7XG5cdCAgICB9KVxuXHQgICAgLnRoZW4oIGRhdGEgPT4ge1xuXG5cdFx0Ly9cblx0XHR0aGlzLnByb2Nlc3NDaHJvbW9zb21lcyhkYXRhKTtcblx0XHR0aGlzLmluaXREb21QYXJ0MigpO1xuXHRcdC8vXG5cdFx0Ly8gRklOQUxMWSEgV2UgYXJlIHJlYWR5IHRvIGRyYXcgdGhlIGluaXRpYWwgc2NlbmUuXG5cdFx0dGhpcy5zZXRDb250ZXh0KHRoaXMuaW5pdGlhbENmZyk7XG5cblx0ICAgIH0pO1xuXHR9KTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2hlY2tUaW1lc3RhbXAgKCkge1xuICAgICAgICBsZXQgdFN0b3JlID0gbmV3IEtleVN0b3JlKCd0aW1lc3RhbXAnKTtcblx0cmV0dXJuIGQzdHN2KCcuL2RhdGEvVElNRVNUQU1QLnRzdicpLnRoZW4oIHRzID0+IHtcblx0ICAgIGxldCBuZXdUaW1lU3RhbXAgPSAgbmV3IERhdGUoRGF0ZS5wYXJzZSh0c1swXS5USU1FU1RBTVApKTtcblx0ICAgIHJldHVybiB0U3RvcmUuZ2V0KCdUSU1FU1RBTVAnKS50aGVuKCBvbGRUaW1lU3RhbXAgPT4ge1xuXHQgICAgICAgIGlmICghb2xkVGltZVN0YW1wIHx8IG5ld1RpbWVTdGFtcCA+IG9sZFRpbWVTdGFtcCkge1xuXHRcdCAgICB0U3RvcmUucHV0KCdUSU1FU1RBTVAnLG5ld1RpbWVTdGFtcCk7XG5cdFx0ICAgIHJldHVybiB0aGlzLmNsZWFyQ2FjaGVkRGF0YSgpO1xuXHRcdH1cblx0ICAgIH0pXG5cdH0pO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBcbiAgICBpbml0RG9tICgpIHtcblx0c2VsZiA9IHRoaXM7XG5cdHRoaXMucm9vdCA9IGQzLnNlbGVjdCgnI21ndicpO1xuXHRcblx0ZDMuc2VsZWN0KCcjaGVhZGVyIGxhYmVsJylcblx0ICAgIC50ZXh0KHRoaXMubmFtZSlcblx0ICAgIDtcblx0ZDMuc2VsZWN0KCcjdmVyc2lvbicpXG5cdCAgICAudGV4dCgndmVyc2lvbiAnICsgdGhpcy52ZXJzaW9uKVxuXHQgICAgO1xuXHQvL1xuXHQvLyBUT0RPOiByZWZhY3RvciBwYWdlYm94LCBkcmFnZ2FibGUsIGFuZCBmcmllbmRzIGludG8gYSBmcmFtZXdvcmsgbW9kdWxlLFxuXHQvLyBcblx0dGhpcy5wYkRyYWdnZXIgPSB0aGlzLmdldENvbnRlbnREcmFnZ2VyKCk7XG5cdC8vIEFkZCBidXN5IGljb24sIGN1cnJlbnRseSBpbnZpc2liZS5cblx0ZDMuc2VsZWN0QWxsKCcucGFnZWJveCcpXG5cdCAgICAuYXBwZW5kKCdpJylcblx0XHQuYXR0cignY2xhc3MnLCdtYXRlcmlhbC1pY29ucyBidXN5IHJvdGF0aW5nJylcblx0ICAgIDtcblx0Ly9cblx0Ly8gSWYgYSBwYWdlYm94IGhhcyB0aXRsZSB0ZXh0LCBhcHBlbmQgYSBoZWxwIGljb24gdG8gdGhlIGxhYmVsIGFuZCBtb3ZlIHRoZSB0ZXh0IHRoZXJlXG5cdGQzLnNlbGVjdEFsbCgnLnBhZ2Vib3hbdGl0bGVdJylcblx0ICAgIC5hcHBlbmQoJ2knKVxuXHQgICAgICAgIC5hdHRyKCdjbGFzcycsICdtYXRlcmlhbC1pY29ucyBidXR0b24gaGVscCcpXG5cdCAgICAgICAgLmF0dHIoJ3RpdGxlJywgZnVuY3Rpb24oKXtcblx0XHQgICAgbGV0IHAgPSBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKTtcblx0XHQgICAgbGV0IHQgPSBwLmF0dHIoJ3RpdGxlJyk7XG5cdFx0ICAgIHAuYXR0cigndGl0bGUnLCBudWxsKTtcblx0XHQgICAgcmV0dXJuIHQ7XG5cdFx0fSlcblx0XHQub24oJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG5cdFx0ICAgIHNlbGYuc2hvd1N0YXR1cyhkMy5zZWxlY3QodGhpcykuYXR0cigndGl0bGUnKSwgZDMuZXZlbnQuY2xpZW50WCwgZDMuZXZlbnQuY2xpZW50WSk7XG5cdFx0fSlcblx0XHQ7XG5cdC8vIFxuXHQvLyBBZGQgb3Blbi9jbG9zZSBidXR0b24gdG8gY2xvc2FibGVzIGFuZCB3aXJlIHRoZW0gdXAuXG5cdGQzLnNlbGVjdEFsbCgnLmNsb3NhYmxlJylcblx0ICAgIC5hcHBlbmQoJ2knKVxuXHRcdC5hdHRyKCdjbGFzcycsJ21hdGVyaWFsLWljb25zIGJ1dHRvbiBjbG9zZScpXG5cdFx0LmF0dHIoJ3RpdGxlJywnQ2xpY2sgdG8gb3Blbi9jbG9zZS4nKVxuXHRcdC5vbignY2xpY2suZGVmYXVsdCcsIGZ1bmN0aW9uICgpIHtcblx0XHQgICAgbGV0IHAgPSBkMy5zZWxlY3QodGhpcy5wYXJlbnROb2RlKTtcblx0XHQgICAgcC5jbGFzc2VkKCdjbG9zZWQnLCAhIHAuY2xhc3NlZCgnY2xvc2VkJykpO1xuXHRcdCAgICBkMy5zZWxlY3QodGhpcykuYXR0cigndGl0bGUnLCdDbGljayB0byAnICsgIChwLmNsYXNzZWQoJ2Nsb3NlZCcpID8gJ29wZW4nIDogJ2Nsb3NlJykgKyAnLicpXG5cdFx0ICAgIHNlbGYuc2V0UHJlZnNGcm9tVUkoKTtcblx0XHR9KTtcblx0Ly9cblx0Ly8gU2V0IHVwIGRyYWdnYWJsZXMuXG5cdGQzLnNlbGVjdEFsbCgnLmNvbnRlbnQtZHJhZ2dhYmxlID4gKicpXG5cdCAgICAuYXBwZW5kKCdpJylcblx0XHQuYXR0cigndGl0bGUnLCdEcmFnIHVwL2Rvd24gdG8gcmVwb3NpdGlvbi4nKVxuXHRcdC5hdHRyKCdjbGFzcycsJ21hdGVyaWFsLWljb25zIGJ1dHRvbiBkcmFnaGFuZGxlJylcblx0XHQub24oJ21vdXNlZW50ZXInLCBmdW5jdGlvbigpe1xuXHRcdCAgICAvLyBBdHRhY2ggdGhlIGRyYWcgYmVoYXZpb3Igd2hlbiB0aGUgdXNlciBtb3VzZXMgb3ZlciB0aGUgZHJhZyBoYW5kbGUsIGFuZCByZW1vdmUgdGhlIGJlaGF2aW9yXG5cdFx0ICAgIC8vIHdoZW4gdXNlciBtb3VzZXMgb3V0LiBXaHkgZG8gaXQgdGhpcyB3YXk/IEJlY2F1c2UgaWYgdGhlIGRyYWcgYmVoYXZpb3Igc3RheXMgb24gYWxsIHRoZSB0aW1lLFxuXHRcdCAgICAvLyB0aGUgdXNlciBjYW5ub3Qgc2VsZWN0IGFueSB0ZXh0IHdpdGhpbiB0aGUgYm94LlxuXHRcdCAgICBsZXQgcGIgPSB0aGlzLmNsb3Nlc3QoJy5wYWdlYm94Jyk7XG5cdFx0ICAgIGlmICghcGIpIHJldHVybjtcblx0XHQgICAgZDMuc2VsZWN0KHBiKS5jYWxsKHNlbGYucGJEcmFnZ2VyKTtcblx0XHR9KVxuXHRcdC5vbignbW91c2VsZWF2ZScsIGZ1bmN0aW9uKCl7XG5cdFx0ICAgIGxldCBwYiA9IHRoaXMuY2xvc2VzdCgnLnBhZ2Vib3gnKTtcblx0XHQgICAgaWYgKCFwYikgcmV0dXJuO1xuXHRcdCAgICBkMy5zZWxlY3QocGIpLm9uKCcuZHJhZycsbnVsbCk7XG5cdFx0fSk7XG5cblx0Ly8gXG4gICAgICAgIGQzLnNlbGVjdCgnI3N0YXR1c01lc3NhZ2UnKVxuXHQgICAgLm9uKCdjbGljaycsICgpID0+IHsgdGhpcy5zaG93U3RhdHVzKGZhbHNlKTsgfSk7XG5cdFxuXHQvL1xuXHQvLyBCdXR0b246IEdlYXIgaWNvbiB0byBzaG93L2hpZGUgbGVmdCBjb2x1bW5cblx0ZDMuc2VsZWN0KFwiI2hlYWRlciA+IC5nZWFyLmJ1dHRvblwiKVxuXHQgICAgLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xuXHQgICAgICAgIGxldCBsYyA9IHRoaXMucm9vdC5zZWxlY3QoJ1tuYW1lPVwibGVmdGNvbHVtblwiXScpO1xuXHRcdGxjLmNsYXNzZWQoXCJjbG9zZWRcIiwgKCkgPT4gISBsYy5jbGFzc2VkKFwiY2xvc2VkXCIpKTtcblx0XHR3aW5kb3cuc2V0VGltZW91dCgoKT0+e1xuXHRcdCAgICB0aGlzLnJlc2l6ZSgpXG5cdFx0ICAgIHRoaXMuc2V0Q29udGV4dCh7fSk7XG5cdFx0ICAgIHRoaXMuc2V0UHJlZnNGcm9tVUkoKTtcblx0XHR9LCAyNTApO1xuXHQgICAgfSk7XG5cdC8qXG5cdC8vIERpc3BsYXkgU2V0dGluZ3MgQ29udHJvbHNcblx0ZDMuc2VsZWN0QWxsKCcjc2V0dGluZ3MgLnNldHRpbmcgaW5wdXQnKVxuXHQgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBsZXQgdiA9IHBhcnNlSW50KHRoaXMudmFsdWUpO1xuXHRcdGxldCBuID0gdGhpcy5hdHRyaWJ1dGVzWyduYW1lJ10udmFsdWU7XG5cdFx0c2VsZi56b29tVmlld1tuXSA9IHY7XG5cdCAgICB9KTtcblx0Ki9cbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRG9tIGluaXRpYWxpenRpb24gdGhhdCBtdXN0IHdhaXQgdW50aWwgYWZ0ZXIgZ2Vub21lIG1ldGEgZGF0YSBpcyBsb2FkZWQuXG4gICAgaW5pdERvbVBhcnQyICgpIHtcblx0Ly9cblx0bGV0IGNmZyA9IHRoaXMuc2FuaXRpemVDZmcodGhpcy5pbml0aWFsQ2ZnKTtcblx0bGV0IHNlbGYgPSB0aGlzO1xuXG5cdC8vIGluaXRpYWxpemUgdGhlIHJlZiBhbmQgY29tcCBnZW5vbWUgb3B0aW9uIGxpc3RzXG5cdGluaXRPcHRMaXN0KFwiI3JlZkdlbm9tZVwiLCAgIHRoaXMuYWxsR2Vub21lcywgZz0+Zy5uYW1lLCBnPT5nLmxhYmVsLCBmYWxzZSwgZyA9PiBnID09PSBjZmcucmVmKTtcblx0aW5pdE9wdExpc3QoXCIjY29tcEdlbm9tZXNcIiwgdGhpcy5hbGxHZW5vbWVzLCBnPT5nLm5hbWUsIGc9PmcubGFiZWwsIHRydWUsICBnID0+IGNmZy5nZW5vbWVzLmluZGV4T2YoZykgIT09IC0xKTtcblx0ZDMuc2VsZWN0KFwiI3JlZkdlbm9tZVwiKS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbigpIHtcblx0ICAgIHNlbGYuc2V0Q29udGV4dCh7IHJlZjogdGhpcy52YWx1ZSB9KTtcblx0fSk7XG5cdGQzLnNlbGVjdChcIiNjb21wR2Vub21lc1wiKS5vbihcImNoYW5nZVwiLCBmdW5jdGlvbigpIHtcblx0ICAgIGxldCBzZWxlY3RlZE5hbWVzID0gW107XG5cdCAgICBmb3IobGV0IHggb2YgdGhpcy5zZWxlY3RlZE9wdGlvbnMpe1xuXHRcdHNlbGVjdGVkTmFtZXMucHVzaCh4LnZhbHVlKTtcblx0ICAgIH1cblx0ICAgIC8vIHdhbnQgdG8gcHJlc2VydmUgY3VycmVudCBnZW5vbWUgb3JkZXIgYXMgbXVjaCBhcyBwb3NzaWJsZSBcblx0ICAgIGxldCBnTmFtZXMgPSBzZWxmLnZHZW5vbWVzLm1hcChnPT5nLm5hbWUpXG5cdFx0LmZpbHRlcihuID0+IHtcblx0XHQgICAgcmV0dXJuIHNlbGVjdGVkTmFtZXMuaW5kZXhPZihuKSA+PSAwIHx8IG4gPT09IHNlbGYuckdlbm9tZS5uYW1lO1xuXHRcdH0pO1xuXHQgICAgZ05hbWVzID0gZ05hbWVzLmNvbmNhdChzZWxlY3RlZE5hbWVzLmZpbHRlcihuID0+IGdOYW1lcy5pbmRleE9mKG4pID09PSAtMSkpO1xuXHQgICAgc2VsZi5zZXRDb250ZXh0KHsgZ2Vub21lczogZ05hbWVzIH0pO1xuXHR9KTtcblx0ZDN0c3YoXCIuL2RhdGEvZ2Vub21lU2V0cy50c3ZcIikudGhlbihzZXRzID0+IHtcblx0ICAgIC8vIENyZWF0ZSBzZWxlY3Rpb24gYnV0dG9ucy5cblx0ICAgIHNldHMuZm9yRWFjaCggcyA9PiBzLmdlbm9tZXMgPSBzLmdlbm9tZXMuc3BsaXQoXCIsXCIpICk7XG5cdCAgICBsZXQgY2diID0gZDMuc2VsZWN0KCcjY29tcEdlbm9tZXNCb3gnKS5zZWxlY3RBbGwoJ2J1dHRvbicpLmRhdGEoc2V0cyk7XG5cdCAgICBjZ2IuZW50ZXIoKS5hcHBlbmQoJ2J1dHRvbicpXG5cdFx0LnRleHQoZD0+ZC5uYW1lKVxuXHRcdC5hdHRyKCd0aXRsZScsIGQ9PmQuZGVzY3JpcHRpb24pXG5cdFx0Lm9uKCdjbGljaycsIGQgPT4ge1xuXHRcdCAgICBzZWxmLnNldENvbnRleHQoZCk7XG5cdFx0fSlcblx0XHQ7XG5cdH0pLmNhdGNoKCgpPT57XG5cdCAgICBjb25zb2xlLmxvZyhcIk5vIGdlbm9tZVNldHMgZmlsZSBmb3VuZC5cIik7XG5cdH0pOyAvLyBPSyBpZiBubyBnZW5vbWVTZXRzIGZpbGVcblxuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwcm9jZXNzQ2hyb21vc29tZXMgKGRhdGEpIHtcblx0Ly8gZGF0YSBpcyBhIGxpc3Qgb2YgY2hyb21vc29tZSBsaXN0cywgb25lIHBlciBnZW5vbWVcblx0Ly8gRmlsbCBpbiB0aGUgZ2Vub21lQ2hycyBtYXAgKGdlbm9tZSAtPiBjaHIgbGlzdClcblx0dGhpcy5hbGxHZW5vbWVzLmZvckVhY2goKGcsaSkgPT4ge1xuXHQgICAgLy8gbmljZWx5IHNvcnQgdGhlIGNocm9tb3NvbWVzXG5cdCAgICBsZXQgY2hycyA9IGRhdGFbaV07XG5cdCAgICBnLm1heGxlbiA9IDA7XG5cdCAgICBjaHJzLmZvckVhY2goIGMgPT4ge1xuXHRcdC8vXG5cdFx0Yy5sZW5ndGggPSBwYXJzZUludChjLmxlbmd0aClcblx0XHRnLm1heGxlbiA9IE1hdGgubWF4KGcubWF4bGVuLCBjLmxlbmd0aCk7XG5cdFx0Ly8gYmVjYXVzZSBJJ2QgcmF0aGVyIHNheSBcImNocm9tb3NvbWUubmFtZVwiIHRoYW4gXCJjaHJvbW9zb21lLmNocm9tb3NvbWVcIlxuXHRcdGMubmFtZSA9IGMuY2hyb21vc29tZTtcblx0XHRkZWxldGUgYy5jaHJvbW9zb21lO1xuXHQgICAgfSk7XG5cdCAgICAvLyBuaWNlbHkgc29ydCB0aGUgY2hyb21vc29tZXNcblx0ICAgIGNocnMuc29ydCgoYSxiKSA9PiB7XG5cdFx0bGV0IGFhID0gcGFyc2VJbnQoYS5uYW1lKSAtIHBhcnNlSW50KGIubmFtZSk7XG5cdFx0aWYgKCFpc05hTihhYSkpIHJldHVybiBhYTtcblx0XHRyZXR1cm4gYS5uYW1lIDwgYi5uYW1lID8gLTEgOiBhLm5hbWUgPiBiLm5hbWUgPyArMSA6IDA7XG5cdCAgICB9KTtcblx0ICAgIGcuY2hyb21vc29tZXMgPSBjaHJzO1xuXHR9KTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0Q29udGVudERyYWdnZXIgKCkge1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgLy8gSGVscGVyIGZ1bmN0aW9uIGZvciB0aGUgZHJhZyBiZWhhdmlvci4gUmVvcmRlcnMgdGhlIGNvbnRlbnRzIGJhc2VkIG9uXG4gICAgICAvLyBjdXJyZW50IHNjcmVlbiBwb3NpdGlvbiBvZiB0aGUgZHJhZ2dlZCBpdGVtLlxuICAgICAgZnVuY3Rpb24gcmVvcmRlckJ5RG9tKCkge1xuXHQgIC8vIExvY2F0ZSB0aGUgc2liIHdob3NlIHBvc2l0aW9uIGlzIGJleW9uZCB0aGUgZHJhZ2dlZCBpdGVtIGJ5IHRoZSBsZWFzdCBhbW91bnRcblx0ICBsZXQgZHIgPSBzZWxmLmRyYWdnaW5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgIGxldCBiU2liID0gbnVsbDtcblx0ICBsZXQgeHkgPSBkMy5zZWxlY3Qoc2VsZi5kcmFnUGFyZW50KS5jbGFzc2VkKFwiZmxleHJvd1wiKSA/IFwieFwiIDogXCJ5XCI7XG5cdCAgZm9yIChsZXQgcyBvZiBzZWxmLmRyYWdTaWJzKSB7XG5cdCAgICAgIGxldCBzciA9IHMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgICAgIGlmIChkclt4eV0gPCBzclt4eV0pIHtcblx0XHQgICBsZXQgZGlzdCA9IHNyW3h5XSAtIGRyW3h5XTtcblx0XHQgICBpZiAoIWJTaWIgfHwgZGlzdCA8IGJTaWJbeHldIC0gZHJbeHldKVxuXHRcdCAgICAgICBiU2liID0gcztcblx0ICAgICAgfVxuXHQgIH1cblx0ICAvLyBJbnNlcnQgdGhlIGRyYWdnZWQgaXRlbSBiZWZvcmUgdGhlIGxvY2F0ZWQgc2liIChvciBhcHBlbmQgaWYgbm8gc2liIGZvdW5kKVxuXHQgIHNlbGYuZHJhZ1BhcmVudC5pbnNlcnRCZWZvcmUoc2VsZi5kcmFnZ2luZywgYlNpYik7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbiByZW9yZGVyQnlTdHlsZSgpIHtcblx0ICBsZXQgZGQgPSBkMy5zZWxlY3Qoc2VsZi5kcmFnZ2luZyk7XG5cdCAgLy8gTG9jYXRlIHRoZSBzaWIgdGhhdCBjb250YWlucyB0aGUgZHJhZ2dlZCBpdGVtJ3Mgb3JpZ2luLlxuXHQgIGxldCBkciA9IHNlbGYuZHJhZ2dpbmcuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdCAgbGV0IGJTaWIgPSBudWxsO1xuXHQgIGxldCB4eSA9IGQzLnNlbGVjdChzZWxmLmRyYWdQYXJlbnQpLmNsYXNzZWQoXCJmbGV4cm93XCIpID8gXCJ4XCIgOiBcInlcIjtcblx0ICBsZXQgc3ogPSB4eSA9PT0gXCJ4XCIgPyBcIndpZHRoXCIgOiBcImhlaWdodFwiO1xuXHQgIGxldCBzdHk9IHh5ID09PSBcInhcIiA/IFwibGVmdFwiIDogXCJ0b3BcIjtcblx0ICBmb3IgKGxldCBzIG9mIHNlbGYuZHJhZ1NpYnMpIHtcblx0ICAgICAgLy8gc2tpcCB0aGUgZHJhZ2dlZCBpdGVtXG5cdCAgICAgIGlmIChzID09PSBzZWxmLmRyYWdnaW5nKSBjb250aW51ZTtcblx0ICAgICAgbGV0IGRzID0gZDMuc2VsZWN0KHMpO1xuXHQgICAgICBsZXQgc3IgPSBzLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICAvLyBpZncgdGhlIGRyYWdnZWQgaXRlbSdzIG9yaWdpbiBpcyBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIG9mIHNpYiwgd2UgZm91bmQgaXQuXG5cdCAgICAgIGlmIChkclt4eV0gPj0gc3JbeHldICYmIGRyW3h5XSA8PSAoc3JbeHldICsgc3Jbc3pdKSkge1xuXHRcdCAgIC8vIG1vdmUgc2liIHRvd2FyZCB0aGUgaG9sZSwgYW1vdW50ID0gdGhlIHNpemUgb2YgdGhlIGhvbGVcblx0XHQgICBsZXQgYW10ID0gc2VsZi5kcmFnSG9sZVtzel0gKiAoc2VsZi5kcmFnSG9sZVt4eV0gPCBzclt4eV0gPyAtMSA6IDEpO1xuXHRcdCAgIGRzLnN0eWxlKHN0eSwgcGFyc2VJbnQoZHMuc3R5bGUoc3R5KSkgKyBhbXQgKyBcInB4XCIpO1xuXHRcdCAgIHNlbGYuZHJhZ0hvbGVbeHldIC09IGFtdDtcbiAgICAgICAgICAgICAgICAgICBicmVhaztcblx0ICAgICAgfVxuXHQgIH1cbiAgICAgIH1cbiAgICAgIC8vXG4gICAgICByZXR1cm4gZDMuYmVoYXZpb3IuZHJhZygpXG5cdCAgLm9yaWdpbihmdW5jdGlvbihkLGkpe1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICB9KVxuICAgICAgICAgIC5vbihcImRyYWdzdGFydC5tXCIsIGZ1bmN0aW9uKCkge1xuXHQgICAgICBsZXQgdCA9IGQzLmV2ZW50LnNvdXJjZUV2ZW50LnRhcmdldDtcblx0ICAgICAgaWYgKCEgZDMuc2VsZWN0KHQpLmNsYXNzZWQoXCJkcmFnaGFuZGxlXCIpKSByZXR1cm47XG5cdCAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICAvL1xuXHQgICAgICBzZWxmLmRyYWdnaW5nICAgID0gdGhpcy5jbG9zZXN0KFwiLnBhZ2Vib3hcIik7XG5cdCAgICAgIHNlbGYuZHJhZ0hvbGUgICAgPSBzZWxmLmRyYWdnaW5nLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgICBzZWxmLmRyYWdQYXJlbnQgID0gc2VsZi5kcmFnZ2luZy5wYXJlbnROb2RlO1xuXHQgICAgICBzZWxmLmRyYWdTaWJzICAgID0gc2VsZi5kcmFnUGFyZW50LmNoaWxkcmVuO1xuXHQgICAgICAvL1xuXHQgICAgICBkMy5zZWxlY3Qoc2VsZi5kcmFnZ2luZykuY2xhc3NlZChcImRyYWdnaW5nXCIsIHRydWUpO1xuXHQgIH0pXG5cdCAgLm9uKFwiZHJhZy5tXCIsIGZ1bmN0aW9uICgpIHtcblx0ICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSByZXR1cm47XG5cdCAgICAgIGxldCBkZCA9IGQzLnNlbGVjdChzZWxmLmRyYWdnaW5nKTtcblx0ICAgICAgbGV0IHRwID0gcGFyc2VJbnQoZGQuc3R5bGUoXCJ0b3BcIikpXG5cdCAgICAgIGRkLnN0eWxlKFwidG9wXCIsIHRwICsgZDMuZXZlbnQuZHkgKyBcInB4XCIpO1xuXHQgICAgICAvL3Jlb3JkZXJCeVN0eWxlKCk7XG5cdCAgfSlcblx0ICAub24oXCJkcmFnZW5kLm1cIiwgZnVuY3Rpb24gKCkge1xuXHQgICAgICBpZiAoIXNlbGYuZHJhZ2dpbmcpIHJldHVybjtcblx0ICAgICAgcmVvcmRlckJ5RG9tKCk7XG5cdCAgICAgIHNlbGYuc2V0UHJlZnNGcm9tVUkoKTtcblx0ICAgICAgbGV0IGRkID0gZDMuc2VsZWN0KHNlbGYuZHJhZ2dpbmcpO1xuXHQgICAgICBkZC5zdHlsZShcInRvcFwiLCBcIjBweFwiKTtcblx0ICAgICAgZGQuY2xhc3NlZChcImRyYWdnaW5nXCIsIGZhbHNlKTtcblx0ICAgICAgc2VsZi5kcmFnZ2luZyAgICA9IG51bGw7XG5cdCAgICAgIHNlbGYuZHJhZ0hvbGUgICAgPSBudWxsO1xuXHQgICAgICBzZWxmLmRyYWdQYXJlbnQgID0gbnVsbDtcblx0ICAgICAgc2VsZi5kcmFnU2licyAgICA9IG51bGw7XG5cdCAgfSlcblx0ICA7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldFVJRnJvbVByZWZzICgpIHtcblx0dGhpcy51c2VyUHJlZnNTdG9yZS5nZXQoXCJwcmVmc1wiKS50aGVuKCBwcmVmcyA9PiB7XG5cdCAgICBwcmVmcyA9IHByZWZzIHx8IHt9O1xuXHQgICAgY29uc29sZS5sb2coXCJHb3QgcHJlZnMgZnJvbSBzdG9yYWdlXCIsIHByZWZzKTtcblxuXHQgICAgLy8gc2V0IG9wZW4vY2xvc2VkIHN0YXRlc1xuXHQgICAgKHByZWZzLmNsb3NhYmxlcyB8fCBbXSkuZm9yRWFjaCggYyA9PiB7XG5cdFx0bGV0IGlkID0gY1swXTtcblx0XHRsZXQgc3RhdGUgPSBjWzFdO1xuXHRcdGQzLnNlbGVjdCgnIycraWQpLmNsYXNzZWQoJ2Nsb3NlZCcsIHN0YXRlID09PSBcImNsb3NlZFwiIHx8IG51bGwpO1xuXHQgICAgfSk7XG5cblx0ICAgIC8vIHNldCBkcmFnZ2FibGVzJyBvcmRlclxuXHQgICAgKHByZWZzLmRyYWdnYWJsZXMgfHwgW10pLmZvckVhY2goIGQgPT4ge1xuXHRcdGxldCBjdHJJZCA9IGRbMF07XG5cdFx0bGV0IGNvbnRlbnRJZHMgPSBkWzFdO1xuXHRcdGxldCBjdHIgPSBkMy5zZWxlY3QoJyMnK2N0cklkKTtcblx0XHRsZXQgY29udGVudHMgPSBjdHIuc2VsZWN0QWxsKCcjJytjdHJJZCsnID4gKicpO1xuXHRcdGNvbnRlbnRzWzBdLnNvcnQoIChhLGIpID0+IHtcblx0XHQgICAgbGV0IGFpID0gY29udGVudElkcy5pbmRleE9mKGEuZ2V0QXR0cmlidXRlKCdpZCcpKTtcblx0XHQgICAgbGV0IGJpID0gY29udGVudElkcy5pbmRleE9mKGIuZ2V0QXR0cmlidXRlKCdpZCcpKTtcblx0XHQgICAgcmV0dXJuIGFpID09PSAtMSA/IDEgOiBiaSA9PT0gLTEgPyAtMSA6IGFpIC0gYmk7XG5cdFx0fSk7XG5cdFx0Y29udGVudHMub3JkZXIoKTtcblx0ICAgIH0pO1xuXHR9KTtcbiAgICB9XG4gICAgc2V0UHJlZnNGcm9tVUkgKCkge1xuICAgICAgICAvLyBzYXZlIG9wZW4vY2xvc2VkIHN0YXRlc1xuXHRsZXQgY2xvc2FibGVzID0gdGhpcy5yb290LnNlbGVjdEFsbCgnLmNsb3NhYmxlJyk7XG5cdGxldCBvY0RhdGEgPSBjbG9zYWJsZXNbMF0ubWFwKCBjID0+IHtcblx0ICAgIGxldCBkYyA9IGQzLnNlbGVjdChjKTtcblx0ICAgIHJldHVybiBbZGMuYXR0cignaWQnKSwgZGMuY2xhc3NlZChcImNsb3NlZFwiKSA/IFwiY2xvc2VkXCIgOiBcIm9wZW5cIl07XG5cdH0pO1xuXHQvLyBzYXZlIGRyYWdnYWJsZXMnIG9yZGVyXG5cdGxldCBkcmFnQ3RycyA9IHRoaXMucm9vdC5zZWxlY3RBbGwoJy5jb250ZW50LWRyYWdnYWJsZScpO1xuXHRsZXQgZHJhZ2dhYmxlcyA9IGRyYWdDdHJzLnNlbGVjdEFsbCgnLmNvbnRlbnQtZHJhZ2dhYmxlID4gKicpO1xuXHRsZXQgZGREYXRhID0gZHJhZ2dhYmxlcy5tYXAoIChkLGkpID0+IHtcblx0ICAgIGxldCBjdHIgPSBkMy5zZWxlY3QoZHJhZ0N0cnNbMF1baV0pO1xuXHQgICAgcmV0dXJuIFtjdHIuYXR0cignaWQnKSwgZC5tYXAoIGRkID0+IGQzLnNlbGVjdChkZCkuYXR0cignaWQnKSldO1xuXHR9KTtcblx0bGV0IHByZWZzID0ge1xuXHQgICAgY2xvc2FibGVzOiBvY0RhdGEsXG5cdCAgICBkcmFnZ2FibGVzOiBkZERhdGFcblx0fVxuXHRjb25zb2xlLmxvZyhcIlNhdmluZyBwcmVmcyB0byBzdG9yYWdlXCIsIHByZWZzKTtcblx0dGhpcy51c2VyUHJlZnNTdG9yZS5zZXQoXCJwcmVmc1wiLCBwcmVmcyk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNob3dCbG9ja3MgKGNvbXApIHtcblx0bGV0IHJlZiA9IHRoaXMuckdlbm9tZTtcblx0aWYgKCEgY29tcCkgY29tcCA9IHRoaXMuY0dlbm9tZXNbMF07XG5cdGlmICghIGNvbXApIHJldHVybjtcblx0dGhpcy50cmFuc2xhdG9yLnJlYWR5KCkudGhlbiggKCkgPT4ge1xuXHQgICAgbGV0IGJsb2NrcyA9IGNvbXAgPT09IHJlZiA/IFtdIDogdGhpcy50cmFuc2xhdG9yLmdldEJsb2NrcyhyZWYsIGNvbXApO1xuXHQgICAgdGhpcy5nZW5vbWVWaWV3LmRyYXdCbG9ja3MoeyByZWYsIGNvbXAsIGJsb2NrcyB9KTtcblx0fSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNob3dCdXN5IChpc0J1c3ksIG1lc3NhZ2UpIHtcbiAgICAgICAgZDMuc2VsZWN0KFwiI2hlYWRlciA+IC5nZWFyLmJ1dHRvblwiKVxuXHQgICAgLmNsYXNzZWQoXCJyb3RhdGluZ1wiLCBpc0J1c3kpO1xuICAgICAgICBkMy5zZWxlY3QoXCIjem9vbVZpZXdcIikuY2xhc3NlZChcImJ1c3lcIiwgaXNCdXN5KTtcblx0aWYgKGlzQnVzeSAmJiBtZXNzYWdlKSB0aGlzLnNob3dTdGF0dXMobWVzc2FnZSk7XG5cdGlmICghaXNCdXN5KSB0aGlzLnNob3dTdGF0dXMoJycpXG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNob3dpbmdTdGF0dXMgKCkge1xuICAgICAgICByZXR1cm4gZDMuc2VsZWN0KCcjc3RhdHVzTWVzc2FnZScpLmNsYXNzZWQoJ3Nob3dpbmcnKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzaG93U3RhdHVzIChtc2csIG5lYXJYLCBuZWFyWSkge1xuXHRsZXQgYmIgPSB0aGlzLnJvb3Qubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRsZXQgXyA9IChuLCBsZW4sIG5tYXgpID0+IHtcblx0ICAgIGlmIChuID09PSB1bmRlZmluZWQpXG5cdCAgICAgICAgcmV0dXJuICc1MCUnO1xuXHQgICAgZWxzZSBpZiAodHlwZW9mKG4pID09PSAnc3RyaW5nJylcblx0ICAgICAgICByZXR1cm4gbjtcblx0ICAgIGVsc2UgaWYgKCBuICsgbGVuIDwgbm1heCApIHtcblx0ICAgICAgICByZXR1cm4gbiArICdweCc7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICByZXR1cm4gKG5tYXggLSBsZW4pICsgJ3B4Jztcblx0ICAgIH1cblx0fTtcblx0bmVhclggPSBfKG5lYXJYLCAyNTAsIGJiLndpZHRoKTtcblx0bmVhclkgPSBfKG5lYXJZLCAxNTAsIGJiLmhlaWdodCk7XG5cdGlmIChtc2cpXG5cdCAgICBkMy5zZWxlY3QoJyNzdGF0dXNNZXNzYWdlJylcblx0XHQuY2xhc3NlZCgnc2hvd2luZycsIHRydWUpXG5cdFx0LnN0eWxlKCdsZWZ0JywgbmVhclgpXG5cdFx0LnN0eWxlKCd0b3AnLCAgbmVhclkpXG5cdFx0LnNlbGVjdCgnc3BhbicpXG5cdFx0ICAgIC50ZXh0KG1zZyk7XG5cdGVsc2Vcblx0ICAgIGQzLnNlbGVjdCgnI3N0YXR1c01lc3NhZ2UnKS5jbGFzc2VkKCdzaG93aW5nJywgZmFsc2UpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldFJlZkdlbm9tZVNlbGVjdGlvbiAoKSB7XG5cdGQzLnNlbGVjdEFsbChcIiNyZWZHZW5vbWUgb3B0aW9uXCIpXG5cdCAgICAucHJvcGVydHkoXCJzZWxlY3RlZFwiLCAgZ2cgPT4gKGdnLmxhYmVsID09PSB0aGlzLnJHZW5vbWUubGFiZWwgIHx8IG51bGwpKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2V0Q29tcEdlbm9tZXNTZWxlY3Rpb24gKCkge1xuXHRsZXQgY2ducyA9IHRoaXMudkdlbm9tZXMubWFwKGc9PmcubGFiZWwpO1xuXHRkMy5zZWxlY3RBbGwoXCIjY29tcEdlbm9tZXMgb3B0aW9uXCIpXG5cdCAgICAgICAgLnByb3BlcnR5KFwic2VsZWN0ZWRcIiwgIGdnID0+IGNnbnMuaW5kZXhPZihnZy5sYWJlbCkgPj0gMCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNldHMgb3IgcmV0dXJuc1xuICAgIHNldEhpZ2hsaWdodCAoZmxpc3QpIHtcblx0aWYgKCFmbGlzdCkgcmV0dXJuIGZhbHNlO1xuXHR0aGlzLnpvb21WaWV3LmhpRmVhdHMgPSBmbGlzdC5yZWR1Y2UoKGEsdikgPT4geyBhW3ZdPXY7IHJldHVybiBhOyB9LCB7fSk7XG5cdHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZXR1cm5zIHRoZSBjdXJyZW50IGNvbnRleHQgYXMgYW4gb2JqZWN0LlxuICAgIC8vIEN1cnJlbnQgY29udGV4dCA9IHJlZiBnZW5vbWUgKyBjb21wIGdlbm9tZXMgKyBjdXJyZW50IHJhbmdlIChjaHIsc3RhcnQsZW5kKVxuICAgIGdldENvbnRleHQgKCkge1xuXHRpZiAodGhpcy5jbW9kZSA9PT0gJ21hcHBlZCcpIHtcblx0ICAgIGxldCBjID0gdGhpcy5jb29yZHM7XG5cdCAgICByZXR1cm4ge1xuXHRcdHJlZiA6IHRoaXMuckdlbm9tZS5sYWJlbCxcblx0XHRnZW5vbWVzOiB0aGlzLnZHZW5vbWVzLm1hcChnPT5nLmxhYmVsKSxcblx0XHRjaHI6IGMuY2hyLFxuXHRcdHN0YXJ0OiBjLnN0YXJ0LFxuXHRcdGVuZDogYy5lbmQsXG5cdFx0aGlnaGxpZ2h0OiBPYmplY3Qua2V5cyh0aGlzLnpvb21WaWV3LmhpRmVhdHMpLnNvcnQoKSxcblx0XHRkbW9kZTogdGhpcy56b29tVmlldy5kbW9kZVxuXHQgICAgfVxuXHR9IGVsc2Uge1xuXHQgICAgbGV0IGMgPSB0aGlzLmxjb29yZHM7XG5cdCAgICByZXR1cm4ge1xuXHRcdHJlZiA6IHRoaXMuckdlbm9tZS5sYWJlbCxcblx0XHRnZW5vbWVzOiB0aGlzLnZHZW5vbWVzLm1hcChnPT5nLmxhYmVsKSxcblx0XHRsYW5kbWFyazogYy5sYW5kbWFyayxcblx0XHRmbGFuazogYy5mbGFuayxcblx0XHRsZW5ndGg6IGMubGVuZ3RoLFxuXHRcdGRlbHRhOiBjLmRlbHRhLFxuXHRcdGhpZ2hsaWdodDogT2JqZWN0LmtleXModGhpcy56b29tVmlldy5oaUZlYXRzKS5zb3J0KCksXG5cdFx0ZG1vZGU6IHRoaXMuem9vbVZpZXcuZG1vZGVcblx0ICAgIH1cblx0fVxuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZXNvbHZlcyB0aGUgc3BlY2lmaWVkIGxhbmRtYXJrIHRvIGEgZmVhdHVyZSBhbmQgdGhlIGxpc3Qgb2YgZXF1aXZhbGVudCBmZWF1cmVzLlxuICAgIC8vIE1heSBiZSBnaXZlbiBhbiBpZCwgY2Fub25pY2FsIGlkLCBvciBzeW1ib2wuXG4gICAgLy8gQXJnczpcbiAgICAvLyAgICAgY2ZnIChvYmopIFNhbml0aXplZCBjb25maWcgb2JqZWN0LCB3aXRoIGEgbGFuZG1hcmsgKHN0cmluZykgZmllbGQuXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgICAgVGhlIGNmZyBvYmplY3QsIHdpdGggYWRkaXRpb25hbCBmaWVsZHM6XG4gICAgLy8gICAgICAgIGxhbmRtYXJrUmVmRmVhdDogdGhlIGxhbmRtYXJrIChGZWF0dXJlIG9iaikgaW4gdGhlIHJlZiBnZW5vbWVcbiAgICAvLyAgICAgICAgbGFuZG1hcmtGZWF0czogWyBlcXVpdmFsZW50IGZlYXR1cmVzIGluIGVhY2ggZ2Vub21lIChpbmNsdWRlcyByZildXG4gICAgLy8gICAgIEFsc28sIGNoYW5nZXMgcmVmIHRvIGJlIHRoZSBnZW5vbWUgb2YgdGhlIGxhbmRtYXJrUmVmRmVhdFxuICAgIC8vICAgICBSZXR1cm5zIG51bGwgaWYgbGFuZG1hcmsgbm90IGZvdW5kIGluIGFueSBnZW5vbWUuXG4gICAgLy8gXG4gICAgcmVzb2x2ZUxhbmRtYXJrIChjZmcpIHtcblx0bGV0IHJmLCBmZWF0cztcblx0Ly8gRmluZCB0aGUgbGFuZG1hcmsgZmVhdHVyZSBpbiB0aGUgcmVmIGdlbm9tZS4gXG5cdHJmID0gdGhpcy5mZWF0dXJlTWFuYWdlci5nZXRDYWNoZWRGZWF0dXJlc0J5TGFiZWwoY2ZnLmxhbmRtYXJrLCBjZmcucmVmKVswXTtcblx0aWYgKCFyZikge1xuXHQgICAgLy8gTGFuZG1hcmsgZG9lcyBub3QgZXhpc3QgaW4gcmVmIGdlbm9tZS4gRG9lcyBpdCBleGlzdCBpbiBhbnkgc3BlY2lmaWVkIGdlbm9tZT9cblx0ICAgIHJmID0gdGhpcy5mZWF0dXJlTWFuYWdlci5nZXRDYWNoZWRGZWF0dXJlc0J5TGFiZWwoY2ZnLmxhbmRtYXJrKS5maWx0ZXIoZiA9PiBjZmcuZ2Vub21lcy5pbmRleE9mKGYuZ2Vub21lKSA+PSAwKVswXTtcblx0ICAgIGlmIChyZikge1xuXHQgICAgICAgIGNmZy5yZWYgPSByZi5nZW5vbWU7XG5cdCAgICB9XG5cdCAgICBlbHNlIHtcblx0ICAgICAgICAvLyBMYW5kbWFyayBjYW5ub3QgYmUgcmVzb2x2ZWQuXG5cdFx0cmV0dXJuIG51bGw7XG5cdCAgICB9XG5cdH1cblx0Ly8gbGFuZG1hcmsgZXhpc3RzIGluIHJlZiBnZW5vbWUuIEdldCBlcXVpdmFsZW50IGZlYXQgaW4gZWFjaCBnZW5vbWUuXG5cdGZlYXRzID0gcmYuY2Fub25pY2FsID8gdGhpcy5mZWF0dXJlTWFuYWdlci5nZXRDYWNoZWRGZWF0dXJlc0J5Q2Fub25pY2FsSWQocmYuY2Fub25pY2FsKSA6IFtyZl07XG5cdGNmZy5sYW5kbWFya1JlZkZlYXQgPSByZjtcblx0Y2ZnLmxhbmRtYXJrRmVhdHMgPSBmZWF0cy5maWx0ZXIoZiA9PiBjZmcuZ2Vub21lcy5pbmRleE9mKGYuZ2Vub21lKSA+PSAwKTtcblx0cmV0dXJuIGNmZztcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyBhIHNhbml0aXplZCB2ZXJzaW9uIG9mIHRoZSBhcmd1bWVudCBjb25maWd1cmF0aW9uIG9iamVjdC5cbiAgICAvLyBUaGUgc2FuaXRpemVkIHZlcnNpb246XG4gICAgLy8gICAgIC0gaGFzIGEgc2V0dGluZyBmb3IgZXZlcnkgcGFyYW1ldGVyLiBQYXJhbWV0ZXJzIG5vdCBzcGVjaWZpZWQgaW4gXG4gICAgLy8gICAgICAgdGhlIGFyZ3VtZW50IGFyZSAoZ2VuZXJhbGx5KSBmaWxsZWQgaW4gd2l0aCB0aGVpciBjdXJyZW50IHZhbHVlcy5cbiAgICAvLyAgICAgLSBpcyBhbHdheXMgdmFsaWQsIGVnXG4gICAgLy8gICAgIFx0LSBoYXMgYSBsaXN0IG9mIDEgb3IgbW9yZSB2YWxpZCBnZW5vbWVzLCB3aXRoIG9uZSBvZiB0aGVtIGRlc2lnbmF0ZWQgYXMgdGhlIHJlZlxuICAgIC8vICAgICBcdC0gaGFzIGEgdmFsaWQgY29vcmRpbmF0ZSByYW5nZVxuICAgIC8vICAgICBcdCAgICAtIHN0YXJ0IGFuZCBlbmQgYXJlIGludGVnZXJzIHdpdGggc3RhcnQgPD0gZW5kXG4gICAgLy8gICAgIFx0ICAgIC0gdmFsaWQgY2hyb21vc29tZSBmb3IgcmVmIGdlbm9tZVxuICAgIC8vXG4gICAgLy8gVGhlIHNhbml0aXplZCB2ZXJzaW9uIGlzIGFsc28gXCJjb21waWxlZFwiOlxuICAgIC8vICAgICAtIGl0IGhhcyBhY3R1YWwgR2Vub21lIG9iamVjdHMsIHdoZXJlIHRoZSBhcmd1bWVudCBqdXN0IGhhcyBuYW1lc1xuICAgIC8vICAgICAtIGdyb3VwcyB0aGUgY2hyK3N0YXJ0K2VuZCBpbiBcImNvb3Jkc1wiIG9iamVjdFxuICAgIC8vXG4gICAgLy9cbiAgICBzYW5pdGl6ZUNmZyAoYykge1xuXHRsZXQgY2ZnID0ge307XG5cblx0Ly8gU2FuaXRpemUgdGhlIGlucHV0LlxuXG5cdC8vIHdpbmRvdyBzaXplIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdGlmIChjLndpZHRoKSB7XG5cdCAgICBjZmcud2lkdGggPSBjLndpZHRoXG5cdH1cblxuXHQvLyByZWYgZ2Vub21lIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1xuXHQvLyBTZXQgY2ZnLnJlZiB0byBzcGVjaWZpZWQgZ2Vub21lLCBcblx0Ly8gICB3aXRoIGZhbGxiYWNrIHRvIGN1cnJlbnQgcmVmIGdlbm9tZSwgXG5cdC8vICAgICAgd2l0aCBmYWxsYmFjayB0byBDNTdCTC82SiAoMXN0IHRpbWUgdGhydSlcblx0Ly8gRklYTUU6IGZpbmFsIGZhbGxiYWNrIHNob3VsZCBiZSBhIGNvbmZpZyBzZXR0aW5nLlxuXHRjZmcucmVmID0gKGMucmVmID8gdGhpcy5ubDJnZW5vbWVbYy5yZWZdIHx8IHRoaXMuckdlbm9tZSA6IHRoaXMuckdlbm9tZSkgfHwgdGhpcy5ubDJnZW5vbWVbJ0M1N0JMLzZKJ107XG5cblx0Ly8gY29tcGFyaXNvbiBnZW5vbWVzIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gU2V0IGNmZy5nZW5vbWVzIHRvIGJlIHRoZSBzcGVjaWZpZWQgZ2Vub21lcyxcblx0Ly8gICAgIHdpdGggZmFsbGJhY2sgdG8gdGhlIGN1cnJlbnQgZ2Vub21lc1xuXHQvLyAgICAgICAgd2l0aCBmYWxsYmFjayB0byBbcmVmXSAoMXN0IHRpbWUgdGhydSlcblx0Y2ZnLmdlbm9tZXMgPSBjLmdlbm9tZXMgP1xuXHQgICAgKGMuZ2Vub21lcy5tYXAoZyA9PiB0aGlzLm5sMmdlbm9tZVtnXSkuZmlsdGVyKHg9PngpKVxuXHQgICAgOlxuXHQgICAgdGhpcy52R2Vub21lcztcblx0Ly8gQWRkIHJlZiB0byBnZW5vbWVzIGlmIG5vdCB0aGVyZSBhbHJlYWR5XG5cdGlmIChjZmcuZ2Vub21lcy5pbmRleE9mKGNmZy5yZWYpID09PSAtMSlcblx0ICAgIGNmZy5nZW5vbWVzLnVuc2hpZnQoY2ZnLnJlZik7XG5cdFxuXHQvLyBhYnNvbHV0ZSBjb29yZGluYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvL1xuXHQvLyBTZXQgY2ZnLmNociB0byBiZSB0aGUgc3BlY2lmaWVkIGNocm9tb3NvbWVcblx0Ly8gICAgIHdpdGggZmFsbGJhY2sgdG8gdGhlIGN1cnJlbnQgY2hyXG5cdC8vICAgICAgICAgd2l0aCBmYWxsYmFjayB0byB0aGUgMXN0IGNocm9tb3NvbWUgaW4gdGhlIHJlZiBnZW5vbWVcblx0Y2ZnLmNociA9IGNmZy5yZWYuZ2V0Q2hyb21vc29tZShjLmNocik7XG5cdGlmICghY2ZnLmNocikgY2ZnLmNociA9IGNmZy5yZWYuZ2V0Q2hyb21vc29tZSggdGhpcy5jb29yZHMgPyB0aGlzLmNvb3Jkcy5jaHIgOiBcIjFcIiApO1xuXHRpZiAoIWNmZy5jaHIpIGNmZy5jaHIgPSBjZmcucmVmLmdldENocm9tb3NvbWUoMCk7XG5cdGlmICghY2ZnLmNocikgdGhyb3cgXCJObyBjaHJvbW9zb21lLlwiXG5cdFxuXHQvLyBTZXQgY2ZnLnN0YXJ0IHRvIGJlIHRoZSBzcGVjaWZpZWQgc3RhcnQgd2l0aCBmYWxsYmFjayB0byB0aGUgY3VycmVudCBzdGFydFxuXHQvLyBDbGlwIGF0IGNociBib3VuZGFyaWVzXG5cdGNmZy5zdGFydCA9IGNsaXAoTWF0aC5yb3VuZCh0eXBlb2YoYy5zdGFydCkgPT09IFwibnVtYmVyXCIgPyBjLnN0YXJ0IDogdGhpcy5jb29yZHMuc3RhcnQpLCAxLCBjZmcuY2hyLmxlbmd0aCk7XG5cblx0Ly8gU2V0IGNmZy5lbmQgdG8gYmUgdGhlIHNwZWNpZmllZCBlbmQgd2l0aCBmYWxsYmFjayB0byB0aGUgY3VycmVudCBlbmRcblx0Ly8gQ2xpcCBhdCBjaHIgYm91bmRhcmllc1xuXHRjZmcuZW5kID0gY2xpcChNYXRoLnJvdW5kKHR5cGVvZihjLmVuZCkgPT09IFwibnVtYmVyXCIgPyBjLmVuZCA6IHRoaXMuY29vcmRzLmVuZCksIDEsIGNmZy5jaHIubGVuZ3RoKTtcblxuXHQvLyBFbnN1cmUgc3RhcnQgPD0gZW5kXG5cdGlmIChjZmcuc3RhcnQgPiBjZmcuZW5kKSB7XG5cdCAgIGxldCB0bXAgPSBjZmcuc3RhcnQ7IGNmZy5zdGFydCA9IGNmZy5lbmQ7IGNmZy5lbmQgPSB0bXA7XG5cdH1cblxuXHQvLyBsYW5kbWFyayBjb29yZGluYXRlcyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBOT1RFIHRoYXQgbGFuZG1hcmsgY29vcmRpbmF0ZSBjYW5ub3QgYmUgZnVsbHkgcmVzb2x2ZWQgdG8gYWJzb2x1dGUgY29vcmRpbmF0ZSB1bnRpbFxuXHQvLyAqYWZ0ZXIqIGdlbm9tZSBkYXRhIGhhdmUgYmVlbiBsb2FkZWQuIFNlZSBzZXRDb250ZXh0IGFuZCByZXNvbHZlTGFuZG1hcmsgbWV0aG9kcy5cblx0Y2ZnLmxhbmRtYXJrID0gYy5sYW5kbWFyayB8fCB0aGlzLmxjb29yZHMubGFuZG1hcms7XG5cdGNmZy5kZWx0YSAgICA9IE1hdGgucm91bmQoJ2RlbHRhJyBpbiBjID8gYy5kZWx0YSA6ICh0aGlzLmxjb29yZHMuZGVsdGEgfHwgMCkpO1xuXHRpZiAodHlwZW9mKGMuZmxhbmspID09PSAnbnVtYmVyJyl7XG5cdCAgICBjZmcuZmxhbmsgPSBNYXRoLnJvdW5kKGMuZmxhbmspO1xuXHR9XG5cdGVsc2UgaWYgKCdsZW5ndGgnIGluIGMpIHtcblx0ICAgIGNmZy5sZW5ndGggPSBNYXRoLnJvdW5kKGMubGVuZ3RoKTtcblx0fVxuXHRlbHNlIHtcblx0ICAgIGNmZy5sZW5ndGggPSBNYXRoLnJvdW5kKHRoaXMuY29vcmRzLmVuZCAtIHRoaXMuY29vcmRzLnN0YXJ0ICsgMSk7XG5cdH1cblxuXHQvLyBjbW9kZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHRpZiAoYy5jbW9kZSAmJiBjLmNtb2RlICE9PSAnbWFwcGVkJyAmJiBjLmNtb2RlICE9PSAnbGFuZG1hcmsnKSBjLmNtb2RlID0gbnVsbDtcblx0Y2ZnLmNtb2RlID0gYy5jbW9kZSB8fCBcblx0ICAgICgoJ2NocicgaW4gYyB8fCAnc3RhcnQnIGluIGMgfHwgJ2VuZCcgaW4gYykgP1xuXHQgICAgICAgICdtYXBwZWQnIDogXG5cdFx0KCdsYW5kbWFyaycgaW4gYyB8fCAnZmxhbmsnIGluIGMgfHwgJ2xlbmd0aCcgaW4gYyB8fCAnZGVsdGEnIGluIGMpID9cblx0XHQgICAgJ2xhbmRtYXJrJyA6IFxuXHRcdCAgICB0aGlzLmNtb2RlIHx8ICdtYXBwZWQnKTtcblxuXHQvLyBoaWdobGlnaHRpbmcgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBTZXQgY2ZnLmhpZ2hsaWdodFxuXHQvLyAgICB3aXRoIGZhbGxiYWNrIHRvIGN1cnJlbnQgaGlnaGxpZ2h0XG5cdC8vICAgICAgICB3aXRoIGZhbGxiYWNrIHRvIFtdXG5cdGNmZy5oaWdobGlnaHQgPSBjLmhpZ2hsaWdodCB8fCB0aGlzLnpvb21WaWV3LmhpZ2hsaWdodGVkIHx8IFtdO1xuXG5cdC8vIGRyYXdpbmcgbW9kZSAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIFNldCB0aGUgZHJhd2luZyBtb2RlIGZvciB0aGUgWm9vbVZpZXcuXG5cdC8vICAgICB3aXRoIGZhbGxiYWNrIHRvIHRoZSBjdXJyZW50IHZhbHVlXG5cdGlmIChjLmRtb2RlID09PSAnY29tcGFyaXNvbicgfHwgYy5kbW9kZSA9PT0gJ3JlZmVyZW5jZScpIFxuXHQgICAgY2ZnLmRtb2RlID0gYy5kbW9kZTtcblx0ZWxzZVxuXHQgICAgY2ZnLmRtb2RlID0gdGhpcy56b29tVmlldy5kbW9kZSB8fCAnY29tcGFyaXNvbic7XG5cblx0Ly9cblx0cmV0dXJuIGNmZztcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBTZXRzIHRoZSBjdXJyZW50IGNvbnRleHQgZnJvbSB0aGUgY29uZmlnIG9iamVjdC4gXG4gICAgLy8gT25seSB0aG9zZSBjb250ZXh0IGl0ZW1zIHNwZWNpZmllZCBpbiB0aGUgY29uZmlnIGFyZSBhZmZlY3RlZCwgZXhjZXB0IGFzIG5vdGVkLlxuICAgIC8vXG4gICAgLy8gQWxsIGNvbmZpZ3MgYXJlIHNhbml0aXplZCBiZWZvcmUgYmVpbmcgYXBwbGllZCAoc2VlIHNhbml0aXplQ2ZnKS5cbiAgICAvLyBcbiAgICAvLyBBcmdzOlxuICAgIC8vICAgIGMgKG9iamVjdCkgQSBjb25maWd1cmF0aW9uIG9iamVjdCB0aGF0IHNwZWNpZmllcyBzb21lL2FsbCBjb25maWcgdmFsdWVzLlxuICAgIC8vICAgICAgICAgVGhlIHBvc3NpYmxlIGNvbmZpZyBpdGVtczpcbiAgICAvLyAgICAgICAgICAgIGdlbm9tZXMgICAobGlzdCBvIHN0cmluZ3MpIEFsbCB0aGUgZ2Vub21lcyB5b3Ugd2FudCB0byBzZWUsIGluIHRvcC10by1ib3R0b20gb3JkZXIuIFxuICAgIC8vICAgICAgICAgICAgICAgTWF5IHVzZSBpbnRlcm5hbCBuYW1lcyBvciBkaXNwbGF5IGxhYmVscywgZWcsIFwibXVzX211c2N1bHVzXzEyOXMxc3ZpbWpcIiBvciBcIjEyOVMxL1N2SW1KXCIuXG4gICAgLy8gICAgICAgICAgICByZWYgICAgICAgKHN0cmluZykgVGhlIGdlbm9tZSB0byB1c2UgYXMgdGhlIHJlZmVyZW5jZS4gTWF5IGJlIG5hbWUgb3IgbGFiZWwuXG4gICAgLy8gICAgICAgICAgICBoaWdobGlnaHQgKGxpc3QgbyBzdHJpbmdzKSBJRHMgb2YgZmVhdHVyZXMgdG8gaGlnaGxpZ2h0XG4gICAgLy8gICAgICAgICAgICBkbW9kZSAgICAgKHN0cmluZykgZWl0aGVyICdjb21wYXJpc29uJyBvciAncmVmZXJlbmNlJ1xuICAgIC8vXG4gICAgLy8gICAgICAgICAgICBDb29yZGluYXRlcyBhcmUgc3BlY2lmaWVkIGluIG9uZSBvZiAyIGZvcm1zLlxuICAgIC8vICAgICAgICAgICAgICBjaHIgICAgICAgKHN0cmluZykgQ2hyb21vc29tZSBmb3IgY29vcmRpbmF0ZSByYW5nZVxuICAgIC8vICAgICAgICAgICAgICBzdGFydCAgICAgKGludCkgQ29vcmRpbmF0ZSByYW5nZSBzdGFydCBwb3NpdGlvblxuICAgIC8vICAgICAgICAgICAgICBlbmQgICAgICAgKGludCkgQ29vcmRpbmF0ZSByYW5nZSBlbmQgcG9zaXRpb25cbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBEaXNwbGF5cyB0aGlzIGNvb3JkaW5hdGUgcmFuZ2UgZnJvbSB0aGUgY3VycmVudCByZWZlcmVuY2UgZ2VuZW9tcywgYW5kIHRoZSBlcXVpdmFsZW50IChtYXBwZWQpXG4gICAgLy8gICAgICAgICAgICAgIGNvb3JkaW5hdGUgcmFuZ2UocykgaW4gZWFjaCBjb21wYXJpc29uIGdlbm9tZS5cbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgb3I6XG4gICAgLy8gICAgICAgICAgICAgIGxhbmRtYXJrICAoc3RyaW5nKSBJRCwgY2Fub25pY2FsIElELCBvciBzeW1ib2wsIGlkZW50aWZ5aW5nIGEgZmVhdHVyZS5cbiAgICAvLyAgICAgICAgICAgICAgZmxhbmt8bGVuZ3RoIChpbnQpIElmIGZsYW5rLCB2aWV3aW5nIHJlZ2lvbiBzaXplID0gZmxhbmsgKyBsZW4obGFuZG1hcmspICsgZmxhbmsuIFxuICAgIC8vICAgICAgICAgICAgICAgICBJZiBsZW5ndGgsIHZpZXdpbmcgcmVnaW9uIHNpemUgPSBsZW5ndGguIEluIGVpdGhlciBjYXNlLCB0aGUgbGFuZG1hcmsgaXMgY2VudGVyZWQgaW5cbiAgICAvLyAgICAgICAgICAgICAgICAgdGhlIHZpZXdpbmcgYXJlYSwgKy8tIGFueSBzcGVjaWZpZWQgZGVsdGEuXG4gICAgLy8gICAgICAgICAgICAgIGRlbHRhICAgICAoaW50KSBBbW91bnQgaW4gYnAgdG8gc2hpZnQgdGhlIHJlZ2lvbiBsZWZ0ICg8MCkgb3IgcmlnaHQgKD4wKS5cbiAgICAvL1xuICAgIC8vICAgICAgICAgICAgICBEaXNwbGF5cyB0aGUgcmVnaW9uIGFyb3VuZCB0aGUgc3BlY2lmaWVkIGxhbmRtYXJrIGluIGVhY2ggZ2Vub21lIHdoZXJlIGl0IGV4aXN0cy5cbiAgICAvL1xuICAgIC8vICAgIHF1aWV0bHkgKGJvb2xlYW4pIElmIHRydWUsIGRvbid0IHVwZGF0ZSBicm93c2VyIGhpc3RvcnkgKGFzIHdoZW4gZ29pbmcgYmFjaylcbiAgICAvL1xuICAgIC8vIFJldHVybnM6XG4gICAgLy8gICAgTm90aGluZ1xuICAgIC8vIFNpZGUgZWZmZWN0czpcbiAgICAvL1x0ICBSZWRyYXdzIFxuICAgIC8vXHQgIENhbGxzIGNvbnRleHRDaGFuZ2VkKCkgXG4gICAgLy9cbiAgICBzZXRDb250ZXh0IChjLCBxdWlldGx5KSB7XG4gICAgICAgIGxldCBjZmcgPSB0aGlzLnNhbml0aXplQ2ZnKGMpO1xuXHQvL2NvbnNvbGUubG9nKFwiU2V0IGNvbnRleHQgKHJhdyk6XCIsIGMpO1xuXHQvL2NvbnNvbGUubG9nKFwiU2V0IGNvbnRleHQgKHNhbml0aXplZCk6XCIsIGNmZyk7XG5cdGlmICghY2ZnKSByZXR1cm47XG5cdHRoaXMuc2hvd0J1c3kodHJ1ZSwgJ1JlcXVlc3RpbmcgZGF0YS4uLicpO1xuXHRsZXQgcCA9IHRoaXMuZmVhdHVyZU1hbmFnZXIubG9hZEdlbm9tZXMoY2ZnLmdlbm9tZXMpLnRoZW4oKCkgPT4ge1xuXHQgICAgaWYgKGNmZy5jbW9kZSA9PT0gJ2xhbmRtYXJrJykge1xuXHQgICAgICAgIGNmZyA9IHRoaXMucmVzb2x2ZUxhbmRtYXJrKGNmZyk7XG5cdFx0aWYgKCFjZmcpIHtcblx0XHQgICAgYWxlcnQoXCJMYW5kbWFyayBkb2VzIG5vdCBleGlzdCBpbiBjdXJyZW50IHJlZmVyZW5jZSBnZW5vbWUuIFBsZWFzZSBjaGFuZ2UgdGhlIHJlZmVyZW5jZSBnZW5vbWUgYW5kIHRyeSBhZ2Fpbi5cIik7XG5cdFx0ICAgIHRoaXMuc2hvd0J1c3koZmFsc2UpO1xuXHRcdCAgICByZXR1cm47XG5cdFx0fVxuXHQgICAgfVxuXHQgICAgdGhpcy52R2Vub21lcyA9IGNmZy5nZW5vbWVzO1xuXHQgICAgdGhpcy5yR2Vub21lICA9IGNmZy5yZWY7XG5cdCAgICB0aGlzLmNHZW5vbWVzID0gY2ZnLmdlbm9tZXMuZmlsdGVyKGcgPT4gZyAhPT0gY2ZnLnJlZik7XG5cdCAgICB0aGlzLnNldFJlZkdlbm9tZVNlbGVjdGlvbih0aGlzLnJHZW5vbWUubmFtZSk7XG5cdCAgICB0aGlzLnNldENvbXBHZW5vbWVzU2VsZWN0aW9uKHRoaXMudkdlbm9tZXMubWFwKGc9PmcubmFtZSkpO1xuXHQgICAgLy9cblx0ICAgIHRoaXMuY21vZGUgPSBjZmcuY21vZGU7XG5cdCAgICAvL1xuXHR9KS50aGVuKCgpID0+IHtcblx0ICAgIC8vXG5cdCAgICBpZiAoIWNmZykgcmV0dXJuO1xuXHQgICAgdGhpcy5jb29yZHMgICA9IHtcblx0XHRjaHI6IGNmZy5jaHIubmFtZSxcblx0XHRjaHJvbW9zb21lOiBjZmcuY2hyLFxuXHRcdHN0YXJ0OiBjZmcuc3RhcnQsXG5cdFx0ZW5kOiBjZmcuZW5kXG5cdCAgICB9O1xuXHQgICAgdGhpcy5sY29vcmRzICA9IHtcblx0ICAgICAgICBsYW5kbWFyazogY2ZnLmxhbmRtYXJrLCBcblx0XHRsYW5kbWFya1JlZkZlYXQ6IGNmZy5sYW5kbWFya1JlZkZlYXQsXG5cdFx0bGFuZG1hcmtGZWF0czogY2ZnLmxhbmRtYXJrRmVhdHMsXG5cdFx0Zmxhbms6IGNmZy5mbGFuaywgXG5cdFx0bGVuZ3RoOiBjZmcubGVuZ3RoLCBcblx0XHRkZWx0YTogY2ZnLmRlbHRhIFxuXHQgICAgfTtcblx0ICAgIC8vXG5cdCAgICB0aGlzLnRyYW5zbGF0b3IucmVhZHkoKS50aGVuKCgpID0+IHtcblx0XHR0aGlzLnpvb21WaWV3LnVwZGF0ZShjZmcpO1xuXHRcdC8vXG5cdFx0dGhpcy5nZW5vbWVWaWV3LnNldEJydXNoQ29vcmRzKHRoaXMuY29vcmRzKTtcblx0XHR0aGlzLmdlbm9tZVZpZXcucmVkcmF3KCk7XG5cdFx0Ly9cblx0XHRpZiAoIXF1aWV0bHkpXG5cdFx0ICAgIHRoaXMuY29udGV4dENoYW5nZWQoKTtcblx0XHQvL1xuXHRcdHRoaXMuc2hvd0J1c3koZmFsc2UpO1xuXHQgICAgfSk7XG5cdH0pO1xuXHRyZXR1cm4gcDtcbiAgICB9XG4gXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2V0Q29vcmRpbmF0ZXMgKHN0cikge1xuXHRsZXQgY29vcmRzID0gcGFyc2VDb29yZHMoc3RyKTtcblx0aWYgKCEgY29vcmRzKSB7XG5cdCAgICBsZXQgZmVhdHMgPSB0aGlzLmZlYXR1cmVNYW5hZ2VyLmdldENhY2hlZEZlYXR1cmVzQnlMYWJlbChzdHIpO1xuXHQgICAgbGV0IGZlYXRzMiA9IGZlYXRzLmZpbHRlcihmPT5mLmdlbm9tZSA9PSB0aGlzLnJHZW5vbWUpO1xuXHQgICAgbGV0IGYgPSBmZWF0czJbMF0gfHwgZmVhdHNbMF07XG5cdCAgICBpZiAoZikge1xuXHRcdGNvb3JkcyA9IHtcblx0XHQgICAgcmVmOiBmLmdlbm9tZS5uYW1lLFxuXHRcdCAgICBsYW5kbWFyazogc3RyLFxuXHRcdCAgICBkZWx0YTogMCxcblx0XHQgICAgaGlnaGxpZ2h0OiBmLmlkXG5cdFx0fVxuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdFx0YWxlcnQoXCJVbmFibGUgdG8gc2V0IGNvb3JkaW5hdGVzIHdpdGggdGhpcyB2YWx1ZTogXCIgKyBzdHIpO1xuXHRcdHJldHVybjtcblx0ICAgIH1cblx0fVxuXHR0aGlzLnNldENvbnRleHQoY29vcmRzKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICByZXNpemUgKCkge1xuXHRsZXQgdyA9IHdpbmRvdy5pbm5lcldpZHRoIC0gMjQ7XG5cdHRoaXMuZ2Vub21lVmlldy5maXRUb1dpZHRoKHcpO1xuXHR0aGlzLnpvb21WaWV3LmZpdFRvV2lkdGgodyk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJldHVybnMgdGhlIGN1cnJlbnQgY29udGV4dCBhcyBhIHBhcmFtZXRlciBzdHJpbmdcbiAgICAvLyBDdXJyZW50IGNvbnRleHQgPSByZWYgZ2Vub21lICsgY29tcCBnZW5vbWVzICsgY3VycmVudCByYW5nZSAoY2hyLHN0YXJ0LGVuZClcbiAgICBnZXRQYXJhbVN0cmluZyAoKSB7XG5cdGxldCBjID0gdGhpcy5nZXRDb250ZXh0KCk7XG4gICAgICAgIGxldCByZWYgPSBgcmVmPSR7Yy5yZWZ9YDtcbiAgICAgICAgbGV0IGdlbm9tZXMgPSBgZ2Vub21lcz0ke2MuZ2Vub21lcy5qb2luKFwiK1wiKX1gO1xuXHRsZXQgY29vcmRzID0gYGNocj0ke2MuY2hyfSZzdGFydD0ke2Muc3RhcnR9JmVuZD0ke2MuZW5kfWA7XG5cdGxldCBsZmxmID0gYy5mbGFuayA/ICcmZmxhbms9JytjLmZsYW5rIDogJyZsZW5ndGg9JytjLmxlbmd0aDtcblx0bGV0IGxjb29yZHMgPSBgbGFuZG1hcms9JHtjLmxhbmRtYXJrfSZkZWx0YT0ke2MuZGVsdGF9JHtsZmxmfWA7XG5cdGxldCBobHMgPSBgaGlnaGxpZ2h0PSR7Yy5oaWdobGlnaHQuam9pbihcIitcIil9YDtcblx0bGV0IGRtb2RlID0gYGRtb2RlPSR7Yy5kbW9kZX1gO1xuXHRyZXR1cm4gYCR7dGhpcy5jbW9kZT09PSdtYXBwZWQnP2Nvb3JkczpsY29vcmRzfSYke2Rtb2RlfSYke3JlZn0mJHtnZW5vbWVzfSYke2hsc31gO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldEN1cnJlbnRMaXN0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3Vyckxpc3Q7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNldEN1cnJlbnRMaXN0IChsc3QsIGdvVG9GaXJzdCkge1xuICAgIFx0Ly9cblx0bGV0IHByZXZMaXN0ID0gdGhpcy5jdXJyTGlzdDtcblx0dGhpcy5jdXJyTGlzdCA9IGxzdDtcblx0aWYgKGxzdCAhPT0gcHJldkxpc3QpIHtcblx0ICAgIHRoaXMuY3Vyckxpc3RJbmRleCA9IGxzdCA/IGxzdC5pZHMucmVkdWNlKCAoeCxpKSA9PiB7IHhbaV09aTsgcmV0dXJuIHg7IH0sIHt9KSA6IHt9O1xuXHQgICAgdGhpcy5jdXJyTGlzdENvdW50ZXIgPSAwO1xuXHR9XG5cdC8vXG5cdGxldCBsaXN0cyA9IGQzLnNlbGVjdCgnI215bGlzdHMnKS5zZWxlY3RBbGwoJy5saXN0SW5mbycpO1xuXHRsaXN0cy5jbGFzc2VkKFwiY3VycmVudFwiLCBkID0+IGQgPT09IGxzdCk7XG5cdC8vXG5cdC8vIHNob3cgdGhpcyBsaXN0IGFzIHRpY2sgbWFya3MgaW4gdGhlIGdlbm9tZSB2aWV3XG5cdHRoaXMuZ2Vub21lVmlldy5kcmF3VGlja3MobHN0ID8gbHN0LmlkcyA6IFtdKTtcblx0dGhpcy5nZW5vbWVWaWV3LmRyYXdUaXRsZSgpO1xuXHR0aGlzLnpvb21WaWV3LmhpZ2hsaWdodCgpO1xuXHQvL1xuXHRpZiAoZ29Ub0ZpcnN0KSB0aGlzLmdvVG9OZXh0TGlzdEVsZW1lbnQoKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ29Ub05leHRMaXN0RWxlbWVudCAoKSB7XG5cdGlmICghdGhpcy5jdXJyTGlzdCB8fCB0aGlzLmN1cnJMaXN0Lmlkcy5sZW5ndGggPT09IDApIHJldHVybjtcblx0bGV0IGN1cnJJZCA9IHRoaXMuY3Vyckxpc3QuaWRzW3RoaXMuY3Vyckxpc3RDb3VudGVyXTtcbiAgICAgICAgdGhpcy5jdXJyTGlzdENvdW50ZXIgPSAodGhpcy5jdXJyTGlzdENvdW50ZXIgKyAxKSAlIHRoaXMuY3Vyckxpc3QuaWRzLmxlbmd0aDtcblx0dGhpcy5zZXRDb29yZGluYXRlcyhjdXJySWQpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBwYW56b29tKHBmYWN0b3IsIHpmYWN0b3IpIHtcblx0Ly9cblx0IXBmYWN0b3IgJiYgKHBmYWN0b3IgPSAwKTtcblx0IXpmYWN0b3IgJiYgKHpmYWN0b3IgPSAxKTtcblx0Ly9cblx0bGV0IGMgPSB0aGlzLmNvb3Jkcztcblx0bGV0IHdpZHRoID0gYy5lbmQgLSBjLnN0YXJ0ICsgMTtcblx0bGV0IG1pZCA9IChjLnN0YXJ0ICsgYy5lbmQpLzI7XG5cdGxldCBjaHIgPSB0aGlzLnJHZW5vbWUuY2hyb21vc29tZXMuZmlsdGVyKGMgPT4gYy5uYW1lID09PSB0aGlzLmNvb3Jkcy5jaHIpWzBdO1xuXHRsZXQgbmN4dCA9IHt9OyAvLyBuZXcgY29udGV4dFxuXHRsZXQgbWluRCA9IC0oYy5zdGFydC0xKTsgLy8gbWluIGRlbHRhIChhdCBjdXJyZW50IHpvb20pXG5cdGxldCBtYXhEID0gY2hyLmxlbmd0aCAtIGMuZW5kOyAvLyBtYXggZGVsdGEgKGF0IGN1cnJlbnQgem9vbSlcblx0bGV0IGQgPSBjbGlwKHBmYWN0b3IgKiB3aWR0aCwgbWluRCwgbWF4RCk7IC8vIGRlbHRhIChhdCBuZXcgem9vbSlcblx0bGV0IG5ld3dpZHRoID0gemZhY3RvciAqIHdpZHRoO1xuXHRsZXQgbmV3c3RhcnQgPSBtaWQgLSBuZXd3aWR0aC8yICsgZDtcblx0Ly9cblx0aWYgKHRoaXMuY21vZGUgPT09ICdtYXBwZWQnKSB7XG5cdCAgICBuY3h0LmNociA9IGMuY2hyO1xuXHQgICAgbmN4dC5zdGFydCA9IG5ld3N0YXJ0O1xuXHQgICAgbmN4dC5lbmQgPSBuZXdzdGFydCArIG5ld3dpZHRoIC0gMTtcblx0fVxuXHRlbHNlIHtcblx0ICAgIG5jeHQubGVuZ3RoID0gbmV3d2lkdGg7XG5cdCAgICBuY3h0LmRlbHRhID0gdGhpcy5sY29vcmRzLmRlbHRhICsgZCA7XG5cdH1cblx0dGhpcy5zZXRDb250ZXh0KG5jeHQpO1xuICAgIH1cbiAgICB6b29tIChmYWN0b3IpIHtcbiAgICAgICAgdGhpcy5wYW56b29tKG51bGwsIGZhY3Rvcik7XG4gICAgfVxuICAgIHBhbiAoZmFjdG9yKSB7XG4gICAgICAgIHRoaXMucGFuem9vbShmYWN0b3IsIG51bGwpO1xuICAgIH1cdFxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaW5pdEZlYXRUeXBlQ29udHJvbCAoZmFjZXQpIHtcblx0bGV0IHNlbGYgPSB0aGlzO1xuXHRsZXQgY29sb3JzID0gdGhpcy5jc2NhbGUuZG9tYWluKCkubWFwKGxibCA9PiB7XG5cdCAgICByZXR1cm4geyBsYmw6bGJsLCBjbHI6dGhpcy5jc2NhbGUobGJsKSB9O1xuXHR9KTtcblx0bGV0IGNrZXMgPSBkMy5zZWxlY3QoXCIuY29sb3JLZXlcIilcblx0ICAgIC5zZWxlY3RBbGwoJy5jb2xvcktleUVudHJ5Jylcblx0XHQuZGF0YShjb2xvcnMpO1xuXHRsZXQgbmNzID0gY2tlcy5lbnRlcigpLmFwcGVuZChcImRpdlwiKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLCBcImNvbG9yS2V5RW50cnkgZmxleHJvd1wiKTtcblx0bmNzLmFwcGVuZChcImRpdlwiKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLFwic3dhdGNoXCIpXG5cdCAgICAuYXR0cihcIm5hbWVcIiwgYyA9PiBjLmxibClcblx0ICAgIC5zdHlsZShcImJhY2tncm91bmQtY29sb3JcIiwgYyA9PiBjLmNscilcblx0ICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uICgpIHtcblx0XHRsZXQgdCA9IGQzLnNlbGVjdCh0aGlzKTtcblx0ICAgICAgICB0LmNsYXNzZWQoXCJjaGVja2VkXCIsICEgdC5jbGFzc2VkKFwiY2hlY2tlZFwiKSk7XG5cdFx0bGV0IHN3YXRjaGVzID0gZDMuc2VsZWN0QWxsKFwiLnN3YXRjaC5jaGVja2VkXCIpWzBdO1xuXHRcdGxldCBmdHMgPSBzd2F0Y2hlcy5tYXAocz0+cy5nZXRBdHRyaWJ1dGUoXCJuYW1lXCIpKVxuXHRcdGZhY2V0LnNldFZhbHVlcyhmdHMpO1xuXHRcdHNlbGYuem9vbVZpZXcuaGlnaGxpZ2h0KCk7XG5cdCAgICB9KVxuXHQgICAgLmFwcGVuZChcImlcIilcblx0ICAgICAgICAuYXR0cihcImNsYXNzXCIsXCJtYXRlcmlhbC1pY29uc1wiKTtcblx0bmNzLmFwcGVuZChcInNwYW5cIilcblx0ICAgIC50ZXh0KGMgPT4gYy5sYmwpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBjbGVhckNhY2hlZERhdGEgKGFzaykge1xuXHRpZiAoIWFzayB8fCB3aW5kb3cuY29uZmlybSgnRGVsZXRlIGFsbCBjYWNoZWQgZGF0YS4gQXJlIHlvdSBzdXJlPycpKSB7XG5cdCAgICB0aGlzLmZlYXR1cmVNYW5hZ2VyLmNsZWFyQ2FjaGVkRGF0YSgpO1xuXHQgICAgdGhpcy50cmFuc2xhdG9yLmNsZWFyQ2FjaGVkRGF0YSgpO1xuXHR9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbGlua1RvTWdpU25wUmVwb3J0ICgpIHtcblx0bGV0IGMgPSB0aGlzLmdldENvbnRleHQoKTtcblx0bGV0IHVybEJhc2UgPSAnaHR0cDovL3d3dy5pbmZvcm1hdGljcy5qYXgub3JnL3NucC9zdW1tYXJ5Jztcblx0bGV0IHRhYkFyZyA9ICdzZWxlY3RlZFRhYj0xJztcblx0bGV0IHNlYXJjaEJ5QXJnID0gJ3NlYXJjaEJ5U2FtZURpZmY9Jztcblx0bGV0IGNockFyZyA9IGBzZWxlY3RlZENocm9tb3NvbWU9JHtjLmNocn1gO1xuXHRsZXQgY29vcmRBcmcgPSBgY29vcmRpbmF0ZT0ke2Muc3RhcnR9LSR7Yy5lbmR9YDtcblx0bGV0IHVuaXRBcmcgPSAnY29vcmRpbmF0ZVVuaXQ9YnAnO1xuXHRsZXQgY3NBcmdzID0gYy5nZW5vbWVzLm1hcChnID0+IGBzZWxlY3RlZFN0cmFpbnM9JHtnfWApXG5cdGxldCByc0FyZyA9IGByZWZlcmVuY2VTdHJhaW49JHtjLnJlZn1gO1xuXHRsZXQgbGlua1VybCA9IGAke3VybEJhc2V9PyR7dGFiQXJnfSYke3NlYXJjaEJ5QXJnfSYke2NockFyZ30mJHtjb29yZEFyZ30mJHt1bml0QXJnfSYke3JzQXJnfSYke2NzQXJncy5qb2luKCcmJyl9YFxuXHR3aW5kb3cub3BlbihsaW5rVXJsLCBcIl9ibGFua1wiKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbGlua1RvTWdpUVRMcyAoKSB7XG5cdGxldCBjICAgICAgICA9IHRoaXMuZ2V0Q29udGV4dCgpO1xuXHRsZXQgdXJsQmFzZSAgPSAnaHR0cDovL3d3dy5pbmZvcm1hdGljcy5qYXgub3JnL2FsbGVsZS9zdW1tYXJ5Jztcblx0bGV0IGNockFyZyAgID0gYGNocm9tb3NvbWU9JHtjLmNocn1gO1xuXHRsZXQgY29vcmRBcmcgPSBgY29vcmRpbmF0ZT0ke2Muc3RhcnR9LSR7Yy5lbmR9YDtcblx0bGV0IHVuaXRBcmcgID0gJ2Nvb3JkVW5pdD1icCc7XG5cdGxldCB0eXBlQXJnICA9ICdhbGxlbGVUeXBlPVFUTCc7XG5cdGxldCBsaW5rVXJsICA9IGAke3VybEJhc2V9PyR7Y2hyQXJnfSYke2Nvb3JkQXJnfSYke3VuaXRBcmd9JiR7dHlwZUFyZ31gO1xuXHR3aW5kb3cub3BlbihsaW5rVXJsLCBcIl9ibGFua1wiKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbGlua1RvTWdpSkJyb3dzZSAoKSB7XG5cdGxldCBjID0gdGhpcy5nZXRDb250ZXh0KCk7XG5cdGxldCB1cmxCYXNlID0gJ2h0dHA6Ly9qYnJvd3NlLmluZm9ybWF0aWNzLmpheC5vcmcvJztcblx0bGV0IGRhdGFBcmcgPSAnZGF0YT1kYXRhJTJGbW91c2UnOyAvLyBcImRhdGEvbW91c2VcIlxuXHRsZXQgbG9jQXJnICA9IGBsb2M9Y2hyJHtjLmNocn0lM0Eke2Muc3RhcnR9Li4ke2MuZW5kfWA7XG5cdGxldCB0cmFja3MgID0gWydETkEnLCdNR0lfR2Vub21lX0ZlYXR1cmVzJywnTkNCSV9DQ0RTJywnTkNCSScsJ0VOU0VNQkwnXTtcblx0bGV0IHRyYWNrc0FyZz1gdHJhY2tzPSR7dHJhY2tzLmpvaW4oJywnKX1gO1xuXHRsZXQgaGlnaGxpZ2h0QXJnID0gJ2hpZ2hsaWdodD0nO1xuXHRsZXQgbGlua1VybCA9IGAke3VybEJhc2V9PyR7IFtkYXRhQXJnLGxvY0FyZyx0cmFja3NBcmcsaGlnaGxpZ2h0QXJnXS5qb2luKCcmJykgfWA7XG5cdHdpbmRvdy5vcGVuKGxpbmtVcmwsIFwiX2JsYW5rXCIpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEb3dubG9hZHMgRE5BIHNlcXVlbmNlcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgaW4gRkFTVEEgZm9ybWF0IGZvciB0aGUgc3BlY2lmaWVkIGZlYXR1cmUuXG4gICAgLy8gSWYgZ2Vub21lcyBpcyBzcGVjaWZpZWQsIGxpc3RzIHRoZSBzcGVjaWZpYyBnZW5vbWVzIHRvIHJldHJpZXZlIGZyb207IG90aGVyd2lzZSByZXRyaWV2ZXMgZnJvbSBhbGwgZ2Vub21lcy5cbiAgICAvLyBBcmdzOlxuICAgIC8vICAgICBmIChvYmplY3QpIHRoZSBmZWF0dXJlXG4gICAgLy8gICAgIHR5cGUgKHN0cmluZykgd2hpY2ggc2VxdWVuY2VzIHRvIGRvd25sb2FkOiAnZ2Vub21pYycsJ2V4b24nLCdDRFMnLFxuICAgIC8vICAgICBnZW5vbWVzIChsaXN0IG9mIHN0cmluZ3MpIG5hbWVzIG9mIGdlbm9tZXMgdG8gcmV0cmlldmUgZnJvbS4gSWYgbm90IHNwZWNpZmllZCxcbiAgICAvLyAgICAgICAgIHJldHJpZXZlcyBzZXF1ZW5lY3MgZnJvbSBhbGwgYXZhaWxhYmxlIG1vdXNlIGdlbm9tZXMuXG4gICAgLy9cbiAgICBkb3dubG9hZEZhc3RhIChmLCB0eXBlLCBnZW5vbWVzKSB7XG5cdGxldCBxID0gdGhpcy5xdWVyeU1hbmFnZXIuYXV4RGF0YU1hbmFnZXIuc2VxdWVuY2VzRm9yRmVhdHVyZShmLCB0eXBlLCBnZW5vbWVzKVxuXHRpZiAocSkgd2luZG93Lm9wZW4ocSxcIl9ibGFua1wiKTtcbiAgICB9XG4gICAgbGlua1RvUmVwb3J0UGFnZSAoZikge1xuICAgICAgICBsZXQgdSA9IHRoaXMucXVlcnlNYW5hZ2VyLmF1eERhdGFNYW5hZ2VyLmxpbmtUb1JlcG9ydFBhZ2UoZi5pZCk7XG5cdHdpbmRvdy5vcGVuKHUsICdfYmxhbmsnKVxuICAgIH1cbn0gLy8gZW5kIGNsYXNzIE1HVkFwcFxuXG5leHBvcnQgeyBNR1ZBcHAgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL01HVkFwcC5qc1xuLy8gbW9kdWxlIGlkID0gOFxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJjbGFzcyBHZW5vbWUge1xuICBjb25zdHJ1Y3RvciAoY2ZnKSB7XG4gICAgdGhpcy5uYW1lID0gY2ZnLm5hbWU7XG4gICAgdGhpcy5sYWJlbD0gY2ZnLmxhYmVsO1xuICAgIHRoaXMuY2hyb21vc29tZXMgPSBbXTtcbiAgICB0aGlzLm1heGxlbiA9IC0xO1xuICAgIHRoaXMueHNjYWxlID0gbnVsbDtcbiAgICB0aGlzLnlzY2FsZSA9IG51bGw7XG4gICAgdGhpcy56b29tWSAgPSAtMTtcbiAgfVxuICBnZXRDaHJvbW9zb21lIChuKSB7XG4gICAgICBpZiAodHlwZW9mKG4pID09PSAnc3RyaW5nJylcblx0ICByZXR1cm4gdGhpcy5jaHJvbW9zb21lcy5maWx0ZXIoYyA9PiBjLm5hbWUgPT09IG4pWzBdO1xuICAgICAgZWxzZVxuICAgICAgICAgIHJldHVybiB0aGlzLmNocm9tb3NvbWVzW25dO1xuICB9XG4gIGhhc0Nocm9tb3NvbWUgKG4pIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENocm9tb3NvbWUobikgPyB0cnVlIDogZmFsc2U7XG4gIH1cbn1cblxuZXhwb3J0IHsgR2Vub21lIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9HZW5vbWUuanNcbi8vIG1vZHVsZSBpZCA9IDlcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHtkM2pzb24sIGQzdHN2LCBvdmVybGFwcywgc3VidHJhY3R9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHtGZWF0dXJlfSBmcm9tICcuL0ZlYXR1cmUnO1xuaW1wb3J0IHtLZXlTdG9yZX0gZnJvbSAnLi9LZXlTdG9yZSc7XG5pbXBvcnQgY29uZmlnIGZyb20gJy4vY29uZmlnJztcbmltcG9ydCB7IENvbnRpZ0Fzc2lnbmVyLCBTd2ltTGFuZUFzc2lnbmVyLCBGZWF0dXJlUGFja2VyIH0gZnJvbSAnLi9MYXlvdXQnO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEhvdyB0aGUgYXBwIGxvYWRzIGZlYXR1cmUgZGF0YS4gUHJvdmlkZXMgdHdvIGNhbGxzOlxuLy8gUmVxdWVzdHMgZmVhdHVyZXMgZnJvbSB0aGUgc2VydmVyIGFuZCByZWdpc3RlcnMgdGhlbSBpbiBhIGNhY2hlLlxuLy8gSW50ZXJhY3RzIHdpdGggdGhlIGJhY2sgZW5kIHRvIGxvYWQgZmVhdHVyZXMuXG4vL1xuY2xhc3MgRmVhdHVyZU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yIChhcHApIHtcblx0dGhpcy5jZmcgPSBjb25maWcuRmVhdHVyZU1hbmFnZXI7XG4gICAgICAgIHRoaXMuYXBwID0gYXBwO1xuXHR0aGlzLmF1eERhdGFNYW5hZ2VyID0gdGhpcy5hcHAucXVlcnlNYW5hZ2VyLmF1eERhdGFNYW5hZ2VyO1xuICAgICAgICB0aGlzLmlkMmZlYXQgPSB7fTtcdFx0Ly8gaW5kZXggZnJvbSAgZmVhdHVyZSBJRCB0byBmZWF0dXJlXG5cdHRoaXMuY2Fub25pY2FsMmZlYXRzID0ge307XHQvLyBpbmRleCBmcm9tIGNhbm9uaWNhbCBJRCAtPiBbIGZlYXR1cmVzIHRhZ2dlZCB3aXRoIHRoYXQgaWQgXVxuXHR0aGlzLnN5bWJvbDJmZWF0cyA9IHt9XHRcdC8vIGluZGV4IGZyb20gc3ltYm9sIC0+IFsgZmVhdHVyZXMgaGF2aW5nIHRoYXQgc3ltYm9sIF1cblx0XHRcdFx0XHQvLyB3YW50IGNhc2UgaW5zZW5zaXRpdmUgc2VhcmNoZXMsIHNvIGtleXMgYXJlIGxvd2VyIGNhc2VkXG5cdHRoaXMuY2FjaGUgPSB7fTtcdFx0Ly8ge2dlbm9tZS5uYW1lIC0+IHtjaHIubmFtZSAtPiBsaXN0IG9mIGJsb2Nrc319XG5cdHRoaXMubWluZUZlYXR1cmVDYWNoZSA9IHt9O1x0Ly8gYXV4aWxpYXJ5IGluZm8gcHVsbGVkIGZyb20gTW91c2VNaW5lIFxuXHR0aGlzLmxvYWRlZEdlbm9tZXMgPSBuZXcgU2V0KCk7IC8vIHRoZSBzZXQgb2YgR2Vub21lcyB0aGF0IGhhdmUgYmVlbiBmdWxseSBsb2FkZWRcblx0dGhpcy50cmFuc2NyaXB0RmlsZXMgPSB7fTtcdC8vIG1hcCBmcm9tIGZpbGUgbmFtZSB0byBwcm9taXNlIGZvciB0aGF0IGZpbGUuXG5cdC8vXG5cdHRoaXMuZlN0b3JlID0gbmV3IEtleVN0b3JlKCdmZWF0dXJlcycpOyAvLyBtYXBzIGdlbm9tZSBuYW1lIC0+IGxpc3Qgb2YgZmVhdHVyZXNcbiAgICB9XG4gXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQXJnczpcbiAgICAvLyAgIGQgKHBhcnNlZCBHRkYgcm93KVxuICAgIHByb2Nlc3NGZWF0dXJlIChnZW5vbWUsIGQpIHtcblx0bGV0IElEID0gZFs4XVsnSUQnXTtcblx0Ly8gSWYgd2UndmUgYWxyZWFkeSBnb3QgdGhpcyBvbmUgaW4gdGhlIGNhY2hlLCByZXR1cm4gaXQuXG5cdGxldCBmID0gSUQgPyB0aGlzLmlkMmZlYXRbSURdIDogbnVsbDtcblx0aWYgKGYpIHJldHVybiBmO1xuXHQvLyBDcmVhdGUgYSBuZXcgRmVhdHVyZVxuXHRmID0gbmV3IEZlYXR1cmUoZ2Vub21lLCBJRCwgZCk7XG5cdC8vIFJlZ2lzdGVyIGl0LlxuXHR0aGlzLmlkMmZlYXRbZi5JRF0gPSBmO1xuXHQvLyBnZW5vbWUgY2FjaGVcblx0bGV0IGdjID0gdGhpcy5jYWNoZVtnZW5vbWUubmFtZV0gPSAodGhpcy5jYWNoZVtnZW5vbWUubmFtZV0gfHwge30pO1xuXHQvLyBjaHJvbW9zb21lIGNhY2hlICh3L2luIGdlbm9tZSlcblx0bGV0IGNjID0gZ2NbZi5jaHJdID0gKGdjW2YuY2hyXSB8fCBbXSk7XG5cdGNjLnB1c2goZik7XG5cdC8vXG5cdGlmIChmLmNhbm9uaWNhbCAmJiBmLmNhbm9uaWNhbCAhPT0gJy4nKSB7XG5cdCAgICBsZXQgbHN0ID0gdGhpcy5jYW5vbmljYWwyZmVhdHNbZi5jYW5vbmljYWxdID0gKHRoaXMuY2Fub25pY2FsMmZlYXRzW2YuY2Fub25pY2FsXSB8fCBbXSk7XG5cdCAgICBsc3QucHVzaChmKTtcblx0fVxuXHRpZiAoZi5zeW1ib2wgJiYgZi5zeW1ib2wgIT09ICcuJykge1xuXHQgICAgbGV0IHMgPSBmLnN5bWJvbC50b0xvd2VyQ2FzZSgpO1xuXHQgICAgbGV0IGxzdCA9IHRoaXMuc3ltYm9sMmZlYXRzW3NdID0gKHRoaXMuc3ltYm9sMmZlYXRzW3NdIHx8IFtdKTtcblx0ICAgIGxzdC5wdXNoKGYpO1xuXHR9XG5cdC8vIGhlcmUgeSdnby5cblx0cmV0dXJuIGY7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYXNzZXJ0U29ydGVkIChmZWF0cykge1xuXHRsZXQgcHJldiA9IG51bGw7XG4gICAgICAgIGZlYXRzLmZvckVhY2goKGYsaSkgPT4ge1xuXHQgICAgaWYgKHByZXYgJiYgZi5jaHIgIT09IHByZXYuY2hyKVxuXHQgICAgICAgIHByZXYgPSBudWxsO1xuXHQgICAgaWYgKHByZXYgJiYgZi5zdGFydCA8IHByZXYuc3RhcnQpXG5cdCAgICAgICAgdGhyb3cgJ0ZlYXR1cmVzIGFyZSBub3Qgc29ydGVkIGF0IHBvc2l0aW9uICcgKyBpO1xuXHQgICAgcHJldiA9IGY7XG5cdH0pO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBQcm9jZXNzZXMgdGhlIFwicmF3XCIgZmVhdHVyZXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlci5cbiAgICAvLyBUdXJucyB0aGVtIGludG8gRmVhdHVyZSBvYmplY3RzIGFuZCByZWdpc3RlcnMgdGhlbS5cbiAgICAvLyBJZiB0aGUgc2FtZSByYXcgZmVhdHVyZSBpcyByZWdpc3RlcmVkIGFnYWluLFxuICAgIC8vIHRoZSBGZWF0dXJlIG9iamVjdCBjcmVhdGVkIHRoZSBmaXJzdCB0aW1lIGlzIHJldHVybmVkLlxuICAgIC8vIChJLmUuLCByZWdpc3RlcmluZyB0aGUgc2FtZSBmZWF0dXJlIG11bHRpcGxlIHRpbWVzIGlzIG9rKVxuICAgIC8vXG4gICAgcHJvY2Vzc0ZlYXR1cmVzIChnZW5vbWUsIGZlYXRzKSB7XG5cdGxldCBjdGE7XHQvLyBjb250aWcgYXNzaWduZXJcblx0bGV0IHN3YV9wO1x0Ly8gc3dpbSBsYW5lIGFzc2lnbmVyIGZvciBwbHVzIHN0cmFuZFxuXHRsZXQgc3dhX207XHQvLyBzd2ltIGxhbmUgYXNzaWduZXIgZm9yIG1pbnVzIHN0cmFuZFxuXHRsZXQgZnA7XHRcdC8vIGZlYXR1cmUgcGFja2VyXG5cdGxldCBwcmV2O1x0Ly8gcHJldmlvdXMgZmVhdHVyZVxuXHQvLyB0dXJuIHJhdyBmZWF0dXJlcyBpbnRvIEZlYXR1cmUgb2JqZWN0c1xuXHRmZWF0cyA9IGZlYXRzLm1hcChkID0+IHRoaXMucHJvY2Vzc0ZlYXR1cmUoZ2Vub21lLCBkKSk7XG5cdC8vIGFzc2lnbiBsYW5lc1xuXHRmZWF0cy5mb3JFYWNoKGYgPT4ge1xuXHQgICAgaWYgKGYuY2hyICE9IHByZXYpIHtcblx0ICAgICAgICBjdGEgPSBuZXcgQ29udGlnQXNzaWduZXIoKTtcblx0XHRzd2FfcCA9IG5ldyBTd2ltTGFuZUFzc2lnbmVyKCk7XG5cdFx0c3dhX20gPSBuZXcgU3dpbUxhbmVBc3NpZ25lcigpO1xuXHRcdGZwID0gbmV3IEZlYXR1cmVQYWNrZXIoMSk7XG5cdCAgICB9XG5cdCAgICBmLmNvbnRpZyA9IGN0YS5hc3NpZ25OZXh0KGYuc3RhcnQsIGYuZW5kKTtcblx0ICAgIGYubGFuZSA9IGYuc3RyYW5kID09PSAnKycgPyBcblx0ICAgICAgICBzd2FfcC5hc3NpZ25OZXh0KGYuc3RhcnQsIGYuZW5kKVxuXHRcdDpcblx0XHQtc3dhX20uYXNzaWduTmV4dChmLnN0YXJ0LCBmLmVuZCk7XG5cdCAgICBmLmxhbmUyID0gZnAuYXNzaWduTmV4dChmLnN0YXJ0LCBmLmVuZCwgTWF0aC5tYXgoMSwgZi50cmFuc2NyaXB0X2NvdW50KSwgZi5zeW1ib2wpXG5cdCAgICBwcmV2ID0gZi5jaHI7XG5cdH0pO1xuXHQvL3RoaXMuYXNzZXJ0U29ydGVkKGZlYXRzKTtcblx0cmV0dXJuIGZlYXRzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGVuc3VyZUZlYXR1cmVzQnlHZW5vbWUgKGdlbm9tZSkge1xuXHRpZiAodGhpcy5sb2FkZWRHZW5vbWVzLmhhcyhnZW5vbWUpKVxuXHQgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSh0cnVlKTtcblx0cmV0dXJuIHRoaXMuZlN0b3JlLmdldChnZW5vbWUubmFtZSkudGhlbihkYXRhID0+IHtcblx0ICAgIGlmIChkYXRhID09PSB1bmRlZmluZWQpIHtcblx0XHRjb25zb2xlLmxvZyhcIlJlcXVlc3Rpbmc6XCIsIGdlbm9tZS5uYW1lLCApO1xuXHRcdGxldCB1cmwgPSBgLi9kYXRhLyR7Z2Vub21lLm5hbWV9L2ZlYXR1cmVzLmpzb25gO1xuXHRcdHJldHVybiBkM2pzb24odXJsKS50aGVuKCByYXdmZWF0cyA9PiB7XG5cdFx0ICAgIHRoaXMuZlN0b3JlLnNldChnZW5vbWUubmFtZSwgcmF3ZmVhdHMpO1xuXHRcdCAgICBsZXQgZmVhdHMgPSB0aGlzLnByb2Nlc3NGZWF0dXJlcyhnZW5vbWUsIHJhd2ZlYXRzKTtcblx0XHR9KTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdGNvbnNvbGUubG9nKFwiRm91bmQgaW4gY2FjaGU6XCIsIGdlbm9tZS5uYW1lLCApO1xuXHRcdGxldCBmZWF0cyA9IHRoaXMucHJvY2Vzc0ZlYXR1cmVzKGdlbm9tZSwgZGF0YSk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdCAgICB9XG5cdH0pLnRoZW4oICgpPT4ge1xuXHQgICAgdGhpcy5sb2FkZWRHZW5vbWVzLmFkZChnZW5vbWUpOyAgXG5cdCAgICB0aGlzLmFwcC5zaG93U3RhdHVzKGBMb2FkZWQ6ICR7Z2Vub21lLm5hbWV9YCk7XG5cdCAgICByZXR1cm4gdHJ1ZTsgXG5cdH0pO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHByb2Nlc3NUcmFuc2NyaXB0ICh0KSB7XG5cdGxldCBnaWQgPSB0WzhdWydnZW5lX2lkJ107XG5cdGxldCBmZWF0ID0gdGhpcy5pZDJmZWF0W2dpZF07XG5cdGxldCB0dCA9IHtcblx0ICAgIElEOiB0WzhdWydJRCddLFxuXHQgICAgY2hyOiB0WzBdLFxuXHQgICAgc3RhcnQ6IHRbM10sXG5cdCAgICBlbmQ6IHRbNF0sXG5cdCAgICBzdHJhbmQ6IHRbNl0sXG5cdCAgICBmZWF0dXJlOiBmZWF0LFxuXHR9XG5cdHR0LmV4b25zID0gdFs4XVsnZU9mZnNldHMnXS5tYXAoIChvLGkpID0+IHtcblx0ICAgIGxldCBzdGFydCA9IHRbM10gKyBvO1xuXHQgICAgbGV0IGVuZCA9IHN0YXJ0ICsgdFs4XVsnZUxlbmd0aHMnXVtpXSAtIDE7XG5cdCAgICByZXR1cm4ge0lEOic/Jywgc3RhcnQ6c3RhcnQsIGVuZDplbmQsIGZlYXR1cmU6ZmVhdH1cblx0fSk7XG5cdGZlYXQudHJhbnNjcmlwdHMucHVzaCh0dCk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgbG9hZFRyYW5zY3JpcHRGaWxlIChmZWF0KSB7XG5cdGxldCBnZW5vbWUgPSBmZWF0Lmdlbm9tZS5uYW1lO1xuXHRsZXQgY2hyID0gZmVhdC5jaHI7XG5cdGxldCBibGsgPSBNYXRoLmZsb29yKGZlYXQuc3RhcnQvdGhpcy5jZmcudHJhbnNjcmlwdEJsb2NrU2l6ZSk7XG5cdGxldCB1cmwgPSBgZGF0YS8ke2dlbm9tZX0vdHJhbnNjcmlwdHMvY2hyJHtjaHJ9LiR7YmxrfS5qc29uYDtcblx0bGV0IHAgPSB0aGlzLnRyYW5zY3JpcHRGaWxlc1t1cmxdO1xuXHRpZiAoIXApIHtcblx0ICAgIHAgPSB0aGlzLnRyYW5zY3JpcHRGaWxlc1t1cmxdID0gZDNqc29uKHVybCkudGhlbih0cmFuc2NyaXB0cyA9PiB7XG5cdFx0dHJhbnNjcmlwdHMuZm9yRWFjaCh0ID0+IHRoaXMucHJvY2Vzc1RyYW5zY3JpcHQodCkpO1xuXHRcdGNvbnNvbGUubG9nKCdMb2FkZWQgdHJhbnNjcmlwdHM6ICcgKyB1cmwpO1xuXHQgICAgfSk7XG5cdH1cblx0cmV0dXJuIHA7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyB3aGVuIGFsbCBleG9ucyBmb3IgdGhlIGdpdmVuIHNldCBvZiBnZW5lIGlkcy5cbiAgICAvLyBHZW5lIElEcyBhcmUgZ2Vub21lLXNwZWNpZmljLCBOT1QgY2Fub25pY2FsLlxuICAgIC8vXG4gICAgZW5zdXJlVHJhbnNjcmlwdHNCeUdlbmVJZHMgKGlkcykge1xuXHQvLyBNYXAgaWRzIHRvIEZlYXR1cmUgb2JqZWN0cywgZmlsdGVyIGZvciB0aG9zZSB3aGVyZSBleG9ucyBoYXZlIG5vdCBiZWVuIHJldHJpZXZlZCB5ZXRcblx0Ly8gRXhvbnMgYWNjdW11bGF0ZSBpbiB0aGVpciBmZWF0dXJlcyAtIG5vIGNhY2hlIGV2aWN0aW9uIGltcGxlbWVudGVkIHlldC4gRklYTUUuXG5cdC8vIFxuXHRsZXQgZmVhdHMgPSAoaWRzfHxbXSkubWFwKGkgPT4gdGhpcy5pZDJmZWF0W2ldKS5maWx0ZXIoZiA9PiBmKTtcblx0bGV0IHByb21pc2VzID0gZmVhdHMubWFwKGYgPT4ge1xuXHQgICAgbGV0IGdlbm9tZSA9IGYuZ2Vub21lLm5hbWU7XG5cdCAgICBsZXQgY2hyID0gZi5jaHI7XG5cdCAgICBsZXQgYmxrID0gTWF0aC5mbG9vcihmLnN0YXJ0L3RoaXMuY2ZnLnRyYW5zY3JpcHRCbG9ja1NpemUpO1xuXHQgICAgbGV0IHVybCA9IGBkYXRhLyR7Z2Vub21lfS90cmFuc2NyaXB0cy9jaHIke2Nocn0uJHtibGt9Lmpzb25gO1xuXHQgICAgbGV0IHAgPSB0aGlzLnRyYW5zY3JpcHRGaWxlc1t1cmxdO1xuXHQgICAgaWYgKCFwKSB7XG5cdCAgICAgICAgcCA9IHRoaXMudHJhbnNjcmlwdEZpbGVzW3VybF0gPSBkM2pzb24odXJsKS50aGVuKHRyYW5zY3JpcHRzID0+IHtcblx0XHQgICAgdHJhbnNjcmlwdHMuZm9yRWFjaCh0ID0+IHRoaXMucHJvY2Vzc1RyYW5zY3JpcHQodCkpO1xuXHRcdCAgICBjb25zb2xlLmxvZygnTG9hZGVkIHRyYW5zY3JpcHRzOiAnICsgdXJsKTtcblx0XHR9KTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBwO1xuXHR9KVxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGxvYWRHZW5vbWVzIChnZW5vbWVzKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLmFsbChnZW5vbWVzLm1hcChnID0+IHRoaXMuZW5zdXJlRmVhdHVyZXNCeUdlbm9tZSAoZykpKS50aGVuKCgpPT50cnVlKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXRDYWNoZWRGZWF0dXJlc0J5UmFuZ2UgKGdlbm9tZSwgcmFuZ2UpIHtcbiAgICAgICAgbGV0IGdjID0gdGhpcy5jYWNoZVtnZW5vbWUubmFtZV0gO1xuXHRpZiAoIWdjKSByZXR1cm4gW107XG5cdGxldCBjRmVhdHMgPSBnY1tyYW5nZS5jaHJdO1xuXHRpZiAoIWNGZWF0cykgcmV0dXJuIFtdO1xuXHQvLyBGSVhNRTogc2hvdWxkIGJlIHNtYXJ0ZXIgdGhhbiB0ZXN0aW5nIGV2ZXJ5IGZlYXR1cmUhXG5cdGxldCBmZWF0cyA9IGNGZWF0cy5maWx0ZXIoY2YgPT4gb3ZlcmxhcHMoY2YsIHJhbmdlKSk7XG4gICAgICAgIHJldHVybiBmZWF0cztcdFxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJldHVybnMgYWxsIGNhY2hlZCBmZWF0dXJlcyBoYXZpbmcgdGhlIGdpdmVuIGNhbm9uaWNhbCBpZC5cbiAgICBnZXRDYWNoZWRGZWF0dXJlQnlJZCAoaWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQyZmVhdHNbaWRdO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJldHVybnMgYWxsIGNhY2hlZCBmZWF0dXJlcyBoYXZpbmcgdGhlIGdpdmVuIGNhbm9uaWNhbCBpZC5cbiAgICBnZXRDYWNoZWRGZWF0dXJlc0J5Q2Fub25pY2FsSWQgKGNpZCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jYW5vbmljYWwyZmVhdHNbY2lkXSB8fCBbXTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiBmZWF0dXJlcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBsYWJlbCwgd2hpY2ggY2FuIGJlIGFuIGlkLCBjYW5vbmljYWwgaWQsIG9yIHN5bWJvbC5cbiAgICAvLyBJZiBnZW5vbWUgaXMgc3BlY2lmaWVkLCBsaW1pdCByZXN1bHRzIHRvIGZlYXR1cmVzIGZyb20gdGhhdCBnZW5vbWUuXG4gICAgLy8gXG4gICAgZ2V0Q2FjaGVkRmVhdHVyZXNCeUxhYmVsIChsYWJlbCwgZ2Vub21lKSB7XG5cdGxldCBmID0gdGhpcy5pZDJmZWF0W2xhYmVsXVxuXHRsZXQgZmVhdHMgPSBmID8gW2ZdIDogdGhpcy5jYW5vbmljYWwyZmVhdHNbbGFiZWxdIHx8IHRoaXMuc3ltYm9sMmZlYXRzW2xhYmVsLnRvTG93ZXJDYXNlKCldIHx8IFtdO1xuXHRyZXR1cm4gZ2Vub21lID8gZmVhdHMuZmlsdGVyKGY9PiBmLmdlbm9tZSA9PT0gZ2Vub21lKSA6IGZlYXRzO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgZmVhdHVyZXMgaW4gXG4gICAgLy8gdGhlIHNwZWNpZmllZCByYW5nZXMgb2YgdGhlIHNwZWNpZmllZCBnZW5vbWUuXG4gICAgZ2V0RmVhdHVyZXNCeVJhbmdlIChnZW5vbWUsIHJhbmdlcywgZ2V0RXhvbnMpIHtcblx0bGV0IGZpZHMgPSBbXVxuXHRsZXQgcCA9IHRoaXMuZW5zdXJlRmVhdHVyZXNCeUdlbm9tZShnZW5vbWUpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgcmFuZ2VzLmZvckVhY2goIHIgPT4ge1xuXHQgICAgICAgIHIuZmVhdHVyZXMgPSB0aGlzLmdldENhY2hlZEZlYXR1cmVzQnlSYW5nZShnZW5vbWUsIHIpIFxuXHRcdHIuZ2Vub21lID0gZ2Vub21lO1xuXHRcdGZpZHMgPSBmaWRzLmNvbmNhdChyLmZlYXR1cmVzLm1hcChmID0+IGYuSUQpKVxuXHQgICAgfSk7XG5cdCAgICBsZXQgcmVzdWx0cyA9IHsgZ2Vub21lLCBibG9ja3M6cmFuZ2VzIH07XG5cdCAgICByZXR1cm4gcmVzdWx0cztcblx0fSk7XG5cdGlmIChnZXRFeG9ucykge1xuXHQgICAgcCA9IHAudGhlbihyZXN1bHRzID0+IHtcblx0ICAgICAgICByZXR1cm4gdGhpcy5lbnN1cmVUcmFuc2NyaXB0c0J5R2VuZUlkcyhmaWRzKS50aGVuKCgpPT5yZXN1bHRzKTtcblx0XHR9KTtcblx0fVxuXHRyZXR1cm4gcDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgZm9yIHRoZSBmZWF0dXJlcyBoYXZpbmcgdGhlIHNwZWNpZmllZCBpZHMgZnJvbSB0aGUgc3BlY2lmaWVkIGdlbm9tZS5cbiAgICBnZXRGZWF0dXJlc0J5SWQgKGdlbm9tZSwgaWRzKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmVuc3VyZUZlYXR1cmVzQnlHZW5vbWUoZ2Vub21lKS50aGVuKCAoKSA9PiB7XG5cdCAgICBsZXQgZmVhdHMgPSBbXTtcblx0ICAgIGxldCBzZWVuID0gbmV3IFNldCgpO1xuXHQgICAgbGV0IGFkZGYgPSAoZikgPT4ge1xuXHRcdGlmIChmLmdlbm9tZSAhPT0gZ2Vub21lKSByZXR1cm47XG5cdFx0aWYgKHNlZW4uaGFzKGYuaWQpKSByZXR1cm47XG5cdFx0c2Vlbi5hZGQoZi5pZCk7XG5cdFx0ZmVhdHMucHVzaChmKTtcblx0ICAgIH07XG5cdCAgICBsZXQgYWRkID0gKGYpID0+IHtcblx0XHRpZiAoQXJyYXkuaXNBcnJheShmKSkgXG5cdFx0ICAgIGYuZm9yRWFjaChmZiA9PiBhZGRmKGZmKSk7XG5cdFx0ZWxzZVxuXHRcdCAgICBhZGRmKGYpO1xuXHQgICAgfTtcblx0ICAgIGZvciAobGV0IGkgb2YgaWRzKXtcblx0XHRsZXQgZiA9IHRoaXMuY2Fub25pY2FsMmZlYXRzW2ldIHx8IHRoaXMuaWQyZmVhdFtpXTtcblx0XHRmICYmIGFkZChmKTtcblx0ICAgIH1cblx0ICAgIHJldHVybiBmZWF0cztcblx0fSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNsZWFyQ2FjaGVkRGF0YSAoKSB7XG5cdGNvbnNvbGUubG9nKFwiRmVhdHVyZU1hbmFnZXI6IENhY2hlIGNsZWFyZWQuXCIpXG4gICAgICAgIHJldHVybiB0aGlzLmZTdG9yZS5jbGVhcigpO1xuICAgIH1cblxufSAvLyBlbmQgY2xhc3MgRmVhdHVyZSBNYW5hZ2VyXG5cbmV4cG9ydCB7IEZlYXR1cmVNYW5hZ2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9GZWF0dXJlTWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTBcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiY2xhc3MgU3RvcmUge1xyXG4gICAgY29uc3RydWN0b3IoZGJOYW1lID0gJ2tleXZhbC1zdG9yZScsIHN0b3JlTmFtZSA9ICdrZXl2YWwnKSB7XHJcbiAgICAgICAgdGhpcy5zdG9yZU5hbWUgPSBzdG9yZU5hbWU7XHJcbiAgICAgICAgdGhpcy5fZGJwID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBvcGVucmVxID0gaW5kZXhlZERCLm9wZW4oZGJOYW1lLCAxKTtcclxuICAgICAgICAgICAgb3BlbnJlcS5vbmVycm9yID0gKCkgPT4gcmVqZWN0KG9wZW5yZXEuZXJyb3IpO1xyXG4gICAgICAgICAgICBvcGVucmVxLm9uc3VjY2VzcyA9ICgpID0+IHJlc29sdmUob3BlbnJlcS5yZXN1bHQpO1xyXG4gICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNldHVwOiBjcmVhdGUgYW4gZW1wdHkgb2JqZWN0IHN0b3JlXHJcbiAgICAgICAgICAgIG9wZW5yZXEub251cGdyYWRlbmVlZGVkID0gKCkgPT4ge1xyXG4gICAgICAgICAgICAgICAgb3BlbnJlcS5yZXN1bHQuY3JlYXRlT2JqZWN0U3RvcmUoc3RvcmVOYW1lKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIF93aXRoSURCU3RvcmUodHlwZSwgY2FsbGJhY2spIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fZGJwLnRoZW4oZGIgPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IGRiLnRyYW5zYWN0aW9uKHRoaXMuc3RvcmVOYW1lLCB0eXBlKTtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25jb21wbGV0ZSA9ICgpID0+IHJlc29sdmUoKTtcclxuICAgICAgICAgICAgdHJhbnNhY3Rpb24ub25hYm9ydCA9IHRyYW5zYWN0aW9uLm9uZXJyb3IgPSAoKSA9PiByZWplY3QodHJhbnNhY3Rpb24uZXJyb3IpO1xyXG4gICAgICAgICAgICBjYWxsYmFjayh0cmFuc2FjdGlvbi5vYmplY3RTdG9yZSh0aGlzLnN0b3JlTmFtZSkpO1xyXG4gICAgICAgIH0pKTtcclxuICAgIH1cclxufVxyXG5sZXQgc3RvcmU7XHJcbmZ1bmN0aW9uIGdldERlZmF1bHRTdG9yZSgpIHtcclxuICAgIGlmICghc3RvcmUpXHJcbiAgICAgICAgc3RvcmUgPSBuZXcgU3RvcmUoKTtcclxuICAgIHJldHVybiBzdG9yZTtcclxufVxyXG5mdW5jdGlvbiBnZXQoa2V5LCBzdG9yZSA9IGdldERlZmF1bHRTdG9yZSgpKSB7XHJcbiAgICBsZXQgcmVxO1xyXG4gICAgcmV0dXJuIHN0b3JlLl93aXRoSURCU3RvcmUoJ3JlYWRvbmx5Jywgc3RvcmUgPT4ge1xyXG4gICAgICAgIHJlcSA9IHN0b3JlLmdldChrZXkpO1xyXG4gICAgfSkudGhlbigoKSA9PiByZXEucmVzdWx0KTtcclxufVxyXG5mdW5jdGlvbiBzZXQoa2V5LCB2YWx1ZSwgc3RvcmUgPSBnZXREZWZhdWx0U3RvcmUoKSkge1xyXG4gICAgcmV0dXJuIHN0b3JlLl93aXRoSURCU3RvcmUoJ3JlYWR3cml0ZScsIHN0b3JlID0+IHtcclxuICAgICAgICBzdG9yZS5wdXQodmFsdWUsIGtleSk7XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBkZWwoa2V5LCBzdG9yZSA9IGdldERlZmF1bHRTdG9yZSgpKSB7XHJcbiAgICByZXR1cm4gc3RvcmUuX3dpdGhJREJTdG9yZSgncmVhZHdyaXRlJywgc3RvcmUgPT4ge1xyXG4gICAgICAgIHN0b3JlLmRlbGV0ZShrZXkpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gY2xlYXIoc3RvcmUgPSBnZXREZWZhdWx0U3RvcmUoKSkge1xyXG4gICAgcmV0dXJuIHN0b3JlLl93aXRoSURCU3RvcmUoJ3JlYWR3cml0ZScsIHN0b3JlID0+IHtcclxuICAgICAgICBzdG9yZS5jbGVhcigpO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24ga2V5cyhzdG9yZSA9IGdldERlZmF1bHRTdG9yZSgpKSB7XHJcbiAgICBjb25zdCBrZXlzID0gW107XHJcbiAgICByZXR1cm4gc3RvcmUuX3dpdGhJREJTdG9yZSgncmVhZG9ubHknLCBzdG9yZSA9PiB7XHJcbiAgICAgICAgLy8gVGhpcyB3b3VsZCBiZSBzdG9yZS5nZXRBbGxLZXlzKCksIGJ1dCBpdCBpc24ndCBzdXBwb3J0ZWQgYnkgRWRnZSBvciBTYWZhcmkuXHJcbiAgICAgICAgLy8gQW5kIG9wZW5LZXlDdXJzb3IgaXNuJ3Qgc3VwcG9ydGVkIGJ5IFNhZmFyaS5cclxuICAgICAgICAoc3RvcmUub3BlbktleUN1cnNvciB8fCBzdG9yZS5vcGVuQ3Vyc29yKS5jYWxsKHN0b3JlKS5vbnN1Y2Nlc3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5yZXN1bHQpXHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIGtleXMucHVzaCh0aGlzLnJlc3VsdC5rZXkpO1xyXG4gICAgICAgICAgICB0aGlzLnJlc3VsdC5jb250aW51ZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICB9KS50aGVuKCgpID0+IGtleXMpO1xyXG59XG5cbmV4cG9ydCB7IFN0b3JlLCBnZXQsIHNldCwgZGVsLCBjbGVhciwga2V5cyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvaWRiLWtleXZhbC9kaXN0L2lkYi1rZXl2YWwubWpzXG4vLyBtb2R1bGUgaWQgPSAxMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbmNsYXNzIENvbnRpZ0Fzc2lnbmVyIHtcbiAgICBjb25zdHJ1Y3RvciAoKSB7XG4gICAgICAgIHRoaXMuY29udGlnID0gMDtcblx0dGhpcy5od20gPSBudWxsO1xuICAgIH1cbiAgICBhc3NpZ25OZXh0IChmc3RhcnQsIGZlbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuaHdtID09PSBudWxsIHx8IGZzdGFydCA+IHRoaXMuaHdtKVxuXHQgICAgdGhpcy5jb250aWcgKz0gMTtcblx0dGhpcy5od20gPSBNYXRoLm1heCh0aGlzLmh3bSwgZmVuZCk7XG5cdHJldHVybiB0aGlzLmNvbnRpZztcbiAgICB9XG59XG5cbmNsYXNzIFN3aW1MYW5lQXNzaWduZXIge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcbiAgICAgICAgdGhpcy5sYW5lcyA9IFtdO1xuICAgIH1cbiAgICBhc3NpZ25OZXh0IChmc3RhcnQsIGZlbmQpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmxhbmVzLmxlbmd0aDsgaSsrKSB7XG5cdCAgICBsZXQgaHdtID0gdGhpcy5sYW5lc1tpXTtcblx0ICAgIGlmIChmc3RhcnQgPiBod20pIHtcblx0ICAgICAgICB0aGlzLmxhbmVzW2ldID0gZmVuZDtcblx0XHRyZXR1cm4gaSsxO1xuXHQgICAgfVxuXHR9XG5cdHRoaXMubGFuZXMucHVzaChmZW5kKTtcblx0cmV0dXJuIHRoaXMubGFuZXMubGVuZ3RoO1xuICAgIH1cbn1cblxuY2xhc3MgeEZlYXR1cmVQYWNrZXIge1xuICAgIGNvbnN0cnVjdG9yICh5Z2FwKSB7XG5cdC8vIGRpc3RhbmNlIGJldHdlZW4gYmxvY2tzLlxuXHR0aGlzLnlnYXAgPSB5Z2FwIHx8IDA7XG5cdC8vIG92ZXJsYXBwaW5nIGZlYXR1cmVzLlxuICAgICAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIH1cbiAgICBhc3NpZ25OZXh0IChmc3RhcnQsIGZlbmQsIGZoZWlnaHQpIHtcblx0Ly8gcmVtb3ZlIGJ1ZmZlciBpdGVtcyB0aGF0IGRvIG5vdCBvdmVybGFwIHRoZSBuZXcgZmVhdHVyZVxuICAgICAgICB0aGlzLmJ1ZmZlciA9IHRoaXMuYnVmZmVyLmZpbHRlcihmZiA9PiB7XG5cdCAgICByZXR1cm4gZnN0YXJ0IDw9IGZmLmZlbmQgJiYgZmVuZCA+PSBmZi5mc3RhcnQ7XG5cdH0pO1xuXHQvLyBMb29rIGZvciBhIGJpZyBlbm91Z2ggZ2FwIGluIHRoZSB5IGRpbWVuc2lvbiBiZXR3ZWVuIGJ1ZmZlciBpdGVtc1xuXHQvLyB0byBmaXQgdGhpcyBuZXcgb25lLiBJZiBub25lIGZvdW5kLCBzdGFjayBvbiB0b3AuXG5cdC8vIEJ1ZmZlciBpcyBtYWludGFpbmVkIGluIHNvcnRlZCB5IG9yZGVyLlxuXHQvLyBOQjogcmVtZW1iZXIsIHVwIG1lYW5zIG5lZ2F0aXZlIHkgZGlyZWN0aW9uLlxuXHRsZXQgbWluR2FwID0gZmhlaWdodCArIDIqdGhpcy55Z2FwO1xuXHRsZXQgeSA9IDA7XG5cdGxldCBpID0gMDtcblx0Zm9yIChpIGluIHRoaXMuYnVmZmVyKSB7XG5cdCAgICBsZXQgZmYgPSB0aGlzLmJ1ZmZlcltpXTtcblx0ICAgIC8vIGRpc3RhbmNlIGJldHdlZW4gY3VycmVudCB5IGFuZCBib3R0b20gb2YgbmV4dCBibG9jayBpbiBidWZmZXJcblx0ICAgIGxldCBnYXBTaXplID0geSAtIChmZi55ICsgZmYuZmhlaWdodCk7XG5cdCAgICBpZiAoZ2FwU2l6ZSA+PSBtaW5HYXApIHtcblx0XHRicmVhaztcblx0ICAgIH1cblx0ICAgIC8vIHNldCBjdXJyZW50IHkgdG8gdG9wIG9mIHRoaXMgYnVmZmVyIGJsb2NrXG5cdCAgICB5ID0gZmYueTtcblx0fTtcblx0Ly8gRm91bmQgeSBmb3IgbmV3IGJsb2NrJ3MgYmFzZWxpbmUuIFdhbnQgcG9zaXRpb24gYXQgdG9wIG9mIGJsb2NrLlxuXHR5ID0geSAtIGZoZWlnaHQgLSB0aGlzLnlnYXA7XG5cdC8vIEluc2VydCBpbnRvIGJ1ZmZlci4gTWFpbnRhaW4geSBzb3J0LlxuXHR0aGlzLmJ1ZmZlci5zcGxpY2UoaSwwLCB7ZnN0YXJ0LCBmZW5kLCBmaGVpZ2h0LCB5fSk7XG5cdC8vIGhlcmUgeWEgZ29cblx0cmV0dXJuIHk7XG4gICAgfVxufVxuY2xhc3MgRmVhdHVyZVBhY2tlciB7XG4gICAgY29uc3RydWN0b3IgKHlnYXApIHtcblx0Ly8gZGlzdGFuY2UgYmV0d2VlbiBibG9ja3MuXG5cdHRoaXMueWdhcCA9IHlnYXAgfHwgMDtcblx0Ly8gb3ZlcmxhcHBpbmcgZmVhdHVyZXMuXG4gICAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgfVxuICAgIGFzc2lnbk5leHQgKGZzdGFydCwgZmVuZCwgZmhlaWdodCwgZnN5bWJvbCkge1xuXHQvLyByZW1vdmUgYnVmZmVyIGl0ZW1zIHRoYXQgZG8gbm90IG92ZXJsYXAgdGhlIG5ldyBmZWF0dXJlXG4gICAgICAgIHRoaXMuYnVmZmVyID0gdGhpcy5idWZmZXIuZmlsdGVyKGZmID0+IHtcblx0ICAgIHJldHVybiBmc3RhcnQgPD0gZmYuZmVuZCAmJiBmZW5kID49IGZmLmZzdGFydDtcblx0fSk7XG5cdC8vIExvb2sgZm9yIGEgYmlnIGVub3VnaCBnYXAgaW4gdGhlIHkgZGltZW5zaW9uIGJldHdlZW4gYnVmZmVyIGl0ZW1zXG5cdC8vIHRvIGZpdCB0aGlzIG5ldyBvbmUuIElmIG5vbmUgZm91bmQsIHN0YWNrIG9uIHRvcC5cblx0Ly8gQnVmZmVyIGlzIG1haW50YWluZWQgaW4gc29ydGVkIHkgb3JkZXIuXG5cdC8vIE5COiByZW1lbWJlciwgcG9zaXRpdmUgeSBpcyBkb3duIGluIHNjcmVlbiBjb29yZHNcblx0bGV0IG1pbkdhcCA9IGZoZWlnaHQgKyAyKnRoaXMueWdhcDtcblx0bGV0IHkgPSAwOyAvLyBzdGFydCBvZmYgYXQgYmFzZWxpbmVcblx0bGV0IGk7XG5cdGZvciAoaSA9IDA7IGkgPCB0aGlzLmJ1ZmZlci5sZW5ndGg7IGkrKykge1xuXHQgICAgbGV0IGZmID0gdGhpcy5idWZmZXJbaV07XG5cdCAgICAvLyBkaXN0YW5jZSBiZXR3ZWVuIGN1cnJlbnQgeSBhbmQgdG9wIG9mIG5leHQgYmxvY2sgaW4gYnVmZmVyXG5cdCAgICBsZXQgZ2FwU2l6ZSA9IGZmLnkgLSB5O1xuXHQgICAgaWYgKGdhcFNpemUgPj0gbWluR2FwKSB7XG5cdFx0YnJlYWs7XG5cdCAgICB9XG5cdCAgICAvLyBzZXQgY3VycmVudCB5IHRvIGJvdHRvbSBvZiB0aGlzIGJ1ZmZlciBibG9ja1xuXHQgICAgeSA9IGZmLnkgKyBmZi5maGVpZ2h0O1xuXHR9O1xuXHQvLyBGb3VuZCB5IGZvciBuZXcgYmxvY2sncyBiYXNlbGluZS4gV2FudCBwb3NpdGlvbiBhdCB0b3Agb2YgYmxvY2suXG5cdHkgKz0gdGhpcy55Z2FwO1xuXHQvLyBJbnNlcnQgaW50byBidWZmZXIuIE1haW50YWluIHkgc29ydC5cblx0dGhpcy5idWZmZXIuc3BsaWNlKGksIDAsIHtmc3RhcnQsIGZlbmQsIGZoZWlnaHQsIHksIGZzeW1ib2x9KTtcblx0Ly8gaGVyZSB5YSBnb1xuXHRyZXR1cm4geTtcbiAgICB9XG59XG5cbmV4cG9ydCB7IENvbnRpZ0Fzc2lnbmVyLCBTd2ltTGFuZUFzc2lnbmVyLCBGZWF0dXJlUGFja2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9MYXlvdXQuanNcbi8vIG1vZHVsZSBpZCA9IDEyXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgaW5pdE9wdExpc3QgfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4vQ29tcG9uZW50JztcbmltcG9ydCB7IEF1eERhdGFNYW5hZ2VyIH0gZnJvbSAnLi9BdXhEYXRhTWFuYWdlcic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgUXVlcnlNYW5hZ2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAoYXBwLCBlbHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCBlbHQpO1xuXHR0aGlzLmNmZyA9IGNvbmZpZy5RdWVyeU1hbmFnZXIuc2VhcmNoVHlwZXM7XG5cdHRoaXMuYXV4RGF0YU1hbmFnZXIgPSBuZXcgQXV4RGF0YU1hbmFnZXIoKTtcblx0dGhpcy5zZWxlY3QgPSBudWxsO1x0Ly8gbXkgPHNlbGVjdD4gZWxlbWVudFxuXHR0aGlzLnRlcm0gPSBudWxsO1x0Ly8gbXkgPGlucHV0PiBlbGVtZW50XG5cdHRoaXMuaW5pdERvbSgpO1xuICAgIH1cbiAgICBpbml0RG9tICgpIHtcblx0dGhpcy5zZWxlY3QgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cInNlYXJjaHR5cGVcIl0nKTtcblx0dGhpcy50ZXJtICAgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cInNlYXJjaHRlcm1cIl0nKTtcblx0Ly9cblx0dGhpcy50ZXJtLmF0dHIoXCJwbGFjZWhvbGRlclwiLCB0aGlzLmNmZ1swXS5wbGFjZWhvbGRlcilcblx0aW5pdE9wdExpc3QodGhpcy5zZWxlY3RbMF1bMF0sIHRoaXMuY2ZnLCBjPT5jLm1ldGhvZCwgYz0+Yy5sYWJlbCk7XG5cdC8vIFdoZW4gdXNlciBjaGFuZ2VzIHRoZSBxdWVyeSB0eXBlIChzZWxlY3RvciksIGNoYW5nZSB0aGUgcGxhY2Vob2xkZXIgdGV4dC5cblx0dGhpcy5zZWxlY3Qub24oXCJjaGFuZ2VcIiwgKCkgPT4ge1xuXHQgICAgbGV0IG9wdCA9IHRoaXMuc2VsZWN0LnByb3BlcnR5KFwic2VsZWN0ZWRPcHRpb25zXCIpWzBdO1xuXHQgICAgdGhpcy50ZXJtLmF0dHIoXCJwbGFjZWhvbGRlclwiLCBvcHQuX19kYXRhX18ucGxhY2Vob2xkZXIpXG5cdCAgICBcblx0fSk7XG5cdC8vIFdoZW4gdXNlciBlbnRlcnMgYSBzZWFyY2ggdGVybSwgcnVuIGEgcXVlcnlcblx0dGhpcy50ZXJtLm9uKFwiY2hhbmdlXCIsICgpID0+IHtcblx0ICAgIGxldCB0ZXJtID0gdGhpcy50ZXJtLnByb3BlcnR5KFwidmFsdWVcIik7XG5cdCAgICB0aGlzLnRlcm0ucHJvcGVydHkoXCJ2YWx1ZVwiLFwiXCIpO1xuXHQgICAgbGV0IHNlYXJjaFR5cGUgID0gdGhpcy5zZWxlY3QucHJvcGVydHkoXCJ2YWx1ZVwiKTtcblx0ICAgIGxldCBsc3ROYW1lID0gdGVybTtcblx0ICAgIGQzLnNlbGVjdChcIiNteWxpc3RzXCIpLmNsYXNzZWQoXCJidXN5XCIsdHJ1ZSk7IC8vIEZJWE1FIC0gcmVhY2hvdmVyXG5cdCAgICB0aGlzLmF1eERhdGFNYW5hZ2VyW3NlYXJjaFR5cGVdKHRlcm0pXHQvLyA8LSBydW4gdGhlIHF1ZXJ5XG5cdCAgICAgIC50aGVuKGZlYXRzID0+IHtcblx0XHQgIC8vIEZJWE1FIC0gcmVhY2hvdmVyIC0gdGhpcyB3aG9sZSBoYW5kbGVyXG5cdFx0ICBsZXQgbHN0ID0gdGhpcy5hcHAubGlzdE1hbmFnZXIuY3JlYXRlTGlzdChsc3ROYW1lLCBmZWF0cy5tYXAoZiA9PiBmLnByaW1hcnlJZGVudGlmaWVyKSlcblx0XHQgIHRoaXMuYXBwLmxpc3RNYW5hZ2VyLnVwZGF0ZShsc3QpO1xuXHRcdCAgLy9cblx0XHQgIHRoaXMuYXBwLnpvb21WaWV3LmhpRmVhdHMgPSB7fTtcblx0XHQgIGZlYXRzLmZvckVhY2goZiA9PiB0aGlzLmFwcC56b29tVmlldy5oaUZlYXRzW2YuY2Fub25pY2FsXSA9IGYuY2Fub25pY2FsKTtcblx0XHQgIHRoaXMuYXBwLnpvb21WaWV3LmhpZ2hsaWdodCgpO1xuXHRcdCAgLy9cblx0XHQgIHRoaXMuYXBwLnNldEN1cnJlbnRMaXN0KGxzdCx0cnVlKTtcblx0XHQgIC8vXG5cdFx0ICBkMy5zZWxlY3QoXCIjbXlsaXN0c1wiKS5jbGFzc2VkKFwiYnVzeVwiLGZhbHNlKTtcblx0ICAgICAgfSk7XG5cdH0pXG4gICAgfVxufVxuXG5leHBvcnQgeyBRdWVyeU1hbmFnZXIgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL1F1ZXJ5TWFuYWdlci5qc1xuLy8gbW9kdWxlIGlkID0gMTNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IGNvbmZpZyBmcm9tICcuL2NvbmZpZyc7XG5pbXBvcnQgeyBkM2pzb24sIGQzdGV4dCB9IGZyb20gJy4vdXRpbHMnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEF1eERhdGFNYW5hZ2VyIC0ga25vd3MgaG93IHRvIHF1ZXJ5IGFuIGV4dGVybmFsIHNvdXJjZSAoaS5lLiwgTW91c2VNaW5lKSBmb3IgZ2VuZXNcbi8vIGFubm90YXRlZCB0byBkaWZmZXJlbnQgb250b2xvZ2llcyBhbmQgZm9yIGV4b25zIGFzc29jaWF0ZWQgd2l0aCBzcGVjaWZpYyBnZW5lcyBvciByZWdpb25zLlxuY2xhc3MgQXV4RGF0YU1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yICgpIHtcblx0dGhpcy5jZmcgPSBjb25maWcuQXV4RGF0YU1hbmFnZXI7XG5cdGlmICghdGhpcy5jZmcuYWxsTWluZXNbdGhpcy5jZmcubW91c2VtaW5lXSkgXG5cdCAgICB0aHJvdyBcIlVua25vd24gbWluZSBuYW1lOiBcIiArIHRoaXMuY2ZnLm1vdXNlbWluZTtcblx0dGhpcy5iYXNlVXJsID0gdGhpcy5jZmcuYWxsTWluZXNbdGhpcy5jZmcubW91c2VtaW5lXTtcblx0Y29uc29sZS5sb2coXCJNb3VzZU1pbmUgdXJsOlwiLCB0aGlzLmJhc2VVcmwpO1xuICAgICAgICB0aGlzLnFVcmwgPSB0aGlzLmJhc2VVcmwgKyAnL3NlcnZpY2UvcXVlcnkvcmVzdWx0cz8nO1xuXHR0aGlzLnJVcmwgPSB0aGlzLmJhc2VVcmwgKyAnL3BvcnRhbC5kbz9jbGFzcz1TZXF1ZW5jZUZlYXR1cmUmZXh0ZXJuYWxpZHM9Jztcblx0dGhpcy5mYVVybCA9IHRoaXMuYmFzZVVybCArICcvc2VydmljZS9xdWVyeS9yZXN1bHRzL2Zhc3RhPyc7XG5cdHRoaXMuc2VxU2xpY2VVcmwgPSB0aGlzLmJhc2VVcmwgKyAnL3NlcnZpY2Uvc2VxdWVuY2U/JztcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0QXV4RGF0YSAocSwgZm9ybWF0KSB7XG5cdC8vY29uc29sZS5sb2coJ1F1ZXJ5OiAnICsgcSk7XG5cdGZvcm1hdCA9IGZvcm1hdCB8fCAnanNvbm9iamVjdHMnO1xuXHRsZXQgcXVlcnkgPSBlbmNvZGVVUklDb21wb25lbnQocSk7XG5cdGxldCB1cmwgPSB0aGlzLnFVcmwgKyBgZm9ybWF0PSR7Zm9ybWF0fSZxdWVyeT0ke3F1ZXJ5fWA7XG5cdHJldHVybiBkM2pzb24odXJsKS50aGVuKGRhdGEgPT4gZGF0YS5yZXN1bHRzfHxbXSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaXNJZGVudGlmaWVyIChxKSB7XG4gICAgICAgIGxldCBwdHMgPSBxLnNwbGl0KCc6Jyk7XG4gICAgICAgIGlmIChwdHMubGVuZ3RoID09PSAyICYmIHB0c1sxXS5tYXRjaCgvXlswLTldKyQvKSlcblx0ICAgIHJldHVybiB0cnVlO1xuXHRpZiAocS50b0xvd2VyQ2FzZSgpLnN0YXJ0c1dpdGgoJ3ItbW11LScpKVxuXHQgICAgcmV0dXJuIHRydWU7XG5cdHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYWRkV2lsZGNhcmRzIChxKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5pc0lkZW50aWZpZXIocSkgfHwgcS5pbmRleE9mKCcqJyk+PTApID8gcSA6IGAqJHtxfSpgO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBkbyBhIExPT0tVUCBxdWVyeSBmb3IgU2VxdWVuY2VGZWF0dXJlcyBmcm9tIE1vdXNlTWluZVxuICAgIGZlYXR1cmVzQnlMb29rdXAgKHFyeVN0cmluZykge1xuXHRsZXQgcSA9IGA8cXVlcnkgbmFtZT1cIlwiIG1vZGVsPVwiZ2Vub21pY1wiIFxuXHQgICAgdmlldz1cIlNlcXVlbmNlRmVhdHVyZS5wcmltYXJ5SWRlbnRpZmllciBTZXF1ZW5jZUZlYXR1cmUuc3ltYm9sXCIgXG5cdCAgICBjb25zdHJhaW50TG9naWM9XCJBIGFuZCBCIGFuZCBDXCI+XG5cdFx0PGNvbnN0cmFpbnQgY29kZT1cIkFcIiBwYXRoPVwiU2VxdWVuY2VGZWF0dXJlXCIgb3A9XCJMT09LVVBcIiB2YWx1ZT1cIiR7cXJ5U3RyaW5nfVwiLz5cblx0XHQ8Y29uc3RyYWludCBjb2RlPVwiQlwiIHBhdGg9XCJTZXF1ZW5jZUZlYXR1cmUub3JnYW5pc20udGF4b25JZFwiIG9wPVwiPVwiIHZhbHVlPVwiMTAwOTBcIi8+XG5cdFx0PGNvbnN0cmFpbnQgY29kZT1cIkNcIiBwYXRoPVwiU2VxdWVuY2VGZWF0dXJlLnNlcXVlbmNlT250b2xvZ3lUZXJtLm5hbWVcIiBvcD1cIiE9XCIgdmFsdWU9XCJ0cmFuc2dlbmVcIi8+XG5cdCAgICA8L3F1ZXJ5PmA7XG5cdHJldHVybiB0aGlzLmdldEF1eERhdGEocSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZlYXR1cmVzQnlPbnRvbG9neVRlcm0gKHFyeVN0cmluZywgdGVybVR5cGVzKSB7XG5cdHFyeVN0cmluZyA9IHRoaXMuYWRkV2lsZGNhcmRzKHFyeVN0cmluZyk7XG4gICAgICAgIGxldCBxID0gYDxxdWVyeSBuYW1lPVwiXCIgbW9kZWw9XCJnZW5vbWljXCIgXG5cdCAgdmlldz1cIlNlcXVlbmNlRmVhdHVyZS5wcmltYXJ5SWRlbnRpZmllciBTZXF1ZW5jZUZlYXR1cmUuc3ltYm9sXCIgY29uc3RyYWludExvZ2ljPVwiQSBhbmQgQiBhbmQgQyBhbmQgRFwiPlxuXHQgICAgICA8Y29uc3RyYWludCBjb2RlPVwiQVwiIHBhdGg9XCJTZXF1ZW5jZUZlYXR1cmUub250b2xvZ3lBbm5vdGF0aW9ucy5vbnRvbG9neVRlcm0ucGFyZW50c1wiIG9wPVwiTE9PS1VQXCIgdmFsdWU9XCIke3FyeVN0cmluZ31cIi8+XG5cdCAgICAgIDxjb25zdHJhaW50IGNvZGU9XCJCXCIgcGF0aD1cIlNlcXVlbmNlRmVhdHVyZS5vcmdhbmlzbS50YXhvbklkXCIgb3A9XCI9XCIgdmFsdWU9XCIxMDA5MFwiLz5cblx0ICAgICAgPGNvbnN0cmFpbnQgY29kZT1cIkNcIiBwYXRoPVwiU2VxdWVuY2VGZWF0dXJlLnNlcXVlbmNlT250b2xvZ3lUZXJtLm5hbWVcIiBvcD1cIiE9XCIgdmFsdWU9XCJ0cmFuc2dlbmVcIi8+XG5cdCAgICAgIDxjb25zdHJhaW50IGNvZGU9XCJEXCIgcGF0aD1cIlNlcXVlbmNlRmVhdHVyZS5vbnRvbG9neUFubm90YXRpb25zLm9udG9sb2d5VGVybS5vbnRvbG9neS5uYW1lXCIgb3A9XCJPTkUgT0ZcIj5cblx0XHQgICR7IHRlcm1UeXBlcy5tYXAodHQ9PiAnPHZhbHVlPicrdHQrJzwvdmFsdWU+Jykuam9pbignJykgfVxuXHQgICAgICA8L2NvbnN0cmFpbnQ+XG5cdCAgPC9xdWVyeT5gXG5cdHJldHVybiB0aGlzLmdldEF1eERhdGEocSk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZlYXR1cmVzQnlQYXRod2F5VGVybSAocXJ5U3RyaW5nKSB7XG5cdHFyeVN0cmluZyA9IHRoaXMuYWRkV2lsZGNhcmRzKHFyeVN0cmluZyk7XG4gICAgICAgIGxldCBxID0gYDxxdWVyeSBuYW1lPVwiXCIgbW9kZWw9XCJnZW5vbWljXCIgXG5cdCAgdmlldz1cIkdlbmUucHJpbWFyeUlkZW50aWZpZXIgR2VuZS5zeW1ib2xcIiBjb25zdHJhaW50TG9naWM9XCJBIGFuZCBCXCI+XG5cdCAgICAgIDxjb25zdHJhaW50IHBhdGg9XCJHZW5lLnBhdGh3YXlzXCIgY29kZT1cIkFcIiBvcD1cIkxPT0tVUFwiIHZhbHVlPVwiJHtxcnlTdHJpbmd9XCIvPlxuXHQgICAgICA8Y29uc3RyYWludCBwYXRoPVwiR2VuZS5vcmdhbmlzbS50YXhvbklkXCIgY29kZT1cIkJcIiBvcD1cIj1cIiB2YWx1ZT1cIjEwMDkwXCIvPlxuXHQgIDwvcXVlcnk+YDtcblx0cmV0dXJuIHRoaXMuZ2V0QXV4RGF0YShxKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZmVhdHVyZXNCeUlkICAgICAgICAocXJ5U3RyaW5nKSB7IHJldHVybiB0aGlzLmZlYXR1cmVzQnlMb29rdXAocXJ5U3RyaW5nKTsgfVxuICAgIGZlYXR1cmVzQnlGdW5jdGlvbiAgKHFyeVN0cmluZykgeyByZXR1cm4gdGhpcy5mZWF0dXJlc0J5T250b2xvZ3lUZXJtKHFyeVN0cmluZywgW1wiR2VuZSBPbnRvbG9neVwiXSk7IH1cbiAgICBmZWF0dXJlc0J5UGhlbm90eXBlIChxcnlTdHJpbmcpIHsgcmV0dXJuIHRoaXMuZmVhdHVyZXNCeU9udG9sb2d5VGVybShxcnlTdHJpbmcsIFtcIk1hbW1hbGlhbiBQaGVub3R5cGVcIixcIkRpc2Vhc2UgT250b2xvZ3lcIl0pOyB9XG4gICAgZmVhdHVyZXNCeVBhdGh3YXkgICAocXJ5U3RyaW5nKSB7IHJldHVybiB0aGlzLmZlYXR1cmVzQnlQYXRod2F5VGVybShxcnlTdHJpbmcpOyB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgZm9yIGFsbCBleG9ucyBvZiBmZWF0dXJlcyBvdmVybGFwcGluZyBhIHNwZWNpZmllZCByYW5nZSBpbiB0aGUgc3BlY2lmZWQgZ2Vub21lLlxuICAgIGV4b25WaWV3ICgpIHtcblx0cmV0dXJuIFtcblx0ICAgICdFeG9uLmdlbmUuY2Fub25pY2FsLnByaW1hcnlJZGVudGlmaWVyJyxcblx0ICAgICdFeG9uLmdlbmUucHJpbWFyeUlkZW50aWZpZXInLFxuXHQgICAgJ0V4b24udHJhbnNjcmlwdHMucHJpbWFyeUlkZW50aWZpZXInLFxuXHQgICAgJ0V4b24ucHJpbWFyeUlkZW50aWZpZXInLFxuXHQgICAgJ0V4b24uY2hyb21vc29tZS5wcmltYXJ5SWRlbnRpZmllcicsXG5cdCAgICAnRXhvbi5jaHJvbW9zb21lTG9jYXRpb24uc3RhcnQnLFxuXHQgICAgJ0V4b24uY2hyb21vc29tZUxvY2F0aW9uLmVuZCcsXG5cdCAgICAnRXhvbi5zdHJhaW4ubmFtZSdcblx0XS5qb2luKCcgJyk7XG4gICAgfVxuICAgIC8vXG4gICAgc2VxdWVuY2VTbGljZSAoZ2Vub21lLCBjaHIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgICAgbGV0IHEgPSBgIDxxdWVyeSBtb2RlbD1cImdlbm9taWNcIlxuXHQgICAgdmlldz1cIkNocm9tb3NvbWUuc2VxdWVuY2UucmVzaWR1ZXNcIj5cblx0ICAgIDxjb25zdHJhaW50IHBhdGg9XCJDaHJvbW9zb21lLnByaW1hcnlJZGVudGlmaWVyXCIgb3A9XCI9XCIgdmFsdWU9XCIke2Nocn1cIiAvPlxuXHQgICAgPGNvbnN0cmFpbnQgcGF0aD1cIkNocm9tb3NvbWUuc3RyYWluLm5hbWVcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7Z2Vub21lfVwiIC8+XG5cdCAgICA8L3F1ZXJ5PmBcblx0bGV0IHF1ZXJ5ID0gZW5jb2RlVVJJQ29tcG9uZW50KHEpO1xuXHQvLyBGSVhNRTogV2VpcmQuIFRoaXMgd2ViIHNlcnZpY2UgYXBwZWFycyB0byB1c2UgMC1iYXNlZCBjb29yZGluYXRlcywgYW5kIHdhbnQgZW5kIHRvIGJlIDEgYmV5b25kIHRoZSBcblx0Ly8gbGFzdCBiYXNlIHlvdSB3YW50IHJldHVybmVkLiBIYXZlIHRvIGNvbnZlcnQgZnJvbSBub3JtYWwgZ2Vub21lIGNvb3JkaW5hdGVzLlxuXHRsZXQgdXJsID0gdGhpcy5zZXFTbGljZVVybCArIGBzdGFydD0ke3N0YXJ0LTF9JmVuZD0ke2VuZH0mcXVlcnk9JHtxdWVyeX1gO1xuXHRyZXR1cm4gZDNqc29uKHVybCkudGhlbihkYXRhID0+IHtcblx0ICAgIGxldCByZXN1bHQgPSBkYXRhLmZlYXR1cmVzWzBdXG5cdCAgICByZXN1bHQuZ2Vub21lID0gZ2Vub21lO1xuXHQgICAgcmVzdWx0LmNociA9IGNocjtcblx0ICAgIHJldHVybiByZXN1bHQ7XG5cdH0pO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYWxsIGV4b25zIGZyb20gdGhlIGdpdmVuIGdlbm9tZSB3aGVyZSB0aGUgZXhvbidzIGdlbmUgb3ZlcmxhcHMgdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICAgIGV4b25zQnlSYW5nZVx0KGdlbm9tZSwgY2hyLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIGxldCBxID0gYDxxdWVyeSBtb2RlbD1cImdlbm9taWNcIiB2aWV3PVwiJHt0aGlzLmV4b25WaWV3KCl9XCIgY29uc3RyYWludExvZ2ljPVwiQSBhbmQgQlwiPlxuXHQgICAgPGNvbnN0cmFpbnQgY29kZT1cIkFcIiBwYXRoPVwiRXhvbi5nZW5lLmNocm9tb3NvbWVMb2NhdGlvblwiIG9wPVwiT1ZFUkxBUFNcIj5cblx0XHQ8dmFsdWU+JHtjaHJ9OiR7c3RhcnR9Li4ke2VuZH08L3ZhbHVlPlxuXHQgICAgPC9jb25zdHJhaW50PlxuXHQgICAgPGNvbnN0cmFpbnQgY29kZT1cIkJcIiBwYXRoPVwiRXhvbi5zdHJhaW4ubmFtZVwiIG9wPVwiPVwiIHZhbHVlPVwiJHtnZW5vbWV9XCIvPlxuXHQgICAgPC9xdWVyeT5gXG5cdHJldHVybiB0aGlzLmdldEF1eERhdGEocSk7XG4gICAgfVxuICAgIC8vIFJldHVybnMgYSBwcm9taXNlIGZvciBhbGwgZXhvbnMgb2YgYWxsIGdlbm9sb2dzIG9mIHRoZSBzcGVjaWZpZWQgY2Fub25pY2FsIGdlbmVcbiAgICBleG9uc0J5Q2Fub25pY2FsSWRcdChpZGVudCkge1xuICAgICAgICBsZXQgcSA9IGA8cXVlcnkgbW9kZWw9XCJnZW5vbWljXCIgdmlldz1cIiR7dGhpcy5leG9uVmlldygpfVwiID5cblx0ICAgIDxjb25zdHJhaW50IGNvZGU9XCJBXCIgcGF0aD1cIkV4b24uZ2VuZS5jYW5vbmljYWwucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIgLz5cblx0ICAgIDwvcXVlcnk+YFxuXHRyZXR1cm4gdGhpcy5nZXRBdXhEYXRhKHEpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYWxsIGV4b25zIG9mIHRoZSBzcGVjaWZpZWQgZ2VuZS5cbiAgICBleG9uc0J5R2VuZUlkXHQoaWRlbnQpIHtcbiAgICAgICAgbGV0IHEgPSBgPHF1ZXJ5IG1vZGVsPVwiZ2Vub21pY1wiIHZpZXc9XCIke3RoaXMuZXhvblZpZXcoKX1cIiA+XG5cdCAgICA8Y29uc3RyYWludCBjb2RlPVwiQVwiIHBhdGg9XCJFeG9uLmdlbmUucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIgLz5cblx0ICAgIDwvcXVlcnk+YFxuXHRyZXR1cm4gdGhpcy5nZXRBdXhEYXRhKHEpO1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIGEgcHJvbWlzZSBmb3IgYWxsIGV4b25zIG9mIHRoZSBzcGVjaWZpZWQgZ2VuZS5cbiAgICBleG9uc0J5R2VuZUlkc1x0KGlkZW50cykge1xuXHRsZXQgdmFscyA9IGlkZW50cy5tYXAoaSA9PiBgPHZhbHVlPiR7aX08L3ZhbHVlPmApLmpvaW4oJycpO1xuICAgICAgICBsZXQgcSA9IGA8cXVlcnkgbW9kZWw9XCJnZW5vbWljXCIgdmlldz1cIiR7dGhpcy5leG9uVmlldygpfVwiID5cblx0ICAgIDxjb25zdHJhaW50IGNvZGU9XCJBXCIgcGF0aD1cIkV4b24uZ2VuZS5wcmltYXJ5SWRlbnRpZmllclwiIG9wPVwiT05FIE9GXCI+JHt2YWxzfTwvY29uc3RyYWludD5cblx0ICAgIDwvcXVlcnk+YFxuXHRyZXR1cm4gdGhpcy5nZXRBdXhEYXRhKHEpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RzIGEgVVJMIGZvciBsaW5raW5nIHRvIGEgTW91c2VNaW5lIHJlcG9ydCBwYWdlIGJ5IGlkXG4gICAgbGlua1RvUmVwb3J0UGFnZSAoaWRlbnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuclVybCArIGlkZW50O1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBDb25zdHJ1Y3RzIGEgVVJMIHRvIHJldHJpZXZlIG1vdXNlIHNlcXVlbmNlcyBvZiB0aGUgc3BlY2lmaWVkIHR5cGUgZm9yIHRoZSBzcGVjaWZpZWQgZmVhdHVyZS5cbiAgICBzZXF1ZW5jZXNGb3JGZWF0dXJlIChmLCB0eXBlLCBnZW5vbWVzKSB7XG5cdGxldCBxO1xuXHRsZXQgdXJsO1xuXHRsZXQgdmlldztcblx0bGV0IGlkZW50O1xuICAgICAgICAvL1xuXHR0eXBlID0gdHlwZSA/IHR5cGUudG9Mb3dlckNhc2UoKSA6ICdnZW5vbWljJztcblx0Ly9cblx0aWYgKGYuY2Fub25pY2FsKSB7XG5cdCAgICBpZGVudCA9IGYuY2Fub25pY2FsXG5cdCAgICAvL1xuXHQgICAgbGV0IGdzID0gJydcblx0ICAgIGxldCB2YWxzO1xuXHQgICAgaWYgKGdlbm9tZXMpIHtcblx0XHR2YWxzID0gZ2Vub21lcy5tYXAoKGcpID0+IGA8dmFsdWU+JHtnfTwvdmFsdWU+YCkuam9pbignJyk7XG5cdCAgICB9XG5cdCAgICBzd2l0Y2ggKHR5cGUpIHtcblx0ICAgIGNhc2UgJ2dlbm9taWMnOlxuXHRcdHZpZXcgPSAnR2VuZS5jYW5vbmljYWwucHJpbWFyeUlkZW50aWZpZXInO1xuXHRcdGdzID0gYDxjb25zdHJhaW50IHBhdGg9XCJHZW5lLnN0cmFpbi5uYW1lXCIgb3A9XCJPTkUgT0ZcIj4ke3ZhbHN9PC9jb25zdHJhaW50PmBcblx0XHRxID0gYDxxdWVyeSBuYW1lPVwic2VxdWVuY2VzQnlDYW5vbmljYWxJZFwiIG1vZGVsPVwiZ2Vub21pY1wiIHZpZXc9XCJHZW5lLnByaW1hcnlJZGVudGlmaWVyXCIgPlxuXHRcdCAgICA8Y29uc3RyYWludCBwYXRoPVwiR2VuZS5jYW5vbmljYWwucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIvPlxuXHRcdCAgICAke2dzfTwvcXVlcnk+YDtcblx0XHRicmVhaztcblxuICAgICAgICAgICAgY2FzZSAndHJhbnNjcmlwdCc6XG5cdFx0dmlldyA9ICdUcmFuc2NyaXB0LmdlbmUuY2Fub25pY2FsLnByaW1hcnlJZGVudGlmaWVyJztcblx0XHRncyA9IGA8Y29uc3RyYWludCBwYXRoPVwiVHJhbnNjcmlwdC5zdHJhaW4ubmFtZVwiIG9wPVwiT05FIE9GXCI+JHt2YWxzfTwvY29uc3RyYWludD5gXG5cdFx0cSA9IGA8cXVlcnkgbmFtZT1cInRyYW5zY3JpcHRTZXF1ZW5jZXNCeUNhbm9uaWNhbElkXCIgbW9kZWw9XCJnZW5vbWljXCIgdmlldz1cIlRyYW5zY3JpcHQucHJpbWFyeUlkZW50aWZpZXJcIiA+XG5cdFx0ICAgIDxjb25zdHJhaW50IHBhdGg9XCJUcmFuc2NyaXB0LmdlbmUuY2Fub25pY2FsLnByaW1hcnlJZGVudGlmaWVyXCIgb3A9XCI9XCIgdmFsdWU9XCIke2lkZW50fVwiLz5cblx0XHQgICAgJHtnc308L3F1ZXJ5PmA7XG5cdCAgICAgICAgYnJlYWs7XG5cblx0ICAgIGNhc2UgJ2V4b24nOlxuXHRcdHZpZXcgPSAnRXhvbi5nZW5lLmNhbm9uaWNhbC5wcmltYXJ5SWRlbnRpZmllcic7XG5cdFx0Z3MgPSBgPGNvbnN0cmFpbnQgcGF0aD1cIkV4b24uc3RyYWluLm5hbWVcIiBvcD1cIk9ORSBPRlwiPiR7dmFsc308L2NvbnN0cmFpbnQ+YFxuXHRcdHEgPSBgPHF1ZXJ5IG5hbWU9XCJleG9uU2VxdWVuY2VzQnlDYW5vbmljYWxJZFwiIG1vZGVsPVwiZ2Vub21pY1wiIHZpZXc9XCJFeG9uLnByaW1hcnlJZGVudGlmaWVyXCIgPlxuXHRcdCAgICA8Y29uc3RyYWludCBwYXRoPVwiRXhvbi5nZW5lLmNhbm9uaWNhbC5wcmltYXJ5SWRlbnRpZmllclwiIG9wPVwiPVwiIHZhbHVlPVwiJHtpZGVudH1cIi8+XG5cdFx0ICAgICR7Z3N9PC9xdWVyeT5gO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSAnY2RzJzpcblx0XHR2aWV3ID0gJ0NEUy5nZW5lLmNhbm9uaWNhbC5wcmltYXJ5SWRlbnRpZmllcic7XG5cdFx0Z3MgPSBgPGNvbnN0cmFpbnQgcGF0aD1cIkNEUy5zdHJhaW4ubmFtZVwiIG9wPVwiT05FIE9GXCI+JHt2YWxzfTwvY29uc3RyYWludD5gXG5cdFx0cSA9IGA8cXVlcnkgbmFtZT1cImNkc1NlcXVlbmNlc0J5Q2Fub25pY2FsSWRcIiBtb2RlbD1cImdlbm9taWNcIiB2aWV3PVwiQ0RTLnByaW1hcnlJZGVudGlmaWVyXCIgPlxuXHRcdCAgICA8Y29uc3RyYWludCBwYXRoPVwiQ0RTLmdlbmUuY2Fub25pY2FsLnByaW1hcnlJZGVudGlmaWVyXCIgb3A9XCI9XCIgdmFsdWU9XCIke2lkZW50fVwiLz5cblx0XHQgICAgJHtnc308L3F1ZXJ5PmA7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdH1cblx0ZWxzZSB7XG5cdCAgICBpZGVudCA9IGYuSUQ7XG5cdCAgICB2aWV3ID0gJydcblx0ICAgIHN3aXRjaCAodHlwZSkge1xuXHQgICAgY2FzZSAnZ2Vub21pYyc6XG5cdFx0cSA9IGA8cXVlcnkgbmFtZT1cInNlcXVlbmNlc0J5SWRcIiBtb2RlbD1cImdlbm9taWNcIiB2aWV3PVwiR2VuZS5wcmltYXJ5SWRlbnRpZmllclwiID5cblx0XHQgICAgPGNvbnN0cmFpbnQgcGF0aD1cIkdlbmUucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIvPlxuXHRcdCAgPC9xdWVyeT5gO1xuXHRcdGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAndHJhbnNjcmlwdCc6XG5cdFx0cSA9IGA8cXVlcnkgbmFtZT1cInRyYW5zY3JpcHRTZXF1ZW5jZXNCeUlkXCIgbW9kZWw9XCJnZW5vbWljXCIgdmlldz1cIlRyYW5zY3JpcHQucHJpbWFyeUlkZW50aWZpZXJcIiA+XG5cdFx0ICAgIDxjb25zdHJhaW50IHBhdGg9XCJUcmFuc2NyaXB0LmdlbmUucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIvPlxuXHRcdCAgPC9xdWVyeT5gO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSAnZXhvbic6XG5cdFx0cSA9IGA8cXVlcnkgbmFtZT1cImV4b25TZXF1ZW5jZXNCeUlkXCIgbW9kZWw9XCJnZW5vbWljXCIgdmlldz1cIkV4b24ucHJpbWFyeUlkZW50aWZpZXJcIiA+XG5cdFx0ICAgIDxjb25zdHJhaW50IHBhdGg9XCJFeG9uLmdlbmUucHJpbWFyeUlkZW50aWZpZXJcIiBvcD1cIj1cIiB2YWx1ZT1cIiR7aWRlbnR9XCIvPlxuXHRcdCAgPC9xdWVyeT5gO1xuXHQgICAgICAgIGJyZWFrO1xuXHQgICAgY2FzZSAnY2RzJzpcblx0XHRxID0gYDxxdWVyeSBuYW1lPVwiY2RzU2VxdWVuY2VzQnlJZFwiIG1vZGVsPVwiZ2Vub21pY1wiIHZpZXc9XCJDRFMucHJpbWFyeUlkZW50aWZpZXJcIiA+XG5cdFx0ICAgIDxjb25zdHJhaW50IHBhdGg9XCJDRFMuZ2VuZS5wcmltYXJ5SWRlbnRpZmllclwiIG9wPVwiPVwiIHZhbHVlPVwiJHtpZGVudH1cIi8+XG5cdFx0ICA8L3F1ZXJ5PmA7XG5cdCAgICAgICAgYnJlYWs7XG5cdCAgICB9XG5cdH1cblx0aWYgKCFxKSByZXR1cm4gbnVsbDtcblx0Y29uc29sZS5sb2cocSwgdmlldyk7XG5cdHVybCA9IHRoaXMuZmFVcmwgKyBgcXVlcnk9JHtlbmNvZGVVUklDb21wb25lbnQocSl9YDtcblx0aWYgKHZpZXcpXG4gICAgICAgICAgICB1cmwgKz0gYCZ2aWV3PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZpZXcpfWA7XG5cdHJldHVybiB1cmw7XG4gICAgfVxufVxuXG5leHBvcnQgeyBBdXhEYXRhTWFuYWdlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvQXV4RGF0YU1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE0XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJy4vQ29tcG9uZW50JztcbmltcG9ydCB7IExpc3RGb3JtdWxhRXZhbHVhdG9yIH0gZnJvbSAnLi9MaXN0Rm9ybXVsYUV2YWx1YXRvcic7XG5pbXBvcnQgeyBLZXlTdG9yZSB9IGZyb20gJy4vS2V5U3RvcmUnO1xuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIE1haW50YWlucyBuYW1lZCBsaXN0cyBvZiBJRHMuIExpc3RzIG1heSBiZSB0ZW1wb3JhcnksIGxhc3Rpbmcgb25seSBmb3IgdGhlIHNlc3Npb24sIG9yIHBlcm1hbmVudCxcbi8vIGxhc3RpbmcgdW50aWwgdGhlIHVzZXIgY2xlYXJzIHRoZSBicm93c2VyIGxvY2FsIHN0b3JhZ2UgYXJlYS5cbi8vXG4vLyBVc2VzIHdpbmRvdy5zZXNzaW9uU3RvcmFnZSBhbmQgd2luZG93LmxvY2FsU3RvcmFnZSB0byBzYXZlIGxpc3RzXG4vLyB0ZW1wb3JhcmlseSBvciBwZXJtYW5lbnRseSwgcmVzcC4gIEZJWE1FOiBzaG91bGQgYmUgdXNpbmcgd2luZG93LmluZGV4ZWREQlxuLy9cbmNsYXNzIExpc3RNYW5hZ2VyIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAoYXBwLCBlbHQpIHtcbiAgICAgICAgc3VwZXIoYXBwLCBlbHQpO1xuXHR0aGlzLm5hbWUybGlzdCA9IG51bGw7XG5cdHRoaXMubGlzdFN0b3JlID0gbmV3IEtleVN0b3JlKCd1c2VyLWxpc3RzJyk7XG5cdHRoaXMuZm9ybXVsYUV2YWwgPSBuZXcgTGlzdEZvcm11bGFFdmFsdWF0b3IodGhpcyk7XG5cdHRoaXMucmVhZHkgPSB0aGlzLl9sb2FkKCkudGhlbiggKCk9PnRoaXMuaW5pdERvbSgpICk7XG4gICAgfVxuICAgIGluaXREb20gKCkge1xuXHQvLyBCdXR0b246IHNob3cvaGlkZSB3YXJuaW5nIG1lc3NhZ2Vcblx0dGhpcy5yb290LnNlbGVjdCgnLmJ1dHRvbi53YXJuaW5nJylcblx0ICAgIC5vbignY2xpY2snLCAoKSA9PiB7XG5cdCAgICAgICAgbGV0IHcgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cIm1lc3NhZ2VcIl0nKTtcblx0XHR3LmNsYXNzZWQoJ3Nob3dpbmcnLCAhdy5jbGFzc2VkKCdzaG93aW5nJykpO1xuXHQgICAgfSk7XG5cdC8vIEJ1dHRvbjogY3JlYXRlIGxpc3QgZnJvbSBjdXJyZW50IHNlbGVjdGlvblxuXHR0aGlzLnJvb3Quc2VsZWN0KCcuYnV0dG9uW25hbWU9XCJuZXdmcm9tc2VsZWN0aW9uXCJdJylcblx0ICAgIC5vbihcImNsaWNrXCIsICgpID0+IHtcblx0XHRsZXQgaWRzID0gbmV3IFNldChPYmplY3Qua2V5cyh0aGlzLmFwcC56b29tVmlldy5oaUZlYXRzKSk7IC8vIEZJWE1FIC0gcmVhY2hvdmVyXG5cdFx0bGV0IGxzdCA9IHRoaXMuYXBwLmdldEN1cnJlbnRMaXN0KCk7XG5cdFx0aWYgKGxzdClcblx0XHQgICAgaWRzID0gaWRzLnVuaW9uKGxzdC5pZHMpO1xuXHRcdGlmIChpZHMuc2l6ZSA9PT0gMCkge1xuXHRcdCAgICBhbGVydChcIk5vdGhpbmcgc2VsZWN0ZWQuXCIpO1xuXHRcdCAgICByZXR1cm47XG5cdFx0fVxuXHRcdGxldCBuZXdsaXN0ID0gdGhpcy5jcmVhdGVMaXN0KFwic2VsZWN0aW9uXCIsIEFycmF5LmZyb20oaWRzKSk7XG5cdFx0dGhpcy51cGRhdGUobmV3bGlzdCk7XG5cdCAgICB9KTtcblxuXHQvLyBCdXR0b246IGNvbWJpbmUgbGlzdHM6IG9wZW4gbGlzdCBlZGl0b3Igd2l0aCBmb3JtdWxhIGVkaXRvciBvcGVuXG5cdHRoaXMucm9vdC5zZWxlY3QoJy5idXR0b25bbmFtZT1cImNvbWJpbmVcIl0nKVxuXHQgICAgLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xuXHRcdGlmICh0aGlzLmdldE5hbWVzKCkubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgIGFsZXJ0KFwiTm8gbGlzdHMuXCIpO1xuXHRcdCAgICByZXR1cm47XG5cdFx0fVxuXHRcdGxldCBsZSA9IHRoaXMuYXBwLmxpc3RFZGl0b3I7XG5cdFx0bGUub3BlbigpO1xuXHRcdGxlLm9wZW5Gb3JtdWxhRWRpdG9yKCk7XG5cdCAgICB9KTtcblx0Ly8gQnV0dG9uOiBkZWxldGUgYWxsIGxpc3RzIChnZXQgY29uZmlybWF0aW9uIGZpcnN0KS5cblx0dGhpcy5yb290LnNlbGVjdCgnLmJ1dHRvbltuYW1lPVwicHVyZ2VcIl0nKVxuXHQgICAgLm9uKFwiY2xpY2tcIiwgKCkgPT4ge1xuXHRcdGlmICh0aGlzLmdldE5hbWVzKCkubGVuZ3RoID09PSAwKSB7XG5cdFx0ICAgIGFsZXJ0KFwiTm8gbGlzdHMuXCIpO1xuXHRcdCAgICByZXR1cm47XG5cdFx0fVxuXHQgICAgICAgIGlmICh3aW5kb3cuY29uZmlybShcIkRlbGV0ZSBhbGwgbGlzdHMuIEFyZSB5b3Ugc3VyZT9cIikpIHtcblx0XHQgICAgdGhpcy5wdXJnZSgpO1xuXHRcdCAgICB0aGlzLnVwZGF0ZSgpO1xuXHRcdH1cblx0ICAgIH0pO1xuICAgIH1cbiAgICBfbG9hZCAoKSB7XG5cdHJldHVybiB0aGlzLmxpc3RTdG9yZS5nZXQoXCJhbGxcIikudGhlbihhbGwgPT4ge1xuXHQgICAgdGhpcy5uYW1lMmxpc3QgPSBhbGwgfHwge307XG5cdH0pO1xuICAgIH1cbiAgICBfc2F2ZSAoKSB7XG5cdHJldHVybiB0aGlzLmxpc3RTdG9yZS5zZXQoXCJhbGxcIiwgdGhpcy5uYW1lMmxpc3QpXG4gICAgfVxuICAgIC8vXG4gICAgLy8gcmV0dXJucyB0aGUgbmFtZXMgb2YgYWxsIHRoZSBsaXN0cywgc29ydGVkXG4gICAgZ2V0TmFtZXMgKCkge1xuICAgICAgICBsZXQgbm1zID0gT2JqZWN0LmtleXModGhpcy5uYW1lMmxpc3QpO1xuXHRubXMuc29ydCgpO1xuXHRyZXR1cm4gbm1zO1xuICAgIH1cbiAgICAvLyByZXR1cm5zIHRydWUgaWZmIGEgbGlzdCBleGlzdHMgd2l0aCB0aGlzIG5hbWVcbiAgICBoYXMgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5hbWUgaW4gdGhpcy5uYW1lMmxpc3Q7XG4gICAgfVxuICAgIC8vIElmIG5vIGxpc3Qgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBleGlzdHMsIHJldHVybiB0aGUgbmFtZS5cbiAgICAvLyBPdGhlcndpc2UsIHJldHVybiBhIG1vZGlmaWVkIHZlcnNpb24gb2YgbmFtZSB0aGF0IGlzIHVuaXF1ZS5cbiAgICAvLyBVbmlxdWUgbmFtZXMgYXJlIGNyZWF0ZWQgYnkgYXBwZW5kaW5nIGEgY291bnRlci5cbiAgICAvLyBFLmcuLCB1bmlxdWlmeShcImZvb1wiKSAtPiBcImZvby4xXCIgb3IgXCJmb28uMlwiIG9yIHdoYXRldmVyLlxuICAgIC8vXG4gICAgdW5pcXVpZnkgKG5hbWUpIHtcblx0aWYgKCF0aGlzLmhhcyhuYW1lKSkgXG5cdCAgICByZXR1cm4gbmFtZTtcblx0Zm9yIChsZXQgaSA9IDE7IDsgaSArPSAxKSB7XG5cdCAgICBsZXQgbm4gPSBgJHtuYW1lfS4ke2l9YDtcblx0ICAgIGlmICghdGhpcy5oYXMobm4pKVxuXHQgICAgICAgIHJldHVybiBubjtcblx0fVxuICAgIH1cbiAgICAvLyByZXR1cm5zIHRoZSBsaXN0IHdpdGggdGhpcyBuYW1lLCBvciBudWxsIGlmIG5vIHN1Y2ggbGlzdFxuICAgIGdldCAobmFtZSkge1xuICAgICAgICBsZXQgbHN0ID0gdGhpcy5uYW1lMmxpc3RbbmFtZV07XG5cdGlmICghbHN0KSB0aHJvdyBcIk5vIHN1Y2ggbGlzdDogXCIgKyBuYW1lO1xuXHRyZXR1cm4gbHN0O1xuICAgIH1cbiAgICAvLyByZXR1cm5zIGFsbCB0aGUgbGlzdHMsIHNvcnRlZCBieSBuYW1lXG4gICAgZ2V0QWxsICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0TmFtZXMoKS5tYXAobiA9PiB0aGlzLmdldChuKSlcbiAgICB9XG4gICAgLy8gXG4gICAgY3JlYXRlT3JVcGRhdGUgKG5hbWUsIGlkcykge1xuICAgICAgICByZXR1cm4gdGhpcy5oYXMobmFtZSkgPyB0aGlzLnVwZGF0ZUxpc3QobmFtZSxudWxsLGlkcykgOiB0aGlzLmNyZWF0ZUxpc3QobmFtZSwgaWRzKTtcbiAgICB9XG4gICAgLy8gY3JlYXRlcyBhIG5ldyBsaXN0IHdpdGggdGhlIGdpdmVuIG5hbWUgYW5kIGlkcy5cbiAgICBjcmVhdGVMaXN0IChuYW1lLCBpZHMsIGZvcm11bGEpIHtcblx0aWYgKG5hbWUgIT09IFwiX1wiKVxuXHQgICAgbmFtZSA9IHRoaXMudW5pcXVpZnkobmFtZSk7XG5cdC8vXG5cdGxldCBkdCA9IG5ldyBEYXRlKCkgKyBcIlwiO1xuXHR0aGlzLm5hbWUybGlzdFtuYW1lXSA9IHtcblx0ICAgIG5hbWU6ICAgICBuYW1lLFxuXHQgICAgaWRzOiAgICAgIGlkcyxcblx0ICAgIGZvcm11bGE6ICBmb3JtdWxhIHx8IFwiXCIsXG5cdCAgICBjcmVhdGVkOiAgZHQsXG5cdCAgICBtb2RpZmllZDogZHRcblx0fTtcblx0dGhpcy5fc2F2ZSgpO1xuXHRyZXR1cm4gdGhpcy5uYW1lMmxpc3RbbmFtZV07XG4gICAgfVxuICAgIC8vIFByb3ZpZGUgYWNjZXNzIHRvIGV2YWx1YXRpb24gc2VydmljZVxuICAgIGV2YWxGb3JtdWxhIChleHByKSB7XG5cdHJldHVybiB0aGlzLmZvcm11bGFFdmFsLmV2YWwoZXhwcik7XG4gICAgfVxuICAgIC8vIFJlZnJlc2hlcyBhIGxpc3QgYW5kIHJldHVybnMgYSBwcm9taXNlIGZvciB0aGUgcmVmcmVzaGVkIGxpc3QuXG4gICAgLy8gSWYgdGhlIGxpc3QgaWYgYSBQT0xPLCBwcm9taXNlIHJlc29sdmVzIGltbWVkaWF0ZWx5IHRvIHRoZSBsaXN0LlxuICAgIC8vIE90aGVyd2lzZSwgc3RhcnRzIGEgcmVldmFsdWF0aW9uIG9mIHRoZSBmb3JtdWxhIHRoYXQgcmVzb2x2ZXMgYWZ0ZXIgdGhlXG4gICAgLy8gbGlzdCdzIGlkcyBoYXZlIGJlZW4gdXBkYXRlZC5cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciwgdGhlIHJldHVybmVkIHByb21pc2UgcmVqZWN0cyB3aXRoIHRoZSBlcnJvci5cbiAgICByZWZyZXNoTGlzdCAobmFtZSkge1xuICAgICAgICBsZXQgbHN0ID0gdGhpcy5nZXQobmFtZSk7XG5cdGlmICghbHN0KSB0aHJvdyBcIk5vIHN1Y2ggbGlzdDogXCIgKyBuYW1lO1xuXHRsc3QubW9kaWZpZWQgPSBcIlwiK25ldyBEYXRlKCk7XG5cdGlmICghbHN0LmZvcm11bGEpXG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGxzdCk7XG5cdGVsc2Uge1xuXHQgICAgbGV0IHAgPSB0aGlzLmZvcm11YWxFdmFsLmV2YWwobHN0LmZvcm11bGEpLnRoZW4oIGlkcyA9PiB7XG5cdFx0ICAgIGxzdC5pZHMgPSBpZHM7XG5cdFx0ICAgIHJldHVybiBsc3Q7XG5cdFx0fSk7XG5cdCAgICByZXR1cm4gcDtcblx0fVxuICAgIH1cblxuICAgIC8vIHVwZGF0ZXMgdGhlIGlkcyBpbiB0aGUgZ2l2ZW4gbGlzdFxuICAgIHVwZGF0ZUxpc3QgKG5hbWUsIG5ld25hbWUsIG5ld2lkcywgbmV3Zm9ybXVsYSkge1xuXHRsZXQgbHN0ID0gdGhpcy5nZXQobmFtZSk7XG4gICAgICAgIGlmICghIGxzdCkgdGhyb3cgXCJObyBzdWNoIGxpc3Q6IFwiICsgbmFtZTtcblx0aWYgKG5ld25hbWUpIHtcblx0ICAgIGRlbGV0ZSB0aGlzLm5hbWUybGlzdFtsc3QubmFtZV07XG5cdCAgICBsc3QubmFtZSA9IHRoaXMudW5pcXVpZnkobmV3bmFtZSk7XG5cdCAgICB0aGlzLm5hbWUybGlzdFtsc3QubmFtZV0gPSBsc3Q7XG5cdH1cblx0aWYgKG5ld2lkcykgbHN0LmlkcyAgPSBuZXdpZHM7XG5cdGlmIChuZXdmb3JtdWxhIHx8IG5ld2Zvcm11bGE9PT1cIlwiKSBsc3QuZm9ybXVsYSA9IG5ld2Zvcm11bGE7XG5cdGxzdC5tb2RpZmllZCA9IG5ldyBEYXRlKCkgKyBcIlwiO1xuXHR0aGlzLl9zYXZlKCk7XG5cdHJldHVybiBsc3Q7XG4gICAgfVxuICAgIC8vIGRlbGV0ZXMgdGhlIHNwZWNpZmllZCBsaXN0XG4gICAgZGVsZXRlTGlzdCAobmFtZSkge1xuICAgICAgICBsZXQgbHN0ID0gdGhpcy5nZXQobmFtZSk7XG5cdGRlbGV0ZSB0aGlzLm5hbWUybGlzdFtuYW1lXTtcblx0dGhpcy5fc2F2ZSgpO1xuXHQvLyBGSVhNRTogdXNlIGV2ZW50cyEhXG5cdGlmIChsc3QgPT09IHRoaXMuYXBwLmdldEN1cnJlbnRMaXN0KCkpIHRoaXMuYXBwLnNldEN1cnJlbnRMaXN0KG51bGwpO1xuXHRpZiAobHN0ID09PSB0aGlzLmFwcC5saXN0RWRpdG9yLmxpc3QpIHRoaXMuYXBwLmxpc3RFZGl0b3IubGlzdCA9IG51bGw7XG5cdHJldHVybiBsc3Q7XG4gICAgfVxuICAgIC8vIGRlbGV0ZSBhbGwgbGlzdHNcbiAgICBwdXJnZSAoKSB7XG4gICAgICAgIHRoaXMubmFtZTJsaXN0ID0ge31cblx0dGhpcy5fc2F2ZSgpO1xuXHQvL1xuXHR0aGlzLmFwcC5zZXRDdXJyZW50TGlzdChudWxsKTtcblx0dGhpcy5hcHAubGlzdEVkaXRvci5saXN0ID0gbnVsbDsgLy8gRklYTUUgLSByZWFjaGFjcm9zc1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRydWUgaWZmIGV4cHIgaXMgdmFsaWQsIHdoaWNoIG1lYW5zIGl0IGlzIGJvdGggc3ludGFjdGljYWxseSBjb3JyZWN0IFxuICAgIC8vIGFuZCBhbGwgbWVudGlvbmVkIGxpc3RzIGV4aXN0LlxuICAgIGlzVmFsaWQgKGV4cHIpIHtcblx0cmV0dXJuIHRoaXMuZm9ybXVsYUV2YWwuaXNWYWxpZChleHByKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVXBkYXRlcyB0aGUgXCJNeSBsaXN0c1wiIGJveCB3aXRoIHRoZSBjdXJyZW50bHkgYXZhaWxhYmxlIGxpc3RzLlxuICAgIC8vIEFyZ3M6XG4gICAgLy8gICBuZXdsaXN0IChMaXN0KSBvcHRpb25hbC4gSWYgc3BlY2lmaWVkLCB3ZSBqdXN0IGNyZWF0ZWQgdGhhdCBsaXN0LCBhbmQgaXRzIG5hbWUgaXNcbiAgICAvLyAgIFx0YSBnZW5lcmF0ZWQgZGVmYXVsdC4gUGxhY2UgZm9jdXMgdGhlcmUgc28gdXNlciBjYW4gdHlwZSBuZXcgbmFtZS5cbiAgICB1cGRhdGUgKG5ld2xpc3QpIHtcblx0bGV0IHNlbGYgPSB0aGlzO1xuICAgICAgICBsZXQgbGlzdHMgPSB0aGlzLmdldEFsbCgpO1xuXHRsZXQgYnlOYW1lID0gKGEsYikgPT4ge1xuXHQgICAgbGV0IGFuID0gYS5uYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBsZXQgYm4gPSBiLm5hbWUudG9Mb3dlckNhc2UoKTtcblx0ICAgIHJldHVybiAoYW4gPCBibiA/IC0xIDogYW4gPiBibiA/ICsxIDogMCk7XG5cdH07XG5cdGxldCBieURhdGUgPSAoYSxiKSA9PiAoKG5ldyBEYXRlKGIubW9kaWZpZWQpKS5nZXRUaW1lKCkgLSAobmV3IERhdGUoYS5tb2RpZmllZCkpLmdldFRpbWUoKSk7XG5cdGxpc3RzLnNvcnQoYnlOYW1lKTtcblx0bGV0IGl0ZW1zID0gdGhpcy5yb290LnNlbGVjdCgnW25hbWU9XCJsaXN0c1wiXScpLnNlbGVjdEFsbChcIi5saXN0SW5mb1wiKVxuXHQgICAgLmRhdGEobGlzdHMpO1xuXHRsZXQgbmV3aXRlbXMgPSBpdGVtcy5lbnRlcigpLmFwcGVuZChcImRpdlwiKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLFwibGlzdEluZm8gZmxleHJvd1wiKTtcblxuXHRuZXdpdGVtcy5hcHBlbmQoXCJpXCIpLmF0dHIoXCJjbGFzc1wiLFwibWF0ZXJpYWwtaWNvbnMgYnV0dG9uXCIpXG5cdCAgICAuYXR0cihcIm5hbWVcIixcImVkaXRcIilcblx0ICAgIC50ZXh0KFwibW9kZV9lZGl0XCIpXG5cdCAgICAuYXR0cihcInRpdGxlXCIsXCJFZGl0IHRoaXMgbGlzdC5cIik7XG5cblx0bmV3aXRlbXMuYXBwZW5kKFwic3BhblwiKS5hdHRyKFwibmFtZVwiLFwibmFtZVwiKTtcblxuXHRuZXdpdGVtcy5hcHBlbmQoXCJzcGFuXCIpLmF0dHIoXCJuYW1lXCIsXCJzaXplXCIpO1xuXHRuZXdpdGVtcy5hcHBlbmQoXCJzcGFuXCIpLmF0dHIoXCJuYW1lXCIsXCJkYXRlXCIpO1xuXG5cdG5ld2l0ZW1zLmFwcGVuZChcImlcIikuYXR0cihcImNsYXNzXCIsXCJtYXRlcmlhbC1pY29ucyBidXR0b25cIilcblx0ICAgIC5hdHRyKFwibmFtZVwiLFwiZGVsZXRlXCIpXG5cdCAgICAudGV4dChcImhpZ2hsaWdodF9vZmZcIilcblx0ICAgIC5hdHRyKFwidGl0bGVcIixcIkRlbGV0ZSB0aGlzIGxpc3QuXCIpO1xuXG5cdGlmIChuZXdpdGVtc1swXVswXSkge1xuXHQgICAgbGV0IGxhc3QgPSBuZXdpdGVtc1swXVtuZXdpdGVtc1swXS5sZW5ndGgtMV07XG5cdCAgICBsYXN0LnNjcm9sbEludG9WaWV3KCk7XG5cdH1cblxuXHRpdGVtc1xuXHQgICAgLmF0dHIoXCJuYW1lXCIsIGxzdD0+bHN0Lm5hbWUpXG5cdCAgICAub24oXCJjbGlja1wiLCBmdW5jdGlvbiAobHN0KSB7XG5cdFx0aWYgKGQzLmV2ZW50LmFsdEtleSkge1xuXHRcdCAgICAvLyBhbHQtY2xpY2sgY29waWVzIHRoZSBsaXN0J3MgbmFtZSBpbnRvIHRoZSBmb3JtdWxhIGVkaXRvclxuXHRcdCAgICBsZXQgbGUgPSBzZWxmLmFwcC5saXN0RWRpdG9yOyAvLyBGSVhNRSByZWFjaG92ZXJcblx0XHQgICAgbGV0IHMgPSBsc3QubmFtZTtcblx0XHQgICAgbGV0IHJlID0gL1sgPSgpKyotXS87XG5cdFx0ICAgIGlmIChzLnNlYXJjaChyZSkgPj0gMClcblx0XHRcdHMgPSAnXCInICsgcyArICdcIic7XG5cdFx0ICAgIGlmICghbGUuaXNFZGl0aW5nRm9ybXVsYSkge1xuXHRcdCAgICAgICAgbGUub3BlbigpO1xuXHRcdFx0bGUub3BlbkZvcm11bGFFZGl0b3IoKTtcblx0XHQgICAgfVxuXHRcdCAgICAvL1xuXHRcdCAgICBsZS5hZGRUb0xpc3RFeHByKHMrJyAnKTtcblx0XHR9XG5cdFx0ZWxzZSBpZiAoZDMuZXZlbnQuc2hpZnRLZXkpIHtcblx0XHQgICAgLy8gc2hpZnQtY2xpY2sgZ29lcyB0byBuZXh0IGxpc3QgZWxlbWVudCBpZiBpdCdzIHRoZSBzYW1lIGxpc3QsXG5cdFx0ICAgIC8vIG9yIGVsc2Ugc2V0cyB0aGUgbGlzdCBhbmQgZ29lcyB0byB0aGUgZmlyc3QgZWxlbWVudC5cblx0XHQgICAgaWYgKHNlbGYuYXBwLmdldEN1cnJlbnRMaXN0KCkgIT09IGxzdClcblx0XHRcdHNlbGYuYXBwLnNldEN1cnJlbnRMaXN0KGxzdCwgdHJ1ZSk7XG5cdFx0ICAgIGVsc2Vcblx0XHRcdHNlbGYuYXBwLmdvVG9OZXh0TGlzdEVsZW1lbnQobHN0KTtcblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0ICAgIC8vIHBsYWluIGNsaWNrIHNldHMgdGhlIHNldCBpZiBpdCdzIGEgZGlmZmVyZW50IGxpc3QsXG5cdFx0ICAgIC8vIG9yIGVsc2UgdW5zZXRzIHRoZSBsaXN0LlxuXHRcdCAgICBpZiAoc2VsZi5hcHAuZ2V0Q3VycmVudExpc3QoKSAhPT0gbHN0KVxuXHRcdCAgICAgICAgc2VsZi5hcHAuc2V0Q3VycmVudExpc3QobHN0KTtcblx0XHQgICAgZWxzZVxuXHRcdCAgICAgICAgc2VsZi5hcHAuc2V0Q3VycmVudExpc3QobnVsbCk7XG5cdFx0fVxuXHQgICAgfSk7XG5cdGl0ZW1zLnNlbGVjdCgnLmJ1dHRvbltuYW1lPVwiZWRpdFwiXScpXG5cdCAgICAvLyBlZGl0OiBjbGljayBcblx0ICAgIC5vbihcImNsaWNrXCIsIGZ1bmN0aW9uKGxzdCkge1xuXHQgICAgICAgIHNlbGYuYXBwLmxpc3RFZGl0b3Iub3Blbihsc3QpO1xuXHQgICAgfSk7XG5cdGl0ZW1zLnNlbGVjdCgnc3BhbltuYW1lPVwibmFtZVwiXScpXG5cdCAgICAudGV4dChsc3QgPT4gbHN0Lm5hbWUpO1xuXHRpdGVtcy5zZWxlY3QoJ3NwYW5bbmFtZT1cImRhdGVcIl0nKS50ZXh0KGxzdCA9PiB7XG5cdCAgICBsZXQgbWQgPSBuZXcgRGF0ZShsc3QubW9kaWZpZWQpO1xuXHQgICAgbGV0IGQgPSBgJHttZC5nZXRGdWxsWWVhcigpfS0ke21kLmdldE1vbnRoKCkrMX0tJHttZC5nZXREYXRlKCl9IGAgXG5cdCAgICAgICAgICArIGA6JHttZC5nZXRIb3VycygpfS4ke21kLmdldE1pbnV0ZXMoKX0uJHttZC5nZXRTZWNvbmRzKCl9YDtcblx0ICAgIHJldHVybiBkO1xuXHR9KTtcblx0aXRlbXMuc2VsZWN0KCdzcGFuW25hbWU9XCJzaXplXCJdJykudGV4dChsc3QgPT4gbHN0Lmlkcy5sZW5ndGgpO1xuXHRpdGVtcy5zZWxlY3QoJy5idXR0b25bbmFtZT1cImRlbGV0ZVwiXScpXG5cdCAgICAub24oXCJjbGlja1wiLCBsc3QgPT4ge1xuXHQgICAgICAgIHRoaXMuZGVsZXRlTGlzdChsc3QubmFtZSk7XG5cdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdC8vIE5vdCBzdXJlIHdoeSB0aGlzIGlzIG5lY2Vzc2FyeSBoZXJlLiBCdXQgd2l0aG91dCBpdCwgdGhlIGxpc3QgaXRlbSBhZnRlciB0aGUgb25lIGJlaW5nXG5cdFx0Ly8gZGVsZXRlZCBoZXJlIHdpbGwgcmVjZWl2ZSBhIGNsaWNrIGV2ZW50LlxuXHRcdGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdC8vXG5cdCAgICB9KTtcblxuXHQvL1xuXHRpdGVtcy5leGl0KCkucmVtb3ZlKCk7XG5cdC8vXG5cdGlmIChuZXdsaXN0KSB7XG5cdCAgICBsZXQgbHN0ZWx0ID0gXG5cdCAgICAgICAgZDMuc2VsZWN0KGAjbXlsaXN0cyBbbmFtZT1cImxpc3RzXCJdIFtuYW1lPVwiJHtuZXdsaXN0Lm5hbWV9XCJdYClbMF1bMF07XG4gICAgICAgICAgICBsc3RlbHQuc2Nyb2xsSW50b1ZpZXcoZmFsc2UpO1xuXHR9XG4gICAgfVxuXG59IC8vIGVuZCBjbGFzcyBMaXN0TWFuYWdlclxuXG5leHBvcnQgeyBMaXN0TWFuYWdlciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvTGlzdE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE1XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IExpc3RGb3JtdWxhUGFyc2VyIH0gZnJvbSAnLi9MaXN0Rm9ybXVsYVBhcnNlcic7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gS25vd3MgaG93IHRvIHBhcnNlIGFuZCBldmFsdWF0ZSBhIGxpc3QgZm9ybXVsYSAoYWthIGxpc3QgZXhwcmVzc2lvbikuXG5jbGFzcyBMaXN0Rm9ybXVsYUV2YWx1YXRvciB7XG4gICAgY29uc3RydWN0b3IgKGxpc3RNYW5hZ2VyKSB7XG5cdHRoaXMubGlzdE1hbmFnZXIgPSBsaXN0TWFuYWdlcjtcbiAgICAgICAgdGhpcy5wYXJzZXIgPSBuZXcgTGlzdEZvcm11bGFQYXJzZXIoKTtcbiAgICB9XG4gICAgLy8gRXZhbHVhdGVzIHRoZSBleHByZXNzaW9uIGFuZCByZXR1cm5zIGEgUHJvbWlzZSBmb3IgdGhlIGxpc3Qgb2YgaWRzLlxuICAgIC8vIElmIHRoZXJlIGlzIGFuIGVycm9yLCB0aGUgcHJvbWlzZSByZWplY3RzIHdpdGggdGhlIGVycm9yIG1lc3NhZ2UuXG4gICAgZXZhbCAoZXhwcikge1xuXHQgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuXHQgICAgIHRyeSB7XG5cdFx0bGV0IGFzdCA9IHRoaXMucGFyc2VyLnBhcnNlKGV4cHIpO1xuXHRcdGxldCBsbSA9IHRoaXMubGlzdE1hbmFnZXI7XG5cdFx0bGV0IHJlYWNoID0gKG4pID0+IHtcblx0XHQgICAgaWYgKHR5cGVvZihuKSA9PT0gXCJzdHJpbmdcIikge1xuXHRcdFx0bGV0IGxzdCA9IGxtLmdldChuKTtcblx0XHRcdGlmICghbHN0KSB0aHJvdyBcIk5vIHN1Y2ggbGlzdDogXCIgKyBuO1xuXHRcdFx0cmV0dXJuIG5ldyBTZXQobHN0Lmlkcyk7XG5cdFx0ICAgIH1cblx0XHQgICAgZWxzZSB7XG5cdFx0XHRsZXQgbCA9IHJlYWNoKG4ubGVmdCk7XG5cdFx0XHRsZXQgciA9IHJlYWNoKG4ucmlnaHQpO1xuXHRcdFx0cmV0dXJuIGxbbi5vcF0ocik7XG5cdFx0ICAgIH1cblx0XHR9XG5cdFx0bGV0IGlkcyA9IHJlYWNoKGFzdCk7XG5cdFx0cmVzb2x2ZShBcnJheS5mcm9tKGlkcykpO1xuXHQgICAgfVxuXHQgICAgY2F0Y2ggKGUpIHtcblx0XHRyZWplY3QoZSk7XG5cdCAgICB9XG5cdCB9LmJpbmQodGhpcykpO1xuICAgIH1cbiAgICAvLyBDaGVja3MgdGhlIGN1cnJlbnQgZXhwcmVzc2lvbiBmb3Igc3ludGFjdGljIGFuZCBzZW1hbnRpYyB2YWxpZGl0eSBhbmQgc2V0cyB0aGUgXG4gICAgLy8gdmFsaWQvaW52YWxpZCBjbGFzcyBhY2NvcmRpbmdseS4gU2VtYW50aWMgdmFsaWRpdHkgc2ltcGx5IG1lYW5zIGFsbCBuYW1lcyBpbiB0aGVcbiAgICAvLyBleHByZXNzaW9uIGFyZSBib3VuZC5cbiAgICAvL1xuICAgIGlzVmFsaWQgIChleHByKSB7XG5cdHRyeSB7XG5cdCAgICAvLyBmaXJzdCBjaGVjayBzeW50YXhcblx0ICAgIGxldCBhc3QgPSB0aGlzLnBhcnNlci5wYXJzZShleHByKTtcblx0ICAgIGxldCBsbSAgPSB0aGlzLmxpc3RNYW5hZ2VyOyBcblx0ICAgIC8vIG5vdyBjaGVjayBsaXN0IG5hbWVzXG5cdCAgICAoZnVuY3Rpb24gcmVhY2gobikge1xuXHRcdGlmICh0eXBlb2YobikgPT09IFwic3RyaW5nXCIpIHtcblx0XHQgICAgbGV0IGxzdCA9IGxtLmdldChuKTtcblx0XHQgICAgaWYgKCFsc3QpIHRocm93IFwiTm8gc3VjaCBsaXN0OiBcIiArIG5cblx0XHR9XG5cdFx0ZWxzZSB7XG5cdFx0ICAgIHJlYWNoKG4ubGVmdCk7XG5cdFx0ICAgIHJlYWNoKG4ucmlnaHQpO1xuXHRcdH1cblx0ICAgIH0pKGFzdCk7XG5cblx0ICAgIC8vIFRodW1icyB1cCFcblx0ICAgIHJldHVybiB0cnVlO1xuXHR9XG5cdGNhdGNoIChlKSB7XG5cdCAgICAvLyBzeW50YXggZXJyb3Igb3IgdW5rbm93biBsaXN0IG5hbWVcblx0ICAgIHJldHVybiBmYWxzZTtcblx0fVxuICAgIH1cbn1cblxuZXhwb3J0IHsgTGlzdEZvcm11bGFFdmFsdWF0b3IgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL0xpc3RGb3JtdWxhRXZhbHVhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAxNlxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBzZXRDYXJldFBvc2l0aW9uLCBtb3ZlQ2FyZXRQb3NpdGlvbiwgZ2V0Q2FyZXRSYW5nZSB9IGZyb20gJy4vdXRpbHMnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi9Db21wb25lbnQnO1xuaW1wb3J0IHsgTGlzdEZvcm11bGFQYXJzZXIgfSBmcm9tICcuL0xpc3RGb3JtdWxhUGFyc2VyJztcblxuLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5jbGFzcyBMaXN0RWRpdG9yIGV4dGVuZHMgQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvciAoYXBwLCBlbHQpIHtcblx0c3VwZXIoYXBwLCBlbHQpO1xuXHR0aGlzLnBhcnNlciA9IG5ldyBMaXN0Rm9ybXVsYVBhcnNlcigpO1xuXHR0aGlzLmZvcm0gPSBudWxsO1xuXHR0aGlzLmluaXREb20oKTtcblx0dGhpcy5pc0VkaXRpbmdGb3JtdWxhID0gZmFsc2U7XG5cdC8vXG5cdHRoaXMubGlzdCA9IG51bGw7XG4gICAgfVxuICAgIGluaXREb20gKCkge1xuXHRsZXQgc2VsZiA9IHRoaXM7XG5cdHRoaXMuZm9ybSA9IHRoaXMucm9vdC5zZWxlY3QoXCJmb3JtXCIpWzBdWzBdO1xuXHRpZiAoIXRoaXMuZm9ybSkgdGhyb3cgXCJDb3VsZCBub3QgaW5pdCBMaXN0RWRpdG9yLiBObyBmb3JtIGVsZW1lbnQuXCI7XG5cdGQzLnNlbGVjdCh0aGlzLmZvcm0pXG5cdCAgICAub24oXCJjbGlja1wiLCAoKSA9PiB7XG5cdCAgICAgICAgbGV0IHQgPSBkMy5ldmVudC50YXJnZXQ7XG5cdFx0aWYgKFwiYnV0dG9uXCIgPT09IHQudGFnTmFtZS50b0xvd2VyQ2FzZSgpKXtcblx0XHQgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHQgICAgbGV0IGYgPSB0aGlzLmZvcm07XG5cdFx0ICAgIGxldCBzID0gZi5pZHMudmFsdWUucmVwbGFjZSgvWyx8XS9nLCAnICcpLnRyaW0oKTtcblx0XHQgICAgbGV0IGlkcyA9IHMgPyBzLnNwbGl0KC9cXHMrLykgOiBbXTtcblx0XHQgICAgLy8gc2F2ZSBsaXN0XG5cdFx0ICAgIGlmICh0Lm5hbWUgPT09IFwic2F2ZVwiKSB7XG5cdFx0XHRpZiAoIXRoaXMubGlzdCkgcmV0dXJuO1xuXHRcdFx0dGhpcy5saXN0ID0gdGhpcy5hcHAubGlzdE1hbmFnZXIudXBkYXRlTGlzdCh0aGlzLmxpc3QubmFtZSwgZi5uYW1lLnZhbHVlLCBpZHMsIGYuZm9ybXVsYS52YWx1ZSk7XG5cdFx0XHR0aGlzLmFwcC5saXN0TWFuYWdlci51cGRhdGUodGhpcy5saXN0KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBjcmVhdGUgbmV3IGxpc3Rcblx0XHQgICAgZWxzZSBpZiAodC5uYW1lID09PSBcIm5ld1wiKSB7XG5cdFx0XHRsZXQgbiA9IGYubmFtZS52YWx1ZS50cmltKCk7XG5cdFx0XHRpZiAoIW4pIHtcblx0XHRcdCAgIGFsZXJ0KFwiWW91ciBsaXN0IGhhcyBubyBuYW1lIGFuZCBpcyB2ZXJ5IHNhZC4gUGxlYXNlIGdpdmUgaXQgYSBuYW1lIGFuZCB0cnkgYWdhaW4uXCIpO1xuXHRcdFx0ICAgcmV0dXJuXG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmIChuLmluZGV4T2YoJ1wiJykgPj0gMCkge1xuXHRcdFx0ICAgYWxlcnQoXCJPaCBkZWFyLCB5b3VyIGxpc3QncyBuYW1lIGhhcyBhIGRvdWJsZSBxdW90ZSBjaGFyYWN0ZXIsIGFuZCBJJ20gYWZhcmFpZCB0aGF0J3Mgbm90IGFsbG93ZWQuIFBsZWFzZSByZW1vdmUgdGhlICdcXFwiJyBhbmQgdHJ5IGFnYWluLlwiKTtcblx0XHRcdCAgIHJldHVyblxuXHRcdFx0fVxuXHRcdCAgICAgICAgdGhpcy5saXN0ID0gdGhpcy5hcHAubGlzdE1hbmFnZXIuY3JlYXRlTGlzdChuLCBpZHMsIGYuZm9ybXVsYS52YWx1ZSk7XG5cdFx0XHR0aGlzLmFwcC5saXN0TWFuYWdlci51cGRhdGUodGhpcy5saXN0KTtcblx0XHQgICAgfVxuXHRcdCAgICAvLyBjbGVhciBmb3JtXG5cdFx0ICAgIGVsc2UgaWYgKHQubmFtZSA9PT0gXCJjbGVhclwiKSB7XG5cdFx0ICAgICAgICB0aGlzLmxpc3QgPSBudWxsO1xuXHRcdCAgICB9XG5cdFx0ICAgIC8vIGZvcndhcmQgdG8gTUdJXG5cdFx0ICAgIGVsc2UgaWYgKHQubmFtZSA9PT0gXCJ0b01naVwiKSB7XG5cdFx0ICAgICAgICBsZXQgZnJtID0gZDMuc2VsZWN0KCcjbWdpYmF0Y2hmb3JtJylbMF1bMF07XG5cdFx0XHRmcm0uaWRzLnZhbHVlID0gaWRzLmpvaW4oXCIgXCIpO1xuXHRcdFx0ZnJtLnN1Ym1pdCgpXG5cdFx0ICAgIH1cblx0XHQgICAgLy8gZm9yd2FyZCB0byBNb3VzZU1pbmVcblx0XHQgICAgZWxzZSBpZiAodC5uYW1lID09PSBcInRvTW91c2VNaW5lXCIpIHtcblx0XHQgICAgICAgIGxldCBmcm0gPSBkMy5zZWxlY3QoJyNtb3VzZW1pbmVmb3JtJylbMF1bMF07XG5cdFx0XHRmcm0uZXh0ZXJuYWxpZHMudmFsdWUgPSBpZHMuam9pbihcIixcIik7XG5cdFx0XHRmcm0uc3VibWl0KClcblx0XHQgICAgfVxuXHRcdH1cblx0ICAgIH0pO1xuXG5cdC8vIEJ1dHRvbjogc2hvdy9oaWRlIGZvcm11bGEgZWRpdG9yXG5cdHRoaXMucm9vdC5zZWxlY3QoJ1tuYW1lPVwiaWRzZWN0aW9uXCJdIC5idXR0b25bbmFtZT1cImVkaXRmb3JtdWxhXCJdJylcblx0ICAgIC5vbihcImNsaWNrXCIsICgpID0+IHRoaXMudG9nZ2xlRm9ybXVsYUVkaXRvcigpKTtcblx0ICAgIFxuXHQvLyBJbnB1dCBib3g6IGZvcm11bGE6IHZhbGlkYXRlIG9uIGFueSBpbnB1dFxuXHR0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cImZvcm11bGFlZGl0b3JcIl0gW25hbWU9XCJmb3JtdWxhXCJdJylcblx0ICAgIC5vbihcImlucHV0XCIsICgpID0+IHtcblx0ICAgICAgICB0aGlzLnZhbGlkYXRlRXhwcigpO1xuXHQgICAgfSk7XG5cblx0Ly8gRm9yd2FyZCAtPiBNR0kvTW91c2VNaW5lOiBkaXNhYmxlIGJ1dHRvbnMgaWYgbm8gaWRzXG5cdHRoaXMucm9vdC5zZWxlY3QoJ1tuYW1lPVwiaWRzXCJdJylcblx0ICAgIC5vbihcImlucHV0XCIsICgpID0+IHtcblx0ICAgICAgICBsZXQgZW1wdHkgPSB0aGlzLmZvcm0uaWRzLnZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDA7XG5cdFx0dGhpcy5mb3JtLnRvTWdpLmRpc2FibGVkID0gdGhpcy5mb3JtLnRvTW91c2VNaW5lLmRpc2FibGVkID0gZW1wdHk7XG5cdCAgICB9KTtcblxuXHQvLyBCdXR0b25zOiB0aGUgbGlzdCBvcGVyYXRvciBidXR0b25zICh1bmlvbiwgaW50ZXJzZWN0aW9uLCBldGMuKVxuXHR0aGlzLnJvb3Quc2VsZWN0QWxsKCdbbmFtZT1cImZvcm11bGFlZGl0b3JcIl0gLmJ1dHRvbi5saXN0b3AnKVxuXHQgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24gKCkge1xuXHRcdC8vIGFkZCBteSBzeW1ib2wgdG8gdGhlIGZvcm11bGFcblx0XHRsZXQgaW5lbHQgPSBzZWxmLmZvcm0uZm9ybXVsYTtcblx0XHRsZXQgb3AgPSBkMy5zZWxlY3QodGhpcykuYXR0cihcIm5hbWVcIik7XG5cdFx0c2VsZi5hZGRUb0xpc3RFeHByKG9wKTtcblx0XHRzZWxmLnZhbGlkYXRlRXhwcigpO1xuXHQgICAgfSk7XG5cblx0Ly8gQnV0dG9uOiByZWZyZXNoIGJ1dHRvbiBmb3IgcnVubmluZyB0aGUgZm9ybXVsYVxuXHR0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cImZvcm11bGFlZGl0b3JcIl0gLmJ1dHRvbltuYW1lPVwicmVmcmVzaFwiXScpXG4gICAgICAgICAgICAub24oXCJjbGlja1wiLCAoKSA9PiB7XG5cdFx0bGV0IGVtZXNzYWdlPVwiSSdtIHRlcnJpYmx5IHNvcnJ5LCBidXQgdGhlcmUgYXBwZWFycyB0byBiZSBhIHByb2JsZW0gd2l0aCB5b3VyIGxpc3QgZXhwcmVzc2lvbjogXCI7XG5cdFx0bGV0IGZvcm11bGEgPSB0aGlzLmZvcm0uZm9ybXVsYS52YWx1ZS50cmltKCk7XG5cdFx0aWYgKGZvcm11bGEubGVuZ3RoID09PSAwKVxuXHRcdCAgICByZXR1cm47XG5cdCAgICAgICAgdGhpcy5hcHAubGlzdE1hbmFnZXJcblx0XHQgICAgLmV2YWxGb3JtdWxhKGZvcm11bGEpXG5cdFx0ICAgIC50aGVuKGlkcyA9PiB7XG5cdFx0ICAgICAgICB0aGlzLmZvcm0uaWRzLnZhbHVlID0gaWRzLmpvaW4oXCJcXG5cIik7XG5cdFx0ICAgICB9KVxuXHRcdCAgICAuY2F0Y2goZSA9PiBhbGVydChlbWVzc2FnZSArIGUpKTtcblx0ICAgIH0pO1xuXG5cdC8vIEJ1dHRvbjogY2xvc2UgZm9ybXVsYSBlZGl0b3Jcblx0dGhpcy5yb290LnNlbGVjdCgnW25hbWU9XCJmb3JtdWxhZWRpdG9yXCJdIC5idXR0b25bbmFtZT1cImNsb3NlXCJdJylcbiAgICAgICAgICAgIC5vbihcImNsaWNrXCIsICgpID0+IHRoaXMuY2xvc2VGb3JtdWxhRWRpdG9yKCkgKTtcblx0XG5cdC8vIENsaWNraW5nIHRoZSBib3ggY29sbGFwc2UgYnV0dG9uIHNob3VsZCBjbGVhciB0aGUgZm9ybVxuXHR0aGlzLnJvb3Quc2VsZWN0KFwiLmJ1dHRvbi5jbG9zZVwiKVxuXHQgICAgLm9uKFwiY2xpY2suZXh0cmFcIiwgKCkgPT4ge1xuXHQgICAgICAgIHRoaXMubGlzdCA9IG51bGw7XG5cdFx0dGhpcy5jbG9zZUZvcm11bGFFZGl0b3IoKTtcblx0ICAgIH0pO1xuICAgIH1cbiAgICBwYXJzZUlkcyAocykge1xuXHRyZXR1cm4gcy5yZXBsYWNlKC9bLHxdL2csICcgJykudHJpbSgpLnNwbGl0KC9cXHMrLyk7XG4gICAgfVxuICAgIGdldCBsaXN0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xpc3Q7XG4gICAgfVxuICAgIHNldCBsaXN0IChsc3QpIHtcbiAgICAgICAgdGhpcy5fbGlzdCA9IGxzdDtcblx0dGhpcy5fc3luY0Rpc3BsYXkoKTtcbiAgICB9XG4gICAgX3N5bmNEaXNwbGF5ICgpIHtcblx0bGV0IGxzdCA9IHRoaXMuX2xpc3Q7XG5cdGlmICghbHN0KSB7XG5cdCAgICB0aGlzLmZvcm0ubmFtZS52YWx1ZSA9ICcnO1xuXHQgICAgdGhpcy5mb3JtLmlkcy52YWx1ZSA9ICcnO1xuXHQgICAgdGhpcy5mb3JtLmlkcy5kaXNhYmxlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5mb3JtLm1vZGlmaWVkLnZhbHVlID0gJyc7XG5cdCAgICB0aGlzLmZvcm0uZm9ybXVsYS52YWx1ZSA9ICcnO1xuXHQgICAgdGhpcy5mb3JtLnNhdmUuZGlzYWJsZWQgPSB0cnVlO1xuXHQgICAgdGhpcy5mb3JtLnRvTWdpLmRpc2FibGVkID0gdHJ1ZTtcblx0ICAgIHRoaXMuZm9ybS50b01vdXNlTWluZS5kaXNhYmxlZCA9IHRydWU7XG5cdH1cblx0ZWxzZSB7XG5cdCAgICB0aGlzLmZvcm0ubmFtZS52YWx1ZSA9IGxzdC5uYW1lO1xuXHQgICAgdGhpcy5mb3JtLmlkcy52YWx1ZSA9IGxzdC5pZHMuam9pbignXFxuJyk7XG5cdCAgICB0aGlzLmZvcm0uZm9ybXVsYS52YWx1ZSA9IGxzdC5mb3JtdWxhIHx8IFwiXCI7XG5cdCAgICB0aGlzLmZvcm0uaWRzLmRpc2FibGVkID0gdGhpcy5mb3JtLmZvcm11bGEudmFsdWUudHJpbSgpLmxlbmd0aCA+IDA7XG5cdCAgICB0aGlzLmZvcm0ubW9kaWZpZWQudmFsdWUgPSBsc3QubW9kaWZpZWQ7XG5cdCAgICB0aGlzLmZvcm0uc2F2ZS5kaXNhYmxlZCA9IGZhbHNlO1xuXHQgICAgdGhpcy5mb3JtLnRvTWdpLmRpc2FibGVkIFxuXHQgICAgICA9IHRoaXMuZm9ybS50b01vdXNlTWluZS5kaXNhYmxlZCBcblx0ICAgICAgICA9ICh0aGlzLmZvcm0uaWRzLnZhbHVlLnRyaW0oKS5sZW5ndGggPT09IDApO1xuXHR9XG5cdHRoaXMudmFsaWRhdGVFeHByKCk7XG4gICAgfVxuICAgIGNsZWFyICgpIHtcbiAgICAgICAgdGhpcy5saXN0ID0gbnVsbDtcbiAgICB9XG4gICAgb3BlbiAobHN0KSB7XG4gICAgICAgIHRoaXMubGlzdCA9IGxzdDtcblx0dGhpcy5yb290LmNsYXNzZWQoXCJjbG9zZWRcIiwgZmFsc2UpO1xuICAgIH1cbiAgICBjbG9zZSAoKSB7XG4gICAgICAgIHRoaXMubGlzdCA9IG51bGw7XG5cdHRoaXMucm9vdC5jbGFzc2VkKFwiY2xvc2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBvcGVuRm9ybXVsYUVkaXRvciAoKSB7XG5cdHRoaXMucm9vdC5jbGFzc2VkKFwiZWRpdGluZ2Zvcm11bGFcIiwgdHJ1ZSk7XG5cdHRoaXMuaXNFZGl0aW5nRm9ybXVsYSA9IHRydWU7XG5cdGxldCBmID0gdGhpcy5mb3JtLmZvcm11bGEudmFsdWU7XG5cdHRoaXMuZm9ybS5mb3JtdWxhLmZvY3VzKCk7XG5cdHNldENhcmV0UG9zaXRpb24odGhpcy5mb3JtLmZvcm11bGEsIGYubGVuZ3RoKTtcbiAgICB9XG4gICAgY2xvc2VGb3JtdWxhRWRpdG9yICgpIHtcblx0dGhpcy5yb290LmNsYXNzZWQoXCJlZGl0aW5nZm9ybXVsYVwiLCBmYWxzZSk7XG5cdHRoaXMuaXNFZGl0aW5nRm9ybXVsYSA9IGZhbHNlO1xuICAgIH1cbiAgICB0b2dnbGVGb3JtdWxhRWRpdG9yICgpIHtcblx0bGV0IHNob3dpbmcgPSB0aGlzLnJvb3QuY2xhc3NlZChcImVkaXRpbmdmb3JtdWxhXCIpO1xuXHRzaG93aW5nID8gdGhpcy5jbG9zZUZvcm11bGFFZGl0b3IoKSA6IHRoaXMub3BlbkZvcm11bGFFZGl0b3IoKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gQ2hlY2tzIHRoZSBjdXJyZW50IGV4cHJlc3Npb24gYW5kIHNldHMgdGhlIHZhbGlkL2ludmFsaWQgY2xhc3MuXG4gICAgdmFsaWRhdGVFeHByICAoKSB7XG5cdGxldCBpbnAgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cImZvcm11bGFlZGl0b3JcIl0gW25hbWU9XCJmb3JtdWxhXCJdJyk7XG5cdGxldCBleHByID0gaW5wWzBdWzBdLnZhbHVlLnRyaW0oKTtcblx0aWYgKCFleHByKSB7XG5cdCAgICBpbnAuY2xhc3NlZChcInZhbGlkXCIsZmFsc2UpLmNsYXNzZWQoXCJpbnZhbGlkXCIsZmFsc2UpO1xuIFx0ICAgIHRoaXMuZm9ybS5pZHMuZGlzYWJsZWQgPSBmYWxzZTtcblx0fVxuXHRlbHNlIHtcblx0ICAgIGxldCBpc1ZhbGlkID0gdGhpcy5hcHAubGlzdE1hbmFnZXIuaXNWYWxpZChleHByKTsgLy8gRklYTUUgLSByZWFjaG92ZXJcblx0ICAgIGlucC5jbGFzc2VkKFwidmFsaWRcIiwgaXNWYWxpZCkuY2xhc3NlZChcImludmFsaWRcIiwgIWlzVmFsaWQpO1xuIFx0ICAgIHRoaXMuZm9ybS5pZHMuZGlzYWJsZWQgPSB0cnVlO1xuXHR9XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGFkZFRvTGlzdEV4cHIgKHRleHQpIHtcblx0bGV0IGlucCA9IHRoaXMucm9vdC5zZWxlY3QoJ1tuYW1lPVwiZm9ybXVsYWVkaXRvclwiXSBbbmFtZT1cImZvcm11bGFcIl0nKTtcblx0bGV0IGllbHQgPSBpbnBbMF1bMF07XG5cdGxldCB2ID0gaWVsdC52YWx1ZTtcblx0bGV0IHNwbGljZSA9IGZ1bmN0aW9uIChlLHQpe1xuXHQgICAgbGV0IHYgPSBlLnZhbHVlO1xuXHQgICAgbGV0IHIgPSBnZXRDYXJldFJhbmdlKGUpO1xuXHQgICAgZS52YWx1ZSA9IHYuc2xpY2UoMCxyWzBdKSArIHQgKyB2LnNsaWNlKHJbMV0pO1xuXHQgICAgc2V0Q2FyZXRQb3NpdGlvbihlLCByWzBdK3QubGVuZ3RoKTtcblx0ICAgIGUuZm9jdXMoKTtcblx0fVxuXHRsZXQgcmFuZ2UgPSBnZXRDYXJldFJhbmdlKGllbHQpO1xuXHRpZiAocmFuZ2VbMF0gPT09IHJhbmdlWzFdKSB7XG5cdCAgICAvLyBubyBjdXJyZW50IHNlbGVjdGlvblxuXHQgICAgc3BsaWNlKGllbHQsIHRleHQpO1xuXHQgICAgaWYgKHRleHQgPT09IFwiKClcIikgXG5cdFx0bW92ZUNhcmV0UG9zaXRpb24oaWVsdCwgLTEpO1xuXHR9XG5cdGVsc2Uge1xuXHQgICAgLy8gdGhlcmUgaXMgYSBjdXJyZW50IHNlbGVjdGlvblxuXHQgICAgaWYgKHRleHQgPT09IFwiKClcIilcblx0XHQvLyBzdXJyb3VuZCBjdXJyZW50IHNlbGVjdGlvbiB3aXRoIHBhcmVucywgdGhlbiBtb3ZlIGNhcmV0IGFmdGVyXG5cdFx0dGV4dCA9ICcoJyArIHYuc2xpY2UocmFuZ2VbMF0scmFuZ2VbMV0pICsgJyknO1xuXHQgICAgc3BsaWNlKGllbHQsIHRleHQpXG5cdH1cblx0dGhpcy52YWxpZGF0ZUV4cHIoKTtcbiAgICB9XG59IC8vIGVuZCBjbGFzcyBMaXN0RWRpdG9yXG5cbmV4cG9ydCB7IExpc3RFZGl0b3IgfTtcblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vd3d3L2pzL0xpc3RFZGl0b3IuanNcbi8vIG1vZHVsZSBpZCA9IDE3XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IEZhY2V0IH0gZnJvbSAnLi9GYWNldCc7XG5cbi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgRmFjZXRNYW5hZ2VyIHtcbiAgICBjb25zdHJ1Y3RvciAoYXBwKSB7XG5cdHRoaXMuYXBwID0gYXBwO1xuXHR0aGlzLmZhY2V0cyA9IFtdO1xuXHR0aGlzLm5hbWUyZmFjZXQgPSB7fVxuICAgIH1cbiAgICBhZGRGYWNldCAobmFtZSwgdmFsdWVGY24pIHtcblx0aWYgKHRoaXMubmFtZTJmYWNldFtuYW1lXSkgdGhyb3cgXCJEdXBsaWNhdGUgZmFjZXQgbmFtZS4gXCIgKyBuYW1lO1xuXHRsZXQgZmFjZXQgPSBuZXcgRmFjZXQobmFtZSwgdGhpcywgdmFsdWVGY24pO1xuICAgICAgICB0aGlzLmZhY2V0cy5wdXNoKCBmYWNldCApO1xuXHR0aGlzLm5hbWUyZmFjZXRbbmFtZV0gPSBmYWNldDtcblx0cmV0dXJuIGZhY2V0XG4gICAgfVxuICAgIHRlc3QgKGYpIHtcbiAgICAgICAgbGV0IHZhbHMgPSB0aGlzLmZhY2V0cy5tYXAoIGZhY2V0ID0+IGZhY2V0LnRlc3QoZikgKTtcblx0cmV0dXJuIHZhbHMucmVkdWNlKChhY2N1bSwgdmFsKSA9PiBhY2N1bSAmJiB2YWwsIHRydWUpO1xuICAgIH1cbiAgICBhcHBseUFsbCAoKSB7XG5cdGxldCBzaG93ID0gbnVsbDtcblx0bGV0IGhpZGUgPSBcIm5vbmVcIjtcblx0Ly8gRklYTUU6IG1ham9yIHJlYWNob3ZlclxuXHR0aGlzLmFwcC56b29tVmlldy5zdmdNYWluLnNlbGVjdChcImcuc3RyaXBzXCIpLnNlbGVjdEFsbCgnLmZlYXR1cmUnKVxuXHQgICAgLnN0eWxlKFwiZGlzcGxheVwiLCBmID0+IHRoaXMudGVzdChmKSA/IHNob3cgOiBoaWRlKTtcbiAgICB9XG59IC8vIGVuZCBjbGFzcyBGYWNldE1hbmFnZXJcblxuZXhwb3J0IHsgRmFjZXRNYW5hZ2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9GYWNldE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDE4XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgRmFjZXQge1xuICAgIGNvbnN0cnVjdG9yIChuYW1lLCBtYW5hZ2VyLCB2YWx1ZUZjbikge1xuXHR0aGlzLm1hbmFnZXIgPSBtYW5hZ2VyO1xuICAgICAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXHR0aGlzLnZhbHVlcyA9IFtdO1xuXHR0aGlzLnZhbHVlRmNuID0gdmFsdWVGY247XG4gICAgfVxuICAgIHNldFZhbHVlcyAodmFsdWVzLCBxdWlldGx5KSB7XG4gICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuXHRpZiAoISBxdWlldGx5KSB7XG5cdCAgICB0aGlzLm1hbmFnZXIuYXBwbHlBbGwoKTtcblx0ICAgIHRoaXMubWFuYWdlci5hcHAuem9vbVZpZXcuaGlnaGxpZ2h0KCk7XG5cdH1cbiAgICB9XG4gICAgdGVzdCAoZikge1xuICAgICAgICByZXR1cm4gIXRoaXMudmFsdWVzIHx8IHRoaXMudmFsdWVzLmxlbmd0aCA9PT0gMCB8fCB0aGlzLnZhbHVlcy5pbmRleE9mKCB0aGlzLnZhbHVlRmNuKGYpICkgPj0gMDtcbiAgICB9XG59IC8vIGVuZCBjbGFzcyBGYWNldFxuXG5leHBvcnQgeyBGYWNldCB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvRmFjZXQuanNcbi8vIG1vZHVsZSBpZCA9IDE5XG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCB7IGQzdHN2IH0gZnJvbSAnLi91dGlscyc7XG5pbXBvcnQgeyBCbG9ja1RyYW5zbGF0b3IgfSBmcm9tICcuL0Jsb2NrVHJhbnNsYXRvcic7XG5pbXBvcnQgeyBLZXlTdG9yZSB9IGZyb20gJy4vS2V5U3RvcmUnO1xuXG4vLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbi8vIEJsb2NrVHJhbnNsYXRvciBtYW5hZ2VyIGNsYXNzLiBGb3IgYW55IGdpdmVuIHBhaXIgb2YgZ2Vub21lcywgQSBhbmQgQiwgbG9hZHMgdGhlIHNpbmdsZSBibG9jayBmaWxlXG4vLyBmb3IgdHJhbnNsYXRpbmcgYmV0d2VlbiB0aGVtLCBhbmQgaW5kZXhlcyBpdCBcImZyb20gYm90aCBkaXJlY3Rpb25zXCI6XG4vLyBcdEEtPkItPiBbQUJfQmxvY2tGaWxlXSA8LUE8LUJcbi8vXG5jbGFzcyBCVE1hbmFnZXIge1xuICAgIGNvbnN0cnVjdG9yIChhcHApIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG5cdHRoaXMucmNCbG9ja3MgPSB7fTtcblx0dGhpcy5ibG9ja1N0b3JlID0gbmV3IEtleVN0b3JlKCdzeW50ZW55LWJsb2NrcycpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHJlZ2lzdGVyQmxvY2tzIChhR2Vub21lLCBiR2Vub21lLCBibG9ja3MpIHtcblx0bGV0IGFuYW1lID0gYUdlbm9tZS5uYW1lO1xuXHRsZXQgYm5hbWUgPSBiR2Vub21lLm5hbWU7XG5cdGNvbnNvbGUubG9nKGBSZWdpc3RlcmluZyBibG9ja3M6ICR7YW5hbWV9IHZzICR7Ym5hbWV9YCwgYCNibG9ja3M9JHtibG9ja3MubGVuZ3RofWApO1xuXHRsZXQgYmxrRmlsZSA9IG5ldyBCbG9ja1RyYW5zbGF0b3IoYUdlbm9tZSxiR2Vub21lLGJsb2Nrcyk7XG5cdGlmKCAhIHRoaXMucmNCbG9ja3NbYW5hbWVdKSB0aGlzLnJjQmxvY2tzW2FuYW1lXSA9IHt9O1xuXHRpZiggISB0aGlzLnJjQmxvY2tzW2JuYW1lXSkgdGhpcy5yY0Jsb2Nrc1tibmFtZV0gPSB7fTtcblx0dGhpcy5yY0Jsb2Nrc1thbmFtZV1bYm5hbWVdID0gYmxrRmlsZTtcblx0dGhpcy5yY0Jsb2Nrc1tibmFtZV1bYW5hbWVdID0gYmxrRmlsZTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBMb2FkcyB0aGUgc3ludGVueSBibG9jayBmaWxlIGZvciBnZW5vbWVzIGFHZW5vbWUgYW5kIGJHZW5vbWUuXG4gICAgLy8gXG4gICAgZ2V0QmxvY2tGaWxlIChhR2Vub21lLCBiR2Vub21lKSB7XG5cdC8vIEJlIGEgbGl0dGxlIHNtYXJ0IGFib3V0IHRoZSBvcmRlciB3ZSB0cnkgdGhlIG5hbWVzLi4uXG5cdGlmIChiR2Vub21lLm5hbWUgPCBhR2Vub21lLm5hbWUpIHtcblx0ICAgIGxldCB0bXAgPSBhR2Vub21lOyBhR2Vub21lID0gYkdlbm9tZTsgYkdlbm9tZSA9IHRtcDtcblx0fVxuXHQvLyBGaXJzdCwgc2VlIGlmIHdlIGFscmVhZHkgaGF2ZSB0aGlzIHBhaXJcblx0bGV0IGFuYW1lID0gYUdlbm9tZS5uYW1lO1xuXHRsZXQgYm5hbWUgPSBiR2Vub21lLm5hbWU7XG5cdGxldCBiZiA9ICh0aGlzLnJjQmxvY2tzW2FuYW1lXSB8fCB7fSlbYm5hbWVdO1xuXHRpZiAoYmYpXG5cdCAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKGJmKTtcblx0XG5cdC8vIFNlY29uZCwgdHJ5IGxvY2FsIGRpc2sgY2FjaGVcblx0bGV0IGtleSA9IGFuYW1lICsgJy0nICsgYm5hbWU7XG5cdHJldHVybiB0aGlzLmJsb2NrU3RvcmUuZ2V0KGtleSkudGhlbihkYXRhID0+IHtcblx0ICAgIGlmIChkYXRhKSB7XG5cdFx0Y29uc29sZS5sb2coXCJGb3VuZCBibG9ja3MgaW4gY2FjaGUuXCIpO1xuXHQgICAgICAgIHJldHVybiB0aGlzLnJlZ2lzdGVyQmxvY2tzKGFHZW5vbWUsIGJHZW5vbWUsIGRhdGEpO1xuXHQgICAgfVxuXHQgICAgZWxzZSBpZiAodGhpcy5zZXJ2ZXJSZXF1ZXN0KSB7XG5cdCAgICAgICAgLy8gaWYgdGhlcmUgaXMgYW4gb3V0c3RhbmRpbmcgcmVxdWVzdCwgd2FpdCB1bnRpbCBpdCdzIGRvbmUgYW5kIHRyeSBhZ2Fpbi5cblx0XHRyZXR1cm4gdGhpcy5zZXJ2ZXJSZXF1ZXN0LnRoZW4oKCk9PnRoaXMuZ2V0QmxvY2tGaWxlKGFHZW5vbWUsIGJHZW5vbWUpKTtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdC8vIFRoaXJkLCBsb2FkIGZyb20gc2VydmVyLlxuXHRcdGxldCBmbiA9IGAuL2RhdGEvYmxvY2tzLnRzdmBcblx0XHRjb25zb2xlLmxvZyhcIlJlcXVlc3RpbmcgYmxvY2sgZmlsZSBmcm9tOiBcIiArIGZuKTtcblx0XHR0aGlzLnNlcnZlclJlcXVlc3QgPSBkM3RzdihmbikudGhlbihibG9ja3MgPT4ge1xuXHRcdCAgICBsZXQgcmJzID0gYmxvY2tzLnJlZHVjZSggKGEsYikgPT4ge1xuXHRcdFx0bGV0IGsgPSBiLmFHZW5vbWUgKyAnLScgKyBiLmJHZW5vbWU7XG5cdFx0XHRpZiAoIShrIGluIGEpKSBhW2tdID0gW107XG5cdFx0XHQgICAgYVtrXS5wdXNoKGIpO1xuXHRcdFx0ICAgIHJldHVybiBhO1xuXHRcdFx0fSwge30pO1xuXHRcdCAgICBmb3IgKGxldCBuIGluIHJicykge1xuXHRcdCAgICAgICAgdGhpcy5ibG9ja1N0b3JlLnNldChuLCByYnNbbl0pO1xuXHRcdCAgICB9XG5cdFx0fSkudGhlbigoKSA9PiB0aGlzLmdldEJsb2NrRmlsZShhR2Vub21lLCBiR2Vub21lKSk7XG5cdFx0cmV0dXJuIHRoaXMuc2VydmVyUmVxdWVzdDtcblx0ICAgIH1cblx0fSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyBhIHByb21pc2UgdGhhdCBpcyBmdWxmaWxsZWQgd2hlbiB0aGUgdHJhbnNsYXRvciBoYXMgbG9hZGVkIGFsbCB0aGUgZGF0YSBuZWVkZWRcbiAgICAvLyBmb3IgdHJhbnNsYXRpbmcgY29vcmRpbmF0ZXMgYmV0d2VlbiB0aGUgY3VycmVudCByZWYgc3RyYWluIGFuZCB0aGUgY3VycmVudCBjb21wYXJpc29uIHN0cmFpbnMuXG4gICAgLy9cbiAgICByZWFkeSAoKSB7XG5cdGxldCBwcm9taXNlcyA9IHRoaXMuYXBwLmNHZW5vbWVzLm1hcChjZyA9PiB0aGlzLmdldEJsb2NrRmlsZSh0aGlzLmFwcC5yR2Vub21lLCBjZykpO1xuXHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpXG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyB0aGUgc3ludGVueSBibG9jayB0cmFuc2xhdG9yIHRoYXQgbWFwcyB0aGUgY3VycmVudCByZWYgZ2Vub21lIHRvIHRoZSBzcGVjaWZpZWQgY29tcGFyaXNvbiBnZW5vbWUuXG4gICAgLy9cbiAgICBnZXRCbG9ja3MgKGZyb21HZW5vbWUsIHRvR2Vub21lKSB7XG4gICAgICAgIGxldCBibGtUcmFucyA9IHRoaXMucmNCbG9ja3NbZnJvbUdlbm9tZS5uYW1lXVt0b0dlbm9tZS5uYW1lXTtcblx0cmV0dXJuIGJsa1RyYW5zLmdldEJsb2Nrcyhmcm9tR2Vub21lKVxuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFRyYW5zbGF0ZXMgdGhlIGdpdmVuIGNvb3JkaW5hdGUgcmFuZ2UgZnJvbSB0aGUgc3BlY2lmaWVkIGZyb21HZW5vbWUgdG8gdGhlIHNwZWNpZmllZCB0b0dlbm9tZS5cbiAgICAvLyBSZXR1cm5zIGEgbGlzdCBvZiB6ZXJvIG9yIG1vcmUgY29vcmRpbmF0ZSByYW5nZXMgaW4gdGhlIHRvR2Vub21lLlxuICAgIC8vXG4gICAgdHJhbnNsYXRlIChmcm9tR2Vub21lLCBjaHIsIHN0YXJ0LCBlbmQsIHRvR2Vub21lLCBpbnZlcnRlZCkge1xuXHQvLyBnZXQgdGhlIHJpZ2h0IGJsb2NrIGZpbGVcblx0bGV0IGJsa1RyYW5zID0gdGhpcy5yY0Jsb2Nrc1tmcm9tR2Vub21lLm5hbWVdW3RvR2Vub21lLm5hbWVdO1xuXHRpZiAoIWJsa1RyYW5zKSB0aHJvdyBcIkludGVybmFsIGVycm9yLiBObyBibG9jayBmaWxlIGZvdW5kIGluIGluZGV4LlwiXG5cdC8vIHRyYW5zbGF0ZSFcblx0bGV0IHJhbmdlcyA9IGJsa1RyYW5zLnRyYW5zbGF0ZShmcm9tR2Vub21lLCBjaHIsIHN0YXJ0LCBlbmQsIGludmVydGVkKTtcblx0cmV0dXJuIHJhbmdlcztcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY2xlYXJDYWNoZWREYXRhICgpIHtcblx0Y29uc29sZS5sb2coXCJCVE1hbmFnZXI6IENhY2hlIGNsZWFyZWQuXCIpXG4gICAgICAgIHJldHVybiB0aGlzLmJsb2NrU3RvcmUuY2xlYXIoKTtcbiAgICB9XG59IC8vIGVuZCBjbGFzcyBCVE1hbmFnZXJcblxuZXhwb3J0IHsgQlRNYW5hZ2VyIH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9CVE1hbmFnZXIuanNcbi8vIG1vZHVsZSBpZCA9IDIwXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuLy8gU29tZXRoaW5nIHRoYXQga25vd3MgaG93IHRvIHRyYW5zbGF0ZSBjb29yZGluYXRlcyBiZXR3ZWVuIHR3byBnZW5vbWVzLlxuLy9cbi8vXG5jbGFzcyBCbG9ja1RyYW5zbGF0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGFHZW5vbWUsIGJHZW5vbWUsIGJsb2Nrcyl7XG5cdHRoaXMuYUdlbm9tZSA9IGFHZW5vbWU7XG5cdHRoaXMuYkdlbm9tZSA9IGJHZW5vbWU7XG5cdHRoaXMuYmxvY2tzID0gYmxvY2tzLm1hcChiID0+IHRoaXMucHJvY2Vzc0Jsb2NrKGIpKVxuXHR0aGlzLmN1cnJTb3J0ID0gXCJhXCI7IC8vIGVpdGhlciAnYScgb3IgJ2InXG4gICAgfVxuICAgIHByb2Nlc3NCbG9jayAoYmxrKSB7IFxuICAgICAgICBibGsuYUluZGV4ID0gcGFyc2VJbnQoYmxrLmFJbmRleCk7XG4gICAgICAgIGJsay5iSW5kZXggPSBwYXJzZUludChibGsuYkluZGV4KTtcbiAgICAgICAgYmxrLmFTdGFydCA9IHBhcnNlSW50KGJsay5hU3RhcnQpO1xuICAgICAgICBibGsuYlN0YXJ0ID0gcGFyc2VJbnQoYmxrLmJTdGFydCk7XG4gICAgICAgIGJsay5hRW5kICAgPSBwYXJzZUludChibGsuYUVuZCk7XG4gICAgICAgIGJsay5iRW5kICAgPSBwYXJzZUludChibGsuYkVuZCk7XG5cdGJsay5hYk1hcCA9IGQzLnNjYWxlLmxpbmVhcigpXG5cdCAgICAuZG9tYWluKFtibGsuYVN0YXJ0LGJsay5hRW5kXSlcblx0ICAgIC5yYW5nZSggYmxrLmJsb2NrT3JpPT09XCItXCIgPyBbYmxrLmJFbmQsYmxrLmJTdGFydF0gOiBbYmxrLmJTdGFydCxibGsuYkVuZF0pO1xuXHRibGsuYmFNYXAgPSBibGsuYWJNYXAuaW52ZXJ0XG5cdHJldHVybiBibGs7XG4gICAgfVxuICAgIHNldFNvcnQgKHdoaWNoKSB7XG5cdGlmICh3aGljaCAhPT0gJ2EnICYmIHdoaWNoICE9PSAnYicpIHRocm93IFwiQmFkIGFyZ3VtZW50OlwiICsgd2hpY2g7XG5cdGxldCBzb3J0Q29sID0gd2hpY2ggKyBcIkluZGV4XCI7XG5cdGxldCBjbXAgPSAoeCx5KSA9PiB4W3NvcnRDb2xdIC0geVtzb3J0Q29sXTtcblx0dGhpcy5ibG9ja3Muc29ydChjbXApO1xuXHR0aGlzLmN1cnJTb3J0ID0gd2hpY2g7XG4gICAgfVxuICAgIGZsaXBTb3J0ICgpIHtcblx0dGhpcy5zZXRTb3J0KHRoaXMuY3VyclNvcnQgPT09IFwiYVwiID8gXCJiXCIgOiBcImFcIik7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZ2Vub21lIChlaXRoZXIgdGhlIGEgb3IgYiBnZW5vbWUpIGFuZCBhIGNvb3JkaW5hdGUgcmFuZ2UsXG4gICAgLy8gcmV0dXJucyB0aGUgZXF1aXZhbGVudCBjb29yZGluYXRlIHJhbmdlKHMpIGluIHRoZSBvdGhlciBnZW5vbWVcbiAgICB0cmFuc2xhdGUgKGZyb21HZW5vbWUsIGNociwgc3RhcnQsIGVuZCwgaW52ZXJ0KSB7XG5cdC8vXG5cdGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gc3RhcnQgOiBlbmQ7XG5cdC8vIGZyb20gPSBcImFcIiBvciBcImJcIiwgZGVwZW5kaW5nIG9uIHdoaWNoIGdlbm9tZSBpcyBnaXZlbi5cbiAgICAgICAgbGV0IGZyb20gPSAoZnJvbUdlbm9tZSA9PT0gdGhpcy5hR2Vub21lID8gXCJhXCIgOiBmcm9tR2Vub21lID09PSB0aGlzLmJHZW5vbWUgPyBcImJcIiA6IG51bGwpO1xuXHRpZiAoIWZyb20pIHRocm93IFwiQmFkIGFyZ3VtZW50LiBHZW5vbWUgbmVpdGhlciBBIG5vciBCLlwiO1xuXHQvLyB0byA9IFwiYlwiIG9yIFwiYVwiLCBvcHBvc2l0ZSBvZiBmcm9tXG5cdGxldCB0byA9IChmcm9tID09PSBcImFcIiA/IFwiYlwiIDogXCJhXCIpO1xuXHQvLyBtYWtlIHN1cmUgdGhlIGJsb2NrcyBhcmUgc29ydGVkIGJ5IHRoZSBmcm9tIGdlbm9tZVxuXHR0aGlzLnNldFNvcnQoZnJvbSk7XG5cdC8vXG5cdGxldCBmcm9tQyA9IGZyb20rXCJDaHJcIjtcblx0bGV0IGZyb21TID0gZnJvbStcIlN0YXJ0XCI7XG5cdGxldCBmcm9tRSA9IGZyb20rXCJFbmRcIjtcblx0bGV0IGZyb21JID0gZnJvbStcIkluZGV4XCI7XG5cdGxldCB0b0MgPSB0bytcIkNoclwiO1xuXHRsZXQgdG9TID0gdG8rXCJTdGFydFwiO1xuXHRsZXQgdG9FID0gdG8rXCJFbmRcIjtcblx0bGV0IHRvSSA9IHRvK1wiSW5kZXhcIjtcblx0bGV0IG1hcHBlciA9IGZyb20rdG8rXCJNYXBcIjtcblx0Ly8gXG5cdGxldCBibGtzID0gdGhpcy5ibG9ja3Ncblx0ICAgIC8vIEZpcnN0IGZpbHRlciBmb3IgYmxvY2tzIHRoYXQgb3ZlcmxhcCB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSByYW5nZSBpbiB0aGUgZnJvbSBnZW5vbWVcblx0ICAgIC5maWx0ZXIoYmxrID0+IGJsa1tmcm9tQ10gPT09IGNociAmJiBibGtbZnJvbVNdIDw9IGVuZCAmJiBibGtbZnJvbUVdID49IHN0YXJ0KVxuXHQgICAgLy8gbWFwIGVhY2ggYmxvY2suIFxuXHQgICAgLm1hcChibGsgPT4ge1xuXHRcdC8vIGNvb3JkIHJhbmdlIG9uIHRoZSBmcm9tIHNpZGUuXG5cdFx0bGV0IHMgPSBNYXRoLm1heChzdGFydCwgYmxrW2Zyb21TXSk7XG5cdFx0bGV0IGUgPSBNYXRoLm1pbihlbmQsIGJsa1tmcm9tRV0pO1xuXHRcdC8vIGNvb3JkIHJhbmdlIG9uIHRoZSB0byBzaWRlLlxuXHRcdGxldCBzMiA9IE1hdGguY2VpbChibGtbbWFwcGVyXShzKSk7XG5cdFx0bGV0IGUyID0gTWF0aC5mbG9vcihibGtbbWFwcGVyXShlKSk7XG5cdCAgICAgICAgcmV0dXJuIGludmVydCA/IHtcblx0XHQgICAgY2hyOiAgIGJsa1tmcm9tQ10sXG5cdFx0ICAgIHN0YXJ0OiBzLFxuXHRcdCAgICBlbmQ6ICAgZSxcblx0XHQgICAgb3JpOiAgIGJsay5ibG9ja09yaSxcblx0XHQgICAgaW5kZXg6IGJsa1tmcm9tSV0sXG5cdFx0ICAgIC8vIGFsc28gcmV0dXJuIHRoZSBmcm9tR2Vub21lIGNvb3JkcyBmb3IgdGhpcyBwaWVjZSBvZiB0aGUgdHJhbnNsYXRpb25cblx0XHQgICAgZkNocjogICBibGtbdG9DXSxcblx0XHQgICAgZlN0YXJ0OiBNYXRoLm1pbihzMixlMiksXG5cdFx0ICAgIGZFbmQ6ICAgTWF0aC5tYXgoczIsZTIpLFxuXHRcdCAgICBmSW5kZXg6IGJsa1t0b0ldLFxuXHRcdCAgICAvLyBpbmNsdWRlIHRoZSBibG9jayBpZCBhbmQgZnVsbCBibG9jayBjb29yZHNcblx0XHQgICAgYmxvY2tJZDogYmxrLmJsb2NrSWQsXG5cdFx0ICAgIGJsb2NrU3RhcnQ6IGJsa1tmcm9tU10sXG5cdFx0ICAgIGJsb2NrRW5kOiBibGtbZnJvbUVdXG5cdFx0fSA6IHtcblx0XHQgICAgY2hyOiAgIGJsa1t0b0NdLFxuXHRcdCAgICBzdGFydDogTWF0aC5taW4oczIsZTIpLFxuXHRcdCAgICBlbmQ6ICAgTWF0aC5tYXgoczIsZTIpLFxuXHRcdCAgICBvcmk6ICAgYmxrLmJsb2NrT3JpLFxuXHRcdCAgICBpbmRleDogYmxrW3RvSV0sXG5cdFx0ICAgIC8vIGFsc28gcmV0dXJuIHRoZSBmcm9tR2Vub21lIGNvb3JkcyBmb3IgdGhpcyBwaWVjZSBvZiB0aGUgdHJhbnNsYXRpb25cblx0XHQgICAgZkNocjogICBibGtbZnJvbUNdLFxuXHRcdCAgICBmU3RhcnQ6IHMsXG5cdFx0ICAgIGZFbmQ6ICAgZSxcblx0XHQgICAgZkluZGV4OiBibGtbZnJvbUldLFxuXHRcdCAgICAvLyBpbmNsdWRlIHRoZSBibG9jayBpZCBhbmQgZnVsbCBibG9jayBjb29yZHNcblx0XHQgICAgYmxvY2tJZDogYmxrLmJsb2NrSWQsXG5cdFx0ICAgIGJsb2NrU3RhcnQ6IGJsa1t0b1NdLFxuXHRcdCAgICBibG9ja0VuZDogYmxrW3RvRV1cblx0XHR9O1xuXHQgICAgfSk7XG5cdGlmICghaW52ZXJ0KSB7XG5cdCAgICAvLyBMb29rIGZvciAxLWJsb2NrIGdhcHMgYW5kIGZpbGwgdGhlbSBpbi4gXG5cdCAgICBibGtzLnNvcnQoKGEsYikgPT4gYS5pbmRleCAtIGIuaW5kZXgpO1xuXHQgICAgbGV0IG5icyA9IFtdO1xuXHQgICAgYmxrcy5mb3JFYWNoKCAoYiwgaSkgPT4ge1xuXHRcdGlmIChpID09PSAwKSByZXR1cm47XG5cdFx0aWYgKGJsa3NbaV0uaW5kZXggLSBibGtzW2kgLSAxXS5pbmRleCA9PT0gMikge1xuXHRcdCAgICBsZXQgYmxrID0gdGhpcy5ibG9ja3MuZmlsdGVyKCBiID0+IGJbdG9JXSA9PT0gYmxrc1tpXS5pbmRleCAtIDEgKVswXTtcblx0XHQgICAgbmJzLnB1c2goe1xuXHRcdFx0Y2hyOiAgIGJsa1t0b0NdLFxuXHRcdFx0c3RhcnQ6IGJsa1t0b1NdLFxuXHRcdFx0ZW5kOiAgIGJsa1t0b0VdLFxuXHRcdFx0b3JpOiAgIGJsay5ibG9ja09yaSxcblx0XHRcdGluZGV4OiBibGtbdG9JXSxcblx0XHRcdC8vIGFsc28gcmV0dXJuIHRoZSBmcm9tR2Vub21lIGNvb3JkcyBmb3IgdGhpcyBwaWVjZSBvZiB0aGUgdHJhbnNsYXRpb25cblx0XHRcdGZDaHI6ICAgYmxrW2Zyb21DXSxcblx0XHRcdGZTdGFydDogYmxrW2Zyb21TXSxcblx0XHRcdGZFbmQ6ICAgYmxrW2Zyb21FXSxcblx0XHRcdGZJbmRleDogYmxrW2Zyb21JXSxcblx0XHRcdC8vIGluY2x1ZGUgdGhlIGJsb2NrIGlkIGFuZCBmdWxsIGJsb2NrIGNvb3Jkc1xuXHRcdFx0YmxvY2tJZDogYmxrLmJsb2NrSWQsXG5cdFx0XHRibG9ja1N0YXJ0OiBibGtbdG9TXSxcblx0XHRcdGJsb2NrRW5kOiBibGtbdG9FXVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdCAgICB9KTtcblx0ICAgIGJsa3MgPSBibGtzLmNvbmNhdChuYnMpO1xuXHR9XG5cdGJsa3Muc29ydCgoYSxiKSA9PiBhLmZJbmRleCAtIGIuZkluZGV4KTtcblx0cmV0dXJuIGJsa3M7XG4gICAgfVxuICAgIC8vIEdpdmVuIGEgZ2Vub21lIChlaXRoZXIgdGhlIGEgb3IgYiBnZW5vbWUpXG4gICAgLy8gcmV0dXJucyB0aGUgYmxvY2tzIGZvciB0cmFuc2xhdGluZyB0byB0aGUgb3RoZXIgKGIgb3IgYSkgZ2Vub21lLlxuICAgIC8vXG4gICAgZ2V0QmxvY2tzIChmcm9tR2Vub21lKSB7XG5cdC8vIGZyb20gPSBcImFcIiBvciBcImJcIiwgZGVwZW5kaW5nIG9uIHdoaWNoIGdlbm9tZSBpcyBnaXZlbi5cbiAgICAgICAgbGV0IGZyb20gPSAoZnJvbUdlbm9tZSA9PT0gdGhpcy5hR2Vub21lID8gXCJhXCIgOiBmcm9tR2Vub21lID09PSB0aGlzLmJHZW5vbWUgPyBcImJcIiA6IG51bGwpO1xuXHRpZiAoIWZyb20pIHRocm93IFwiQmFkIGFyZ3VtZW50LiBHZW5vbWUgbmVpdGhlciBBIG5vciBCLlwiO1xuXHQvLyB0byA9IFwiYlwiIG9yIFwiYVwiLCBvcHBvc2l0ZSBvZiBmcm9tXG5cdGxldCB0byA9IChmcm9tID09PSBcImFcIiA/IFwiYlwiIDogXCJhXCIpO1xuXHQvLyBtYWtlIHN1cmUgdGhlIGJsb2NrcyBhcmUgc29ydGVkIGJ5IHRoZSBmcm9tIGdlbm9tZVxuXHR0aGlzLnNldFNvcnQoZnJvbSk7XG5cdC8vXG5cdGxldCBmcm9tQyA9IGZyb20rXCJDaHJcIjtcblx0bGV0IGZyb21TID0gZnJvbStcIlN0YXJ0XCI7XG5cdGxldCBmcm9tRSA9IGZyb20rXCJFbmRcIjtcblx0bGV0IGZyb21JID0gZnJvbStcIkluZGV4XCI7XG5cdGxldCB0b0MgPSB0bytcIkNoclwiO1xuXHRsZXQgdG9TID0gdG8rXCJTdGFydFwiO1xuXHRsZXQgdG9FID0gdG8rXCJFbmRcIjtcblx0bGV0IHRvSSA9IHRvK1wiSW5kZXhcIjtcblx0bGV0IG1hcHBlciA9IGZyb20rdG8rXCJNYXBcIjtcblx0Ly8gXG5cdGxldCBibGtzID0gdGhpcy5ibG9ja3Ncblx0ICAgIC5tYXAoYmxrID0+IHtcblx0ICAgICAgICByZXR1cm4ge1xuXHRcdCAgICBibG9ja0lkOiAgIGJsay5ibG9ja0lkLFxuXHRcdCAgICBvcmk6ICAgICAgIGJsay5ibG9ja09yaSxcblx0XHQgICAgZnJvbUNocjogICBibGtbZnJvbUNdLFxuXHRcdCAgICBmcm9tU3RhcnQ6IGJsa1tmcm9tU10sXG5cdFx0ICAgIGZyb21FbmQ6ICAgYmxrW2Zyb21FXSxcblx0XHQgICAgZnJvbUluZGV4OiBibGtbZnJvbUldLFxuXHRcdCAgICB0b0NocjogICAgIGJsa1t0b0NdLFxuXHRcdCAgICB0b1N0YXJ0OiAgIGJsa1t0b1NdLFxuXHRcdCAgICB0b0VuZDogICAgIGJsa1t0b0VdLFxuXHRcdCAgICB0b0luZGV4OiAgIGJsa1t0b0ldXG5cdFx0fTtcblx0ICAgIH0pXG5cdC8vIFxuXHRyZXR1cm4gYmxrcztcbiAgICB9XG59XG5cbmV4cG9ydCB7IEJsb2NrVHJhbnNsYXRvciB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvQmxvY2tUcmFuc2xhdG9yLmpzXG4vLyBtb2R1bGUgaWQgPSAyMVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgeyBTVkdWaWV3IH0gZnJvbSAnLi9TVkdWaWV3JztcbmltcG9ydCB7IGNvb3Jkc0FmdGVyVHJhbnNmb3JtIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgR2Vub21lVmlldyBleHRlbmRzIFNWR1ZpZXcge1xuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNvbnN0cnVjdG9yIChhcHAsIGVsdCwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICBzdXBlcihhcHAsIGVsdCwgd2lkdGgsIGhlaWdodCk7XG5cdHRoaXMub3BlbldpZHRoID0gdGhpcy5vdXRlcldpZHRoO1xuXHR0aGlzLm9wZW5IZWlnaHQ9IHRoaXMub3V0ZXJIZWlnaHQ7XG5cdHRoaXMudG90YWxDaHJXaWR0aCA9IDQwOyAvLyB0b3RhbCB3aWR0aCBvZiBvbmUgY2hyb21vc29tZSAoYmFja2JvbmUrYmxvY2tzK2ZlYXRzKVxuXHR0aGlzLmN3aWR0aCA9IDIwOyAgICAgICAgLy8gY2hyb21vc29tZSB3aWR0aFxuXHR0aGlzLnRpY2tMZW5ndGggPSAxMDtcdCAvLyBmZWF0dXJlIHRpY2sgbWFyayBsZW5ndGhcblx0dGhpcy5icnVzaENociA9IG51bGw7XHQgLy8gd2hpY2ggY2hyIGhhcyB0aGUgY3VycmVudCBicnVzaFxuXHR0aGlzLmJ3aWR0aCA9IHRoaXMuY3dpZHRoLzI7ICAvLyBibG9jayB3aWR0aFxuXHR0aGlzLmN1cnJCbG9ja3MgPSBudWxsO1xuXHR0aGlzLmN1cnJUaWNrcyA9IG51bGw7XG5cdHRoaXMuZ0Nocm9tb3NvbWVzID0gdGhpcy5zdmdNYWluLmFwcGVuZCgnZycpLmF0dHIoXCJuYW1lXCIsIFwiY2hyb21vc29tZXNcIik7XG5cdHRoaXMudGl0bGUgICAgPSB0aGlzLnN2Z01haW4uYXBwZW5kKCd0ZXh0JykuYXR0cihcImNsYXNzXCIsIFwidGl0bGVcIik7XG5cdHRoaXMuc2Nyb2xsQW1vdW50ID0gMDtcblx0Ly9cblx0dGhpcy5pbml0RG9tKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGZpdFRvV2lkdGggKHcpe1xuICAgICAgICBzdXBlci5maXRUb1dpZHRoKHcpO1xuXHR0aGlzLm9wZW5XaWR0aCA9IHRoaXMub3V0ZXJXaWR0aDtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaW5pdERvbSAoKSB7XG5cdHRoaXMucm9vdC5zZWxlY3QoJy5idXR0b24uY2xvc2UnKVxuXHQgICAgLm9uKCdjbGljaycsICgpID0+IHRoaXMucmVkcmF3KCkpO1xuXHR0aGlzLnN2Zy5vbihcIndoZWVsXCIsICgpID0+IHtcblx0ICAgIGlmICghdGhpcy5yb290LmNsYXNzZWQoXCJjbG9zZWRcIikpIHJldHVybjtcblx0ICAgIHRoaXMuc2Nyb2xsV2hlZWwoZDMuZXZlbnQuZGVsdGFZKVxuXHQgICAgZDMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSk7XG5cdGxldCBzYnMgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cInN2Z2NvbnRhaW5lclwiXSA+IFtuYW1lPVwic2Nyb2xsYnV0dG9uc1wiXScpXG5cdHNicy5zZWxlY3QoJy5idXR0b25bbmFtZT1cInVwXCJdJykub24oXCJjbGlja1wiLCAoKSA9PiB0aGlzLnNjcm9sbENocm9tb3NvbWVzVXAoKSk7XG5cdHNicy5zZWxlY3QoJy5idXR0b25bbmFtZT1cImRuXCJdJykub24oXCJjbGlja1wiLCAoKSA9PiB0aGlzLnNjcm9sbENocm9tb3NvbWVzRG93bigpKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBzZXRCcnVzaENvb3JkcyAoY29vcmRzKSB7XG5cdHRoaXMuY2xlYXJCcnVzaGVzKCk7XG5cdHRoaXMuZ0Nocm9tb3NvbWVzLnNlbGVjdChgLmNocm9tb3NvbWVbbmFtZT1cIiR7Y29vcmRzLmNocn1cIl0gZ1tuYW1lPVwiYnJ1c2hcIl1gKVxuXHQgIC5lYWNoKGZ1bmN0aW9uKGNocil7XG5cdCAgICBjaHIuYnJ1c2guZXh0ZW50KFtjb29yZHMuc3RhcnQsY29vcmRzLmVuZF0pO1xuXHQgICAgY2hyLmJydXNoKGQzLnNlbGVjdCh0aGlzKSk7XG5cdH0pO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBicnVzaHN0YXJ0IChjaHIpe1xuXHR0aGlzLmNsZWFyQnJ1c2hlcyhjaHIuYnJ1c2gpO1xuXHR0aGlzLmJydXNoQ2hyID0gY2hyO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGJydXNoZW5kICgpe1xuXHRpZighdGhpcy5icnVzaENocikgcmV0dXJuO1xuXHRsZXQgY2MgPSB0aGlzLmFwcC5jb29yZHM7XG5cdHZhciB4dG50ID0gdGhpcy5icnVzaENoci5icnVzaC5leHRlbnQoKTtcblx0aWYgKE1hdGguYWJzKHh0bnRbMF0gLSB4dG50WzFdKSA8PSAxMCl7XG5cdCAgICAvLyB1c2VyIGNsaWNrZWRcblx0ICAgIGxldCB3ID0gY2MuZW5kIC0gY2Muc3RhcnQgKyAxO1xuXHQgICAgeHRudFswXSAtPSB3LzI7XG5cdCAgICB4dG50WzFdICs9IHcvMjtcblx0fVxuXHRsZXQgY29vcmRzID0geyBjaHI6dGhpcy5icnVzaENoci5uYW1lLCBzdGFydDpNYXRoLmZsb29yKHh0bnRbMF0pLCBlbmQ6IE1hdGguZmxvb3IoeHRudFsxXSkgfTtcblx0dGhpcy5hcHAuc2V0Q29udGV4dChjb29yZHMpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNsZWFyQnJ1c2hlcyAoZXhjZXB0KXtcblx0dGhpcy5nQ2hyb21vc29tZXMuc2VsZWN0QWxsKCdbbmFtZT1cImJydXNoXCJdJykuZWFjaChmdW5jdGlvbihjaHIpe1xuXHQgICAgaWYgKGNoci5icnVzaCAhPT0gZXhjZXB0KSB7XG5cdFx0Y2hyLmJydXNoLmNsZWFyKCk7XG5cdFx0Y2hyLmJydXNoKGQzLnNlbGVjdCh0aGlzKSk7XG5cdCAgICB9XG5cdH0pO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldFggKGNocikge1xuXHRsZXQgeCA9IHRoaXMuYXBwLnJHZW5vbWUueHNjYWxlKGNocik7XG5cdGlmIChpc05hTih4KSkgdGhyb3cgXCJ4IGlzIE5hTlwiXG5cdHJldHVybiB4O1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXRZIChwb3MpIHtcblx0bGV0IHkgPSB0aGlzLmFwcC5yR2Vub21lLnlzY2FsZShwb3MpO1xuXHRpZiAoaXNOYU4oeSkpIHRocm93IFwieSBpcyBOYU5cIlxuXHRyZXR1cm4geTtcbiAgICB9XG4gICAgXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgcmVkcmF3ICgpIHtcbiAgICAgICAgdGhpcy5kcmF3KHRoaXMuY3VyclRpY2tzLCB0aGlzLmN1cnJCbG9ja3MpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGRyYXcgKHRpY2tEYXRhLCBibG9ja0RhdGEpIHtcblx0dGhpcy5kcmF3Q2hyb21vc29tZXMoKTtcblx0dGhpcy5kcmF3QmxvY2tzKGJsb2NrRGF0YSk7XG5cdHRoaXMuZHJhd1RpY2tzKHRpY2tEYXRhKTtcblx0dGhpcy5kcmF3VGl0bGUoKTtcblx0dGhpcy5zZXRCcnVzaENvb3Jkcyh0aGlzLmFwcC5jb29yZHMpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIERyYXdzIHRoZSBjaHJvbW9zb21lcyBvZiB0aGUgcmVmZXJlbmNlIGdlbm9tZS5cbiAgICAvLyBJbmNsdWRlcyBiYWNrYm9uZXMsIGxhYmVscywgYW5kIGJydXNoZXMuXG4gICAgLy8gVGhlIGJhY2tib25lcyBhcmUgZHJhd24gYXMgdmVydGljYWwgbGluZSBzZW1lbnRzLFxuICAgIC8vIGRpc3RyaWJ1dGVkIGhvcml6b250YWxseS4gT3JkZXJpbmcgaXMgZGVmaW5lZCBieVxuICAgIC8vIHRoZSBtb2RlbCAoR2Vub21lIG9iamVjdCkuXG4gICAgLy8gTGFiZWxzIGFyZSBkcmF3biBhYm92ZSB0aGUgYmFja2JvbmVzLlxuICAgIC8vXG4gICAgLy8gTW9kaWZpY2F0aW9uOlxuICAgIC8vIERyYXdzIHRoZSBzY2VuZSBpbiBvbmUgb2YgdHdvIHN0YXRlczogb3BlbiBvciBjbG9zZWQuXG4gICAgLy8gVGhlIG9wZW4gc3RhdGUgaXMgYXMgZGVzY3JpYmVkIC0gYWxsIGNocm9tb3NvbWVzIHNob3duLlxuICAgIC8vIEluIHRoZSBjbG9zZWQgc3RhdGU6IFxuICAgIC8vICAgICAqIG9ubHkgb25lIGNocm9tb3NvbWUgc2hvd3MgKHRoZSBjdXJyZW50IG9uZSlcbiAgICAvLyAgICAgKiBkcmF3biBob3Jpem9udGFsbHkgYW5kIHBvc2l0aW9uZWQgYmVzaWRlIHRoZSBcIkdlbm9tZSBWaWV3XCIgdGl0bGVcbiAgICAvL1xuICAgIGRyYXdDaHJvbW9zb21lcyAoKSB7XG5cdGxldCBzZWxmID0gdGhpcztcblxuXHRsZXQgcmcgPSB0aGlzLmFwcC5yR2Vub21lOyAvLyByZWYgZ2Vub21lXG5cdGxldCByQ2hycyA9IHJnLmNocm9tb3NvbWVzO1xuXG4gICAgICAgIC8vIENocm9tb3NvbWUgZ3JvdXBzXG5cdGxldCBjaHJzID0gdGhpcy5nQ2hyb21vc29tZXMuc2VsZWN0QWxsKFwiLmNocm9tb3NvbWVcIilcblx0ICAgIC5kYXRhKHJDaHJzLCBjID0+IGMubmFtZSk7XG5cdGxldCBuZXdjaHJzID0gY2hycy5lbnRlcigpLmFwcGVuZChcImdcIilcblx0ICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJjaHJvbW9zb21lXCIpXG5cdCAgICAuYXR0cihcIm5hbWVcIiwgYyA9PiBjLm5hbWUpO1xuXHRcblx0bmV3Y2hycy5hcHBlbmQoXCJ0ZXh0XCIpLmF0dHIoXCJuYW1lXCIsXCJsYWJlbFwiKTtcblx0bmV3Y2hycy5hcHBlbmQoXCJsaW5lXCIpLmF0dHIoXCJuYW1lXCIsXCJiYWNrYm9uZVwiKTtcblx0bmV3Y2hycy5hcHBlbmQoXCJnXCIpLmF0dHIoXCJuYW1lXCIsXCJzeW5CbG9ja3NcIik7XG5cdG5ld2NocnMuYXBwZW5kKFwiZ1wiKS5hdHRyKFwibmFtZVwiLFwidGlja3NcIik7XG5cdG5ld2NocnMuYXBwZW5kKFwiZ1wiKS5hdHRyKFwibmFtZVwiLFwiYnJ1c2hcIik7XG5cblxuXHRsZXQgY2xvc2VkID0gdGhpcy5yb290LmNsYXNzZWQoXCJjbG9zZWRcIik7XG5cdC8vIHNldCBkaXJlY3Rpb24gb2YgdGhlIHJlc2l6ZSBjdXJzb3IuXG5cdGNocnMuc2VsZWN0QWxsKCdnW25hbWU9XCJicnVzaFwiXSBnLnJlc2l6ZScpLnN0eWxlKCdjdXJzb3InLCBjbG9zZWQgPyAnZXctcmVzaXplJyA6ICducy1yZXNpemUnKVxuXHQvL1xuXHRpZiAoY2xvc2VkKSB7XG5cdCAgICAvLyBSZXNldCB0aGUgU1ZHIHNpemUgdG8gYmUgMS1jaHJvbW9zb21lIHdpZGUuXG5cdCAgICAvLyBUcmFuc2xhdGUgdGhlIGNocm9tb3NvbWVzIGdyb3VwIHNvIHRoYXQgdGhlIGN1cnJlbnQgY2hyb21vc29tZSBhcHBlYXJzIGluIHRoZSBzdmcgYXJlYS5cblx0ICAgIC8vIFR1cm4gaXQgOTAgZGVnLlxuXG5cdCAgICAvLyBTZXQgdGhlIGhlaWdodCBvZiB0aGUgU1ZHIGFyZWEgdG8gMSBjaHJvbW9zb21lJ3Mgd2lkdGhcblx0ICAgIHRoaXMuc2V0R2VvbSh7IGhlaWdodDogdGhpcy50b3RhbENocldpZHRoLCByb3RhdGlvbjogLTkwLCB0cmFuc2xhdGlvbjogWy10aGlzLnRvdGFsQ2hyV2lkdGgvMisxMCwzMF0gfSk7XG5cdCAgICAvLyBcblx0ICAgIGxldCBkZWx0YSA9IDEwO1xuXHQgICAgcmcueHNjYWxlID0gZDMuc2NhbGUub3JkaW5hbCgpXG5cdFx0IC5kb21haW4ockNocnMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiB4Lm5hbWU7fSkpXG5cdFx0IC8vIGluIGNsb3NlZCBtb2RlLCB0aGUgY2hyb21vc29tZXMgaGF2ZSBmaXhlZCBzcGFjaW5nXG5cdFx0IC5yYW5nZVBvaW50cyhbZGVsdGEsIGRlbHRhK3RoaXMudG90YWxDaHJXaWR0aCoockNocnMubGVuZ3RoLTEpXSk7XG5cdCAgICAvL1xuXHQgICAgcmcueXNjYWxlID0gZDMuc2NhbGUubGluZWFyKClcblx0XHQgLmRvbWFpbihbMSxyZy5tYXhsZW5dKVxuXHRcdCAucmFuZ2UoWzAsIHRoaXMud2lkdGhdKTtcblxuXHQgICAgLy8gdHJhbnNsYXRlIGVhY2ggY2hyb21vc29tZSBpbnRvIHBvc2l0aW9uXG5cdCAgICBjaHJzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYyA9PiBgdHJhbnNsYXRlKCR7cmcueHNjYWxlKGMubmFtZSl9LCAwKWApO1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSBjaHJvbW9zb21lcyBncm91cC5cblx0ICAgIHRoaXMuc2Nyb2xsQ2hyb21vc29tZXNUbygtcmcueHNjYWxlKHRoaXMuYXBwLmNvb3Jkcy5jaHIpKTtcblx0ICAgIHRoaXMuc2Nyb2xsQ2hyb21vc29tZXNTbmFwKCk7XG5cdH1cblx0ZWxzZSB7XG5cdCAgICAvLyBXaGVuIG9wZW4sIGRyYXcgYWxsIHRoZSBjaHJvbW9zb21lcy4gRWFjaCBjaHJvbSBpcyBhIHZlcnRpY2FsIGxpbmUuXG5cdCAgICAvLyBDaHJvbXMgYXJlIGRpc3RyaWJ1dGVkIGV2ZW5seSBhY3Jvc3MgdGhlIGF2YWlsYWJsZSBob3Jpem9udGFsIHNwYWNlLlxuXHQgICAgdGhpcy5zZXRHZW9tKHsgd2lkdGg6IHRoaXMub3BlbldpZHRoLCBoZWlnaHQ6IHRoaXMub3BlbkhlaWdodCwgcm90YXRpb246IDAsIHRyYW5zbGF0aW9uOiBbMCwwXSB9KTtcblx0ICAgIC8vIFxuXHQgICAgcmcueHNjYWxlID0gZDMuc2NhbGUub3JkaW5hbCgpXG5cdFx0IC5kb21haW4ockNocnMubWFwKGZ1bmN0aW9uKHgpe3JldHVybiB4Lm5hbWU7fSkpXG5cdFx0IC8vIGluIGNsb3NlZCBtb2RlLCB0aGUgY2hyb21vc29tZXMgc3ByZWFkIHRvIGZpbGwgdGhlIHNwYWNlXG5cdFx0IC5yYW5nZVBvaW50cyhbMCwgdGhpcy5vcGVuV2lkdGggLSAzMF0sIDAuNSk7XG5cdCAgICByZy55c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuXHRcdCAuZG9tYWluKFsxLHJnLm1heGxlbl0pXG5cdFx0IC5yYW5nZShbMCwgdGhpcy5oZWlnaHRdKTtcblxuXHQgICAgLy8gdHJhbnNsYXRlIGVhY2ggY2hyb21vc29tZSBpbnRvIHBvc2l0aW9uXG5cdCAgICBjaHJzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYyA9PiBgdHJhbnNsYXRlKCR7cmcueHNjYWxlKGMubmFtZSl9LCAwKWApO1xuICAgICAgICAgICAgLy8gdHJhbnNsYXRlIHRoZSBjaHJvbW9zb21lcyBncm91cC5cblx0ICAgIHRoaXMuc2Nyb2xsQ2hyb21vc29tZXNUbygwKTtcblx0fVxuXG5cdHJDaHJzLmZvckVhY2goY2hyID0+IHtcblx0ICAgIHZhciBzYyA9IGQzLnNjYWxlLmxpbmVhcigpXG5cdFx0LmRvbWFpbihbMSxjaHIubGVuZ3RoXSlcblx0XHQucmFuZ2UoWzAsIHJnLnlzY2FsZShjaHIubGVuZ3RoKV0pO1xuXHQgICAgY2hyLmJydXNoID0gZDMuc3ZnLmJydXNoKCkueShzYylcblx0ICAgICAgIC5vbihcImJydXNoc3RhcnRcIiwgY2hyID0+IHRoaXMuYnJ1c2hzdGFydChjaHIpKVxuXHQgICAgICAgLm9uKFwiYnJ1c2hlbmRcIiwgKCkgPT4gdGhpcy5icnVzaGVuZCgpKTtcblx0ICB9LCB0aGlzKTtcblxuXG4gICAgICAgIGNocnMuc2VsZWN0KCdbbmFtZT1cImxhYmVsXCJdJylcblx0ICAgIC50ZXh0KGM9PmMubmFtZSlcblx0ICAgIC5hdHRyKFwieFwiLCAwKSBcblx0ICAgIC5hdHRyKFwieVwiLCAtMilcblx0ICAgIDtcblxuXHRjaHJzLnNlbGVjdCgnW25hbWU9XCJiYWNrYm9uZVwiXScpXG5cdCAgICAuYXR0cihcIngxXCIsIDApXG5cdCAgICAuYXR0cihcInkxXCIsIDApXG5cdCAgICAuYXR0cihcIngyXCIsIDApXG5cdCAgICAuYXR0cihcInkyXCIsIGMgPT4gcmcueXNjYWxlKGMubGVuZ3RoKSlcblx0ICAgIDtcblx0ICAgXG5cdGNocnMuc2VsZWN0KCdbbmFtZT1cImJydXNoXCJdJylcblx0ICAgIC5lYWNoKGZ1bmN0aW9uKGQpe2QzLnNlbGVjdCh0aGlzKS5jYWxsKGQuYnJ1c2gpO30pXG5cdCAgICAuc2VsZWN0QWxsKCdyZWN0Jylcblx0ICAgICAuYXR0cignd2lkdGgnLDE2KVxuXHQgICAgIC5hdHRyKCd4JywgLTgpXG5cdCAgICA7XG5cblx0Y2hycy5leGl0KCkucmVtb3ZlKCk7XG5cdFxuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNjcm9sbCB3aGVlbCBldmVudCBoYW5kbGVyLlxuICAgIHNjcm9sbFdoZWVsIChkeSkge1xuXHQvLyBBZGQgZHkgdG8gdG90YWwgc2Nyb2xsIGFtb3VudC4gVGhlbiB0cmFuc2xhdGUgdGhlIGNocm9tb3NvbWVzIGdyb3VwLlxuXHR0aGlzLnNjcm9sbENocm9tb3NvbWVzQnkoZHkpO1xuXHQvLyBBZnRlciBhIDIwMCBtcyBwYXVzZSBpbiBzY3JvbGxpbmcsIHNuYXAgdG8gbmVhcmVzdCBjaHJvbW9zb21lXG5cdHRoaXMudG91dCAmJiB3aW5kb3cuY2xlYXJUaW1lb3V0KHRoaXMudG91dCk7XG5cdHRoaXMudG91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCgpPT50aGlzLnNjcm9sbENocm9tb3NvbWVzU25hcCgpLCAyMDApO1xuICAgIH1cbiAgICBzY3JvbGxDaHJvbW9zb21lc1RvICh4KSB7XG4gICAgICAgIGlmICh4ID09PSB1bmRlZmluZWQpIHggPSB0aGlzLnNjcm9sbEFtb3VudDtcblx0dGhpcy5zY3JvbGxBbW91bnQgPSBNYXRoLm1heChNYXRoLm1pbih4LDE1KSwgLXRoaXMudG90YWxDaHJXaWR0aCAqICh0aGlzLmFwcC5yR2Vub21lLmNocm9tb3NvbWVzLmxlbmd0aC0xKSk7XG5cdHRoaXMuZ0Nocm9tb3NvbWVzLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgYHRyYW5zbGF0ZSgke3RoaXMuc2Nyb2xsQW1vdW50fSwwKWApO1xuICAgIH1cbiAgICBzY3JvbGxDaHJvbW9zb21lc0J5IChkeCkge1xuICAgICAgICB0aGlzLnNjcm9sbENocm9tb3NvbWVzVG8odGhpcy5zY3JvbGxBbW91bnQgKyBkeCk7XG4gICAgfVxuICAgIHNjcm9sbENocm9tb3NvbWVzU25hcCAoKSB7XG5cdGxldCBpID0gTWF0aC5yb3VuZCh0aGlzLnNjcm9sbEFtb3VudCAvIHRoaXMudG90YWxDaHJXaWR0aClcblx0dGhpcy5zY3JvbGxDaHJvbW9zb21lc1RvKGkqdGhpcy50b3RhbENocldpZHRoKTtcbiAgICB9XG4gICAgc2Nyb2xsQ2hyb21vc29tZXNVcCAoKSB7XG4gICAgICAgIHRoaXMuc2Nyb2xsQ2hyb21vc29tZXNCeSgtdGhpcy50b3RhbENocldpZHRoKTtcblx0dGhpcy5zY3JvbGxDaHJvbW9zb21lc1NuYXAoKTtcbiAgICB9XG4gICAgc2Nyb2xsQ2hyb21vc29tZXNEb3duICgpIHtcbiAgICAgICAgdGhpcy5zY3JvbGxDaHJvbW9zb21lc0J5KHRoaXMudG90YWxDaHJXaWR0aCk7XG5cdHRoaXMuc2Nyb2xsQ2hyb21vc29tZXNTbmFwKCk7XG4gICAgfVxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGRyYXdUaXRsZSAoKSB7XG5cdGxldCByZWZnID0gdGhpcy5hcHAuckdlbm9tZS5sYWJlbDtcblx0bGV0IGJsb2NrZyA9IHRoaXMuY3VyckJsb2NrcyA/IFxuXHQgICAgdGhpcy5jdXJyQmxvY2tzLmNvbXAgIT09IHRoaXMuYXBwLnJHZW5vbWUgP1xuXHQgICAgICAgIHRoaXMuY3VyckJsb2Nrcy5jb21wLmxhYmVsXG5cdFx0OlxuXHRcdG51bGxcblx0ICAgIDpcblx0ICAgIG51bGw7XG5cdGxldCBsc3QgPSB0aGlzLmFwcC5jdXJyTGlzdCA/IHRoaXMuYXBwLmN1cnJMaXN0Lm5hbWUgOiBudWxsO1xuXG5cdHRoaXMucm9vdC5zZWxlY3QoXCJsYWJlbCBzcGFuLnRpdGxlXCIpLnRleHQocmVmZyk7XG5cblx0bGV0IGxpbmVzID0gW107XG5cdGJsb2NrZyAmJiBsaW5lcy5wdXNoKGBCbG9ja3MgdnMuICR7YmxvY2tnfWApO1xuXHRsc3QgJiYgbGluZXMucHVzaChgRmVhdHVyZXMgZnJvbSBsaXN0IFwiJHtsc3R9XCJgKTtcblx0bGV0IHN1YnQgPSBsaW5lcy5qb2luKFwiIDo6IFwiKTtcblx0dGhpcy5yb290LnNlbGVjdChcImxhYmVsIHNwYW4uc3VidGl0bGVcIikudGV4dCgoc3VidCA/IFwiOjogXCIgOiBcIlwiKSArIHN1YnQpO1xuICAgIH1cblxuICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIERyYXdzIHRoZSBvdXRsaW5lcyBvZiBzeW50ZW55IGJsb2NrcyBvZiB0aGUgcmVmIGdlbm9tZSB2cy5cbiAgICAvLyB0aGUgZ2l2ZW4gZ2Vub21lLlxuICAgIC8vIFBhc3NpbmcgbnVsbCBlcmFzZXMgYWxsIHN5bnRlbnkgYmxvY2tzLlxuICAgIC8vIEFyZ3M6XG4gICAgLy8gICAgZGF0YSA9PSB7IHJlZjpHZW5vbWUsIGNvbXA6R2Vub21lLCBibG9ja3M6IGxpc3Qgb2Ygc3ludGVueSBibG9ja3MgfVxuICAgIC8vICAgIEVhY2ggc2Jsb2NrID09PSB7IGJsb2NrSWQ6aW50LCBvcmk6Ky8tLCBmcm9tQ2hyLCBmcm9tU3RhcnQsIGZyb21FbmQsIHRvQ2hyLCB0b1N0YXJ0LCB0b0VuZCB9XG4gICAgZHJhd0Jsb2NrcyAoZGF0YSkge1xuXHQvL1xuICAgICAgICBsZXQgc2JncnBzID0gdGhpcy5nQ2hyb21vc29tZXMuc2VsZWN0QWxsKFwiLmNocm9tb3NvbWVcIikuc2VsZWN0KCdbbmFtZT1cInN5bkJsb2Nrc1wiXScpO1xuXHRpZiAoIWRhdGEgfHwgIWRhdGEuYmxvY2tzIHx8IGRhdGEuYmxvY2tzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgdGhpcy5jdXJyQmxvY2tzID0gbnVsbDtcblx0ICAgIHNiZ3Jwcy5odG1sKCcnKTtcblx0ICAgIHRoaXMuZHJhd1RpdGxlKCk7XG5cdCAgICByZXR1cm47XG5cdH1cblx0dGhpcy5jdXJyQmxvY2tzID0gZGF0YTtcblx0Ly8gcmVvcmdhbml6ZSBkYXRhIHRvIHJlZmxlY3QgU1ZHIHN0cnVjdHVyZSB3ZSB3YW50LCBpZSwgZ3JvdXBlZCBieSBjaHJvbW9zb21lXG4gICAgICAgIGxldCBkeCA9IGRhdGEuYmxvY2tzLnJlZHVjZSgoYSxzYikgPT4ge1xuXHRcdGlmICghYVtzYi5mcm9tQ2hyXSkgYVtzYi5mcm9tQ2hyXSA9IFtdO1xuXHRcdGFbc2IuZnJvbUNocl0ucHVzaChzYik7XG5cdFx0cmV0dXJuIGE7XG5cdCAgICB9LCB7fSk7XG5cdHNiZ3Jwcy5lYWNoKGZ1bmN0aW9uKGMpe1xuXHQgICAgZDMuc2VsZWN0KHRoaXMpLmRhdHVtKHtjaHI6IGMubmFtZSwgYmxvY2tzOiBkeFtjLm5hbWVdIHx8IFtdIH0pO1xuXHR9KTtcblxuXHRsZXQgYndpZHRoID0gMTA7XG4gICAgICAgIGxldCBzYmxvY2tzID0gc2JncnBzLnNlbGVjdEFsbCgncmVjdC5zYmxvY2snKS5kYXRhKGI9PmIuYmxvY2tzKTtcbiAgICAgICAgbGV0IG5ld2JzID0gc2Jsb2Nrcy5lbnRlcigpLmFwcGVuZCgncmVjdCcpLmF0dHIoJ2NsYXNzJywnc2Jsb2NrJyk7XG5cdHNibG9ja3Ncblx0ICAgIC5hdHRyKFwieFwiLCAtYndpZHRoLzIgKVxuXHQgICAgLmF0dHIoXCJ5XCIsIGIgPT4gdGhpcy5nZXRZKGIuZnJvbVN0YXJ0KSlcblx0ICAgIC5hdHRyKFwid2lkdGhcIiwgYndpZHRoKVxuXHQgICAgLmF0dHIoXCJoZWlnaHRcIiwgYiA9PiBNYXRoLm1heCgwLHRoaXMuZ2V0WShiLmZyb21FbmQgLSBiLmZyb21TdGFydCArIDEpKSlcblx0ICAgIC5jbGFzc2VkKFwiaW52ZXJzaW9uXCIsIGIgPT4gYi5vcmkgPT09IFwiLVwiKVxuXHQgICAgLmNsYXNzZWQoXCJ0cmFuc2xvY2F0aW9uXCIsIGIgPT4gYi5mcm9tQ2hyICE9PSBiLnRvQ2hyKVxuXHQgICAgO1xuXG4gICAgICAgIHNibG9ja3MuZXhpdCgpLnJlbW92ZSgpO1xuXG5cdHRoaXMuZHJhd1RpdGxlKCk7XG4gICAgfVxuXG4gICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZHJhd1RpY2tzIChpZHMpIHtcblx0dGhpcy5jdXJyVGlja3MgPSBpZHMgfHwgW107XG5cdHRoaXMuYXBwLmZlYXR1cmVNYW5hZ2VyLmdldEZlYXR1cmVzQnlJZCh0aGlzLmFwcC5yR2Vub21lLCB0aGlzLmN1cnJUaWNrcylcblx0ICAgIC50aGVuKCBmZWF0cyA9PiB7IHRoaXMuX2RyYXdUaWNrcyhmZWF0cyk7IH0pO1xuICAgIH1cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBfZHJhd1RpY2tzIChmZWF0dXJlcykge1xuXHRsZXQgcmcgPSB0aGlzLmFwcC5yR2Vub21lOyAvLyByZWYgZ2Vub21lXG5cdC8vIGZlYXR1cmUgdGljayBtYXJrc1xuXHRpZiAoIWZlYXR1cmVzIHx8IGZlYXR1cmVzLmxlbmd0aCA9PT0gMCkge1xuXHQgICAgdGhpcy5nQ2hyb21vc29tZXMuc2VsZWN0QWxsKCdbbmFtZT1cInRpY2tzXCJdJykuc2VsZWN0QWxsKFwiLmZlYXR1cmVcIikucmVtb3ZlKCk7XG5cdCAgICByZXR1cm47XG5cdH1cblxuXHQvL1xuXHRsZXQgdEdycHMgPSB0aGlzLmdDaHJvbW9zb21lcy5zZWxlY3RBbGwoXCIuY2hyb21vc29tZVwiKS5zZWxlY3QoJ1tuYW1lPVwidGlja3NcIl0nKTtcblxuXHQvLyBncm91cCBmZWF0dXJlcyBieSBjaHJvbW9zb21lXG4gICAgICAgIGxldCBmaXggPSBmZWF0dXJlcy5yZWR1Y2UoKGEsZikgPT4geyBcblx0ICAgIGlmICghIGFbZi5jaHJdKSBhW2YuY2hyXSA9IFtdO1xuXHQgICAgYVtmLmNocl0ucHVzaChmKTtcblx0ICAgIHJldHVybiBhO1xuXHR9LCB7fSlcblx0dEdycHMuZWFjaChmdW5jdGlvbihjKSB7XG5cdCAgICBkMy5zZWxlY3QodGhpcykuZGF0dW0oIHsgY2hyOiBjLCBmZWF0dXJlczogZml4W2MubmFtZV0gIHx8IFtdfSApO1xuXHR9KTtcblxuXHQvLyB0aGUgdGljayBlbGVtZW50c1xuICAgICAgICBsZXQgZmVhdHMgPSB0R3Jwcy5zZWxlY3RBbGwoXCIuZmVhdHVyZVwiKVxuXHQgICAgLmRhdGEoZCA9PiBkLmZlYXR1cmVzLCBkID0+IGQuSUQpO1xuXHQvL1xuXHRsZXQgeEFkaiA9IGYgPT4gKGYuc3RyYW5kID09PSBcIitcIiA/IHRoaXMudGlja0xlbmd0aCA6IC10aGlzLnRpY2tMZW5ndGgpO1xuXHQvL1xuXHRsZXQgc2hhcGUgPSBcImNpcmNsZVwiOyAgLy8gXCJjaXJjbGVcIiBvciBcImxpbmVcIlxuXHQvL1xuXHRsZXQgbmV3ZnMgPSBmZWF0cy5lbnRlcigpXG5cdCAgICAuYXBwZW5kKHNoYXBlKVxuXHQgICAgLmF0dHIoXCJjbGFzc1wiLFwiZmVhdHVyZVwiKVxuXHQgICAgLm9uKCdjbGljaycsIChmKSA9PiB7XG5cdFx0bGV0IGkgPSBmLmNhbm9uaWNhbHx8Zi5JRDtcblx0ICAgICAgICB0aGlzLmFwcC5zZXRDb250ZXh0KHtsYW5kbWFyazppLCBoaWdobGlnaHQ6W2ldfSk7XG5cdCAgICB9KSA7XG5cdG5ld2ZzLmFwcGVuZChcInRpdGxlXCIpXG5cdFx0LnRleHQoZj0+Zi5zeW1ib2wgfHwgZi5pZCk7XG5cdGlmIChzaGFwZSA9PT0gXCJsaW5lXCIpIHtcblx0ICAgIGZlYXRzLmF0dHIoXCJ4MVwiLCBmID0+IHhBZGooZikgKyA1KVxuXHQgICAgZmVhdHMuYXR0cihcInkxXCIsIGYgPT4gcmcueXNjYWxlKGYuc3RhcnQpKVxuXHQgICAgZmVhdHMuYXR0cihcIngyXCIsIGYgPT4geEFkaihmKSArIHRoaXMudGlja0xlbmd0aCArIDUpXG5cdCAgICBmZWF0cy5hdHRyKFwieTJcIiwgZiA9PiByZy55c2NhbGUoZi5zdGFydCkpXG5cdH1cblx0ZWxzZSB7XG5cdCAgICBmZWF0cy5hdHRyKFwiY3hcIiwgZiA9PiB4QWRqKGYpKVxuXHQgICAgZmVhdHMuYXR0cihcImN5XCIsIGYgPT4gcmcueXNjYWxlKGYuc3RhcnQpKVxuXHQgICAgZmVhdHMuYXR0cihcInJcIiwgIHRoaXMudGlja0xlbmd0aCAvIDIpO1xuXHR9XG5cdC8vXG5cdGZlYXRzLmV4aXQoKS5yZW1vdmUoKVxuICAgIH1cbn0gLy8gZW5kIGNsYXNzIEdlbm9tZVZpZXdcblxuZXhwb3J0IHsgR2Vub21lVmlldyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvR2Vub21lVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjJcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi9Db21wb25lbnQnO1xuXG5jbGFzcyBGZWF0dXJlRGV0YWlscyBleHRlbmRzIENvbXBvbmVudCB7XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgY29uc3RydWN0b3IgKGFwcCwgZWx0KSB7XG4gICAgICAgIHN1cGVyKGFwcCwgZWx0KTtcblx0dGhpcy5pbml0RG9tICgpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGluaXREb20gKCkge1xuXHQvL1xuXHR0aGlzLnJvb3Quc2VsZWN0IChcIi5idXR0b24uY2xvc2VcIilcblx0ICAgIC5vbihcImNsaWNrLmV4dHJhXCIsICgpID0+IHRoaXMudXBkYXRlKCkpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vXG4gICAgdXBkYXRlKGYpIHtcblx0Ly8gaWYgY2FsbGVkIHdpdGggbm8gYXJncywgdXBkYXRlIHVzaW5nIHRoZSBwcmV2aW91cyBmZWF0dXJlXG5cdGYgPSBmIHx8IHRoaXMubGFzdEZlYXR1cmU7XG5cdGlmICghZikge1xuXHQgICAvLyBGSVhNRTogbWFqb3IgcmVhY2hvdmVyIGluIHRoaXMgc2VjdGlvblxuXHQgICAvL1xuXHQgICAvLyBmYWxsYmFjay4gdGFrZSB0aGUgZmlyc3QgaGlnaGxpZ2h0ZWQuXG5cdCAgIGxldCByID0gdGhpcy5hcHAuem9vbVZpZXcuc3ZnTWFpbi5zZWxlY3QoXCJyZWN0LmZlYXR1cmUuaGlnaGxpZ2h0XCIpWzBdWzBdO1xuXHQgICAvLyBmYWxsYmFjay4gdGFrZSB0aGUgZmlyc3QgZmVhdHVyZVxuXHQgICBpZiAoIXIpIHIgPSB0aGlzLmFwcC56b29tVmlldy5zdmdNYWluLnNlbGVjdChcInJlY3QuZmVhdHVyZVwiKVswXVswXTtcblx0ICAgaWYgKHIpIGYgPSByLl9fZGF0YV9fO1xuXHR9XG5cdC8vIHJlbWVtYmVyXG4gICAgICAgIGlmICghZikgdGhyb3cgXCJDYW5ub3QgdXBkYXRlIGZlYXR1cmUgZGV0YWlscy4gTm8gZmVhdHVyZS5cIjtcblx0dGhpcy5sYXN0RmVhdHVyZSA9IGY7XG5cblx0Ly8gbGlzdCBvZiBmZWF0dXJlcyB0byBzaG93IGluIGRldGFpbHMgYXJlYS5cblx0Ly8gdGhlIGdpdmVuIGZlYXR1cmUgYW5kIGFsbCBlcXVpdmFsZW50cyBpbiBvdGhlciBnZW5vbWVzLlxuXHRsZXQgZmxpc3QgPSBbZl07XG5cdGlmIChmLmNhbm9uaWNhbCkge1xuXHQgICAgLy8gRklYTUU6IHJlYWNob3ZlclxuXHQgICAgZmxpc3QgPSB0aGlzLmFwcC5mZWF0dXJlTWFuYWdlci5nZXRDYWNoZWRGZWF0dXJlc0J5Q2Fub25pY2FsSWQoZi5jYW5vbmljYWwpO1xuXHR9XG5cdC8vIEdvdCB0aGUgbGlzdC4gTm93IG9yZGVyIGl0IHRoZSBzYW1lIGFzIHRoZSBkaXNwbGF5ZWQgZ2Vub21lc1xuXHQvLyBidWlsZCBpbmRleCBvZiBnZW5vbWUgbmFtZSAtPiBmZWF0dXJlIGluIGZsaXN0XG5cdGxldCBpeCA9IGZsaXN0LnJlZHVjZSgoYWNjLGYpID0+IHsgYWNjW2YuZ2Vub21lLm5hbWVdID0gZjsgcmV0dXJuIGFjYzsgfSwge30pXG5cdGxldCBnZW5vbWVPcmRlciA9IChbdGhpcy5hcHAuckdlbm9tZV0uY29uY2F0KHRoaXMuYXBwLmNHZW5vbWVzKSk7XG5cdGZsaXN0ID0gZ2Vub21lT3JkZXIubWFwKGcgPT4gaXhbZy5uYW1lXSB8fCBudWxsKTtcblx0Ly9cblx0bGV0IGNvbEhlYWRlcnMgPSBbXG5cdCAgICAvLyBjb2x1bW5zIGhlYWRlcnMgYW5kIHRoZWlyICUgd2lkdGhzXG5cdCAgICBbXCJDYW5vbmljYWwgaWRcIiAgICAgLDEwXSxcblx0ICAgIFtcIkNhbm9uaWNhbCBzeW1ib2xcIiAsMTBdLFxuXHQgICAgW1wiR2Vub21lXCIgICAgICw5XSxcblx0ICAgIFtcIklEXCIgICAgICwxN10sXG5cdCAgICBbXCJUeXBlXCIgICAgICAgLDEwLjVdLFxuXHQgICAgW1wiQmlvVHlwZVwiICAgICwxOC41XSxcblx0ICAgIFtcIkNvb3JkaW5hdGVzXCIsMThdLFxuXHQgICAgW1wiTGVuZ3RoXCIgICAgICw3XVxuXHRdO1xuXHQvLyBJbiB0aGUgY2xvc2VkIHN0YXRlLCBvbmx5IHNob3cgdGhlIGhlYWRlciBhbmQgdGhlIHJvdyBmb3IgdGhlIHBhc3NlZCBmZWF0dXJlXG5cdGlmICh0aGlzLnJvb3QuY2xhc3NlZCgnY2xvc2VkJykpXG5cdCAgICBmbGlzdCA9IGZsaXN0LmZpbHRlciggKGZmLCBpKSA9PiBmZiA9PT0gZiApO1xuXHQvLyBEcmF3IHRoZSB0YWJsZVxuXHRsZXQgdCA9IHRoaXMucm9vdC5zZWxlY3QoJ3RhYmxlJyk7XG5cdGxldCByb3dzID0gdC5zZWxlY3RBbGwoJ3RyJykuZGF0YSggW2NvbEhlYWRlcnNdLmNvbmNhdChmbGlzdCkgKTtcblx0cm93cy5lbnRlcigpLmFwcGVuZCgndHInKVxuXHQgIC5vbihcIm1vdXNlZW50ZXJcIiwgKGYsaSkgPT4gaSAhPT0gMCAmJiB0aGlzLmFwcC56b29tVmlldy5oaWdobGlnaHQoZiwgdHJ1ZSkpXG5cdCAgLm9uKFwibW91c2VsZWF2ZVwiLCAoZixpKSA9PiBpICE9PSAwICYmIHRoaXMuYXBwLnpvb21WaWV3LmhpZ2hsaWdodCgpKTtcblx0ICAgICAgXG5cdHJvd3MuZXhpdCgpLnJlbW92ZSgpO1xuXHRyb3dzLmNsYXNzZWQoXCJoaWdobGlnaHRcIiwgKGZmLCBpKSA9PiAoaSAhPT0gMCAmJiBmZiA9PT0gZikpO1xuXHQvL1xuXHQvLyBHaXZlbiBhIGZlYXR1cmUsIHJldHVybnMgYSBsaXN0IG9mIHN0cmluZ3MgZm9yIHBvcHVsYXRpbmcgYSB0YWJsZSByb3cuXG5cdC8vIElmIGk9PT0wLCB0aGVuIGYgaXMgbm90IGEgZmVhdHVyZSwgYnV0IGEgbGlzdCBjb2x1bW5zIG5hbWVzK3dpZHRocy5cblx0Ly8gXG5cdGxldCBjZWxsRGF0YSA9IGZ1bmN0aW9uIChmLCBpKSB7XG5cdCAgICBpZiAoaSA9PT0gMCkge1xuXHRcdHJldHVybiBmO1xuXHQgICAgfVxuXHQgICAgbGV0IGNlbGxEYXRhID0gWyBcIi5cIiwgXCIuXCIsIGdlbm9tZU9yZGVyW2ktMV0ubGFiZWwsIFwiLlwiLCBcIi5cIiwgXCIuXCIsIFwiLlwiLCBcIi5cIiBdO1xuXHQgICAgLy8gZiBpcyBudWxsIGlmIGl0IGRvZXNuJ3QgZXhpc3QgZm9yIGdlbm9tZSBpIFxuXHQgICAgaWYgKGYpIHtcblx0XHRsZXQgbGluayA9IFwiXCI7XG5cdFx0bGV0IGNhbm9uaWNhbCA9IGYuY2Fub25pY2FsIHx8IFwiXCI7XG5cdFx0aWYgKGNhbm9uaWNhbCkge1xuXHRcdCAgICBsZXQgdXJsID0gYGh0dHA6Ly93d3cuaW5mb3JtYXRpY3MuamF4Lm9yZy9hY2Nlc3Npb24vJHtjYW5vbmljYWx9YDtcblx0XHQgICAgbGluayA9IGA8YSB0YXJnZXQ9XCJfYmxhbmtcIiBocmVmPVwiJHt1cmx9XCI+JHtjYW5vbmljYWx9PC9hPmA7XG5cdFx0fVxuXHRcdGNlbGxEYXRhID0gW1xuXHRcdCAgICBsaW5rIHx8IGNhbm9uaWNhbCxcblx0XHQgICAgZi5zeW1ib2wsXG5cdFx0ICAgIGYuZ2Vub21lLmxhYmVsLFxuXHRcdCAgICBmLklELFxuXHRcdCAgICBmLnR5cGUsXG5cdFx0ICAgIGYuYmlvdHlwZSxcblx0XHQgICAgYCR7Zi5jaHJ9OiR7Zi5zdGFydH0uLiR7Zi5lbmR9ICgke2Yuc3RyYW5kfSlgLFxuXHRcdCAgICBgJHtmLmVuZCAtIGYuc3RhcnQgKyAxfSBicGBcblx0XHRdO1xuXHQgICAgfVxuXHQgICAgcmV0dXJuIGNlbGxEYXRhO1xuXHR9O1xuXHRsZXQgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG5cdCAgICAuZGF0YSgoZixpKSA9PiBjZWxsRGF0YShmLGkpKTtcblx0Y2VsbHMuZW50ZXIoKS5hcHBlbmQoXCJ0ZFwiKTtcblx0Y2VsbHMuZXhpdCgpLnJlbW92ZSgpO1xuXHRjZWxscy5odG1sKChkLGksaikgPT4ge1xuXHQgICAgcmV0dXJuIGogPT09IDAgPyBkWzBdIDogZFxuXHR9KVxuXHQuc3R5bGUoXCJ3aWR0aFwiLCAoZCxpLGopID0+IGogPT09IDAgPyBgJHtkWzFdfSVgIDogbnVsbCk7XG4gICAgfVxufVxuXG5leHBvcnQgeyBGZWF0dXJlRGV0YWlscyB9O1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi93d3cvanMvRmVhdHVyZURldGFpbHMuanNcbi8vIG1vZHVsZSBpZCA9IDIzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImltcG9ydCBjb25maWcgZnJvbSAnLi9jb25maWcnO1xuaW1wb3J0IHsgU1ZHVmlldyB9IGZyb20gJy4vU1ZHVmlldyc7XG5pbXBvcnQgeyBGZWF0dXJlIH0gZnJvbSAnLi9GZWF0dXJlJztcbmltcG9ydCB7IHByZXR0eVByaW50QmFzZXMsIGNsaXAsIHBhcnNlQ29vcmRzLCBmb3JtYXRDb29yZHMsIGNvb3Jkc0FmdGVyVHJhbnNmb3JtLCByZW1vdmVEdXBzIH0gZnJvbSAnLi91dGlscyc7XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuY2xhc3MgWm9vbVZpZXcgZXh0ZW5kcyBTVkdWaWV3IHtcbiAgICAvL1xuICAgIGNvbnN0cnVjdG9yIChhcHAsIGVsdCwgd2lkdGgsIGhlaWdodCwgaW5pdGlhbENvb3JkcywgaW5pdGlhbEhpKSB7XG4gICAgICBzdXBlcihhcHAsIGVsdCwgd2lkdGgsIGhlaWdodCk7XG4gICAgICAvL1xuICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuICAgICAgLy9cbiAgICAgIHRoaXMuZHJhd0NvdW50ID0gMDtcbiAgICAgIHRoaXMuY2ZnID0gY29uZmlnLlpvb21WaWV3O1xuICAgICAgdGhpcy5kbW9kZSA9ICdjb21wYXJpc29uJzsvLyBkcmF3aW5nIG1vZGUuICdjb21wYXJpc29uJyBvciAncmVmZXJlbmNlJ1xuICAgICAgLy8gQSBmZWF0dXJlIG1heSBiZSByZW5kZXJlZCBpbiBvbmUgb2YgdHdvIHdheXM6IGFzIGEgc2ltcGxlIHJlY3QsIG9yIGFzIGEgZ3JvdXAgY29udGFpbmluZyB0aGUgXG4gICAgICAvLyByZWN0IGFuZCBvdGhlciBzdHVmZiBsaWtlIHRleHQsIGFuIGF4aXMgbGluZSwgZXRjLlxuICAgICAgdGhpcy5fc2hvd0ZlYXR1cmVEZXRhaWxzID0gZmFsc2U7IC8vIGlmIHRydWUsIHNob3cgdHJhbnNjcmlwdC9leG9uIHN0cnVjdHVyZVxuICAgICAgdGhpcy5fc2hvd0FsbExhYmVscyA9IHRydWU7IC8vIGlmIHRydWUsIHNob3cgYWxsIGZlYXR1cmUgbGFiZWxzIChvbmx5IGlmIHNob3dGZWF0dXJlRGV0YWlsID0gdHJ1ZSlcbiAgICAgIHRoaXMuY2xlYXJBbGwgPSBmYWxzZTsgLy8gaWYgdHJ1ZSwgcmVtb3ZlL3JlcmVuZGVyIGFsbCBleGlzdGluZyBmZWF0dXJlcyBvbiBuZXh0IGRyYXdcbiAgICAgIC8vXG4gICAgICAvLyBJRHMgb2YgRmVhdHVyZXMgd2UncmUgaGlnaGxpZ2h0aW5nLiBNYXkgYmUgZmVhdHVyZSdzIElEICBvciBjYW5vbmljYWwgSURyLi9cbiAgICAgIC8vIGhpRmVhdHMgaXMgYW4gb2JqIHdob3NlIGtleXMgYXJlIHRoZSBJRHNcbiAgICAgIHRoaXMuaGlGZWF0cyA9IChpbml0aWFsSGkgfHwgW10pLnJlZHVjZSggKGEsdikgPT4geyBhW3ZdPXY7IHJldHVybiBhOyB9LCB7fSApO1xuICAgICAgdGhpcy5kcmFnZ2luZyA9IG51bGw7XG4gICAgICB0aGlzLmRyYWdnZXIgPSB0aGlzLmdldERyYWdnZXIoKTtcbiAgICAgIC8vXG5cdC8vIENvbmZpZyBmb3IgbWVudSB1bmRlciBtZW51IGJ1dHRvblxuXHR0aGlzLmN4dE1lbnVDZmcgPSBbe1xuXHQgICAgbmFtZTogJ2xpbmtUb1NucHMnLFxuXHQgICAgbGFiZWw6ICdNR0kgU05QcycsIFxuXHQgICAgaWNvbjogJ29wZW5faW5fbmV3Jyxcblx0ICAgIHRvb2x0aXA6ICdWaWV3IFNOUHMgYXQgTUdJIGZvciB0aGUgY3VycmVudCBzdHJhaW5zIGluIHRoZSBjdXJyZW50IHJlZ2lvbi4gKFNvbWUgc3RyYWlucyBub3QgYXZhaWxhYmxlLiknLFxuXHQgICAgaGFuZGxlcjogKCk9PiB0aGlzLmFwcC5saW5rVG9NZ2lTbnBSZXBvcnQoKVxuXHR9LHtcblx0ICAgIG5hbWU6ICdsaW5rVG9RdGwnLFxuXHQgICAgbGFiZWw6ICdNR0kgUVRMcycsIFxuXHQgICAgaWNvbjogICdvcGVuX2luX25ldycsXG5cdCAgICB0b29sdGlwOiAnVmlldyBRVEwgYXQgTUdJIHRoYXQgb3ZlcmxhcCB0aGUgY3VycmVudCByZWdpb24uJyxcblx0ICAgIGhhbmRsZXI6ICgpPT4gdGhpcy5hcHAubGlua1RvTWdpUVRMcygpXG5cdH0se1xuXHQgICAgbmFtZTogJ2xpbmtUb0picm93c2UnLFxuXHQgICAgbGFiZWw6ICdNR0kgSkJyb3dzZScsIFxuXHQgICAgaWNvbjogJ29wZW5faW5fbmV3Jyxcblx0ICAgIHRvb2x0aXA6ICdPcGVuIE1HSSBKQnJvd3NlIChDNTdCTC82SiBHUkNtMzgpIHdpdGggdGhlIGN1cnJlbnQgY29vcmRpbmF0ZSByYW5nZS4nLFxuXHQgICAgaGFuZGxlcjogKCk9PiB0aGlzLmFwcC5saW5rVG9NZ2lKQnJvd3NlKClcblx0fSx7XG5cdCAgICBuYW1lOiAnY2xlYXJDYWNoZScsXG5cdCAgICBsYWJlbDogJ0NsZWFyIGNhY2hlJywgXG5cdCAgICBpY29uOiAnZGVsZXRlX3N3ZWVwJyxcblx0ICAgIHRvb2x0aXA6ICdEZWxldGUgY2FjaGVkIGZlYXR1cmVzLiBEYXRhIHdpbGwgYmUgcmVsb2FkZWQgZnJvbSB0aGUgc2VydmVyIG9uIG5leHQgdXNlLicsXG5cdCAgICBoYW5kbGVyOiAoKT0+IHRoaXMuYXBwLmNsZWFyQ2FjaGVkRGF0YSh0cnVlKVxuXHR9XTtcblxuXHQvLyBjb25maWcgZm9yIGEgZmVhdHVyZSdzIGNvbnRleHQgbWVudVxuXHR0aGlzLmZjeHRNZW51Q2ZnID0gW3tcblx0ICAgIG5hbWU6ICdtZW51VGl0bGUnLFxuXHQgICAgbGFiZWw6IChkKSA9PiBgJHtkLnN5bWJvbCB8fCBkLklEfWAsIFxuXHQgICAgY2xzOiAnbWVudVRpdGxlJ1xuXHR9LHtcblx0ICAgIG5hbWU6ICdsaW5lVXBPbkZlYXR1cmUnLFxuXHQgICAgbGFiZWw6ICdBbGlnbiBvbiB0aGlzIGZlYXR1cmUuJyxcblx0ICAgIGljb246ICdmb3JtYXRfYWxpZ25fY2VudGVyJyxcblx0ICAgIHRvb2x0aXA6ICdBbGlnbnMgdGhlIGRpc3BsYXllZCBnZW5vbWVzIGFyb3VuZCB0aGlzIGZlYXR1cmUuJyxcblx0ICAgIGhhbmRsZXI6IChmKSA9PiB7XG5cdFx0bGV0IGlkcyA9IChuZXcgU2V0KE9iamVjdC5rZXlzKHRoaXMuaGlGZWF0cykpKS5hZGQoZi5pZCk7XG5cdCAgICAgICAgdGhpcy5hcHAuc2V0Q29udGV4dCh7bGFuZG1hcms6Zi5pZCwgZGVsdGE6MCwgaGlnaGxpZ2h0OkFycmF5LmZyb20oaWRzKX0pXG5cdCAgICB9XG5cdH0se1xuXHQgICAgbmFtZTogJ3RvTUdJJyxcblx0ICAgIGxhYmVsOiAnRmVhdHVyZUBNR0knLCBcblx0ICAgIGljb246ICdvcGVuX2luX25ldycsXG5cdCAgICB0b29sdGlwOiAnU2VlIGRldGFpbHMgZm9yIHRoaXMgZmVhdHVyZSBhdCBNR0kuJyxcblx0ICAgIGhhbmRsZXI6IChmKSA9PiB7IHdpbmRvdy5vcGVuKGBodHRwOi8vd3d3LmluZm9ybWF0aWNzLmpheC5vcmcvYWNjZXNzaW9uLyR7Zi5pZH1gLCAnX2JsYW5rJykgfVxuXHR9LHtcblx0ICAgIG5hbWU6ICd0b01vdXNlTWluZScsXG5cdCAgICBsYWJlbDogJ0ZlYXR1cmVATW91c2VNaW5lJywgXG5cdCAgICBpY29uOiAnb3Blbl9pbl9uZXcnLFxuXHQgICAgdG9vbHRpcDogJ1NlZSBkZXRhaWxzIGZvciB0aGlzIGZlYXR1cmUgYXQgTW91c2VNaW5lLicsXG5cdCAgICBoYW5kbGVyOiAoZikgPT4gdGhpcy5hcHAubGlua1RvUmVwb3J0UGFnZShmKVxuXHR9LHtcblx0ICAgIG5hbWU6ICdnZW5vbWljU2VxRG93bmxvYWQnLFxuXHQgICAgbGFiZWw6ICdHZW5vbWljIHNlcXVlbmNlcycsIFxuXHQgICAgaWNvbjogJ2Nsb3VkX2Rvd25sb2FkJyxcblx0ICAgIHRvb2x0aXA6ICdEb3dubG9hZCBnZW5vbWljIHNlcXVlbmNlcyBmb3IgdGhpcyBmZWF0dXJlIGZyb20gY3VycmVudGx5IGRpc3BsYXllZCBnZW5vbWVzLicsXG5cdCAgICBoYW5kbGVyOiAoZikgPT4geyBcblx0XHR0aGlzLmFwcC5kb3dubG9hZEZhc3RhKGYsICdnZW5vbWljJywgdGhpcy5hcHAudkdlbm9tZXMubWFwKHZnPT52Zy5sYWJlbCkpO1xuXHQgICAgfVxuXHR9LHtcblx0ICAgIG5hbWU6ICd0eHBTZXFEb3dubG9hZCcsXG5cdCAgICBsYWJlbDogJ1RyYW5zY3JpcHQgc2VxdWVuY2VzJywgXG5cdCAgICBpY29uOiAnY2xvdWRfZG93bmxvYWQnLFxuXHQgICAgdG9vbHRpcDogJ0Rvd25sb2FkIHRyYW5zY3JpcHQgc2VxdWVuY2VzIG9mIHRoaXMgZmVhdHVyZSBmcm9tIGN1cnJlbnRseSBkaXNwbGF5ZWQgZ2Vub21lcy4nLFxuXHQgICAgaGFuZGxlcjogKGYpID0+IHsgXG5cdFx0dGhpcy5hcHAuZG93bmxvYWRGYXN0YShmLCAndHJhbnNjcmlwdCcsIHRoaXMuYXBwLnZHZW5vbWVzLm1hcCh2Zz0+dmcubGFiZWwpKTtcblx0ICAgIH1cblx0fSx7XG5cdCAgICBuYW1lOiAnY2RzU2VxRG93bmxvYWQnLFxuXHQgICAgbGFiZWw6ICdDRFMgc2VxdWVuY2VzJywgXG5cdCAgICBpY29uOiAnY2xvdWRfZG93bmxvYWQnLFxuXHQgICAgdG9vbHRpcDogJ0Rvd25sb2FkIGNvZGluZyBzZXF1ZW5jZXMgb2YgdGhpcyBmZWF0dXJlIGZyb20gY3VycmVudGx5IGRpc3BsYXllZCBnZW5vbWVzLicsXG5cdCAgICBkaXNhYmxlcjogKGYpID0+IGYuYmlvdHlwZS5pbmRleE9mKCdwcm90ZWluJykgPT09IC0xLCAvLyBkaXNhYmxlIGlmIGYgaXMgbm90IHByb3RlaW4gY29kaW5nXG5cdCAgICBoYW5kbGVyOiAoZikgPT4geyBcblx0XHR0aGlzLmFwcC5kb3dubG9hZEZhc3RhKGYsICdjZHMnLCB0aGlzLmFwcC52R2Vub21lcy5tYXAodmc9PnZnLmxhYmVsKSk7XG5cdCAgICB9XG5cdH0se1xuXHQgICAgbmFtZTogJ2V4b25TZXFEb3dubG9hZCcsXG5cdCAgICBsYWJlbDogJ0V4b24gc2VxdWVuY2VzJywgXG5cdCAgICBpY29uOiAnY2xvdWRfZG93bmxvYWQnLFxuXHQgICAgdG9vbHRpcDogJ0Rvd25sb2FkIGV4b24gc2VxdWVuY2VzIG9mIHRoaXMgZmVhdHVyZSBmcm9tIGN1cnJlbnRseSBkaXNwbGF5ZWQgZ2Vub21lcy4nLFxuXHQgICAgZGlzYWJsZXI6IChmKSA9PiBmLnR5cGUuaW5kZXhPZignZ2VuZScpID09PSAtMSxcblx0ICAgIGhhbmRsZXI6IChmKSA9PiB7IFxuXHRcdHRoaXMuYXBwLmRvd25sb2FkRmFzdGEoZiwgJ2V4b24nLCB0aGlzLmFwcC52R2Vub21lcy5tYXAodmc9PnZnLmxhYmVsKSk7XG5cdCAgICB9XG5cdH1dO1xuICAgICAgLy9cbiAgICAgIHRoaXMuaW5pdERvbSgpO1xuICAgIH1cbiAgICAvL1xuICAgIGluaXREb20gKCkge1xuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG5cdGxldCByID0gdGhpcy5yb290O1xuXHRsZXQgYSA9IHRoaXMuYXBwO1xuICAgICAgICAvL1xuICAgICAgICB0aGlzLmZpZHVjaWFscyA9IHRoaXMuc3ZnLmluc2VydCgnZycsJzpmaXJzdC1jaGlsZCcpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywnZmlkdWNpYWxzJyk7XG4gICAgICAgIHRoaXMuc3RyaXBzR3JwID0gdGhpcy5zdmdNYWluLmFwcGVuZCgnZycpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywnc3RyaXBzJyk7XG4gICAgICAgIHRoaXMuYXhpcyA9IHRoaXMuc3ZnTWFpbi5hcHBlbmQoJ2cnKVxuICAgICAgICAgIC5hdHRyKCdjbGFzcycsJ2F4aXMnKTtcblx0Ly8gXG4gICAgICAgIHRoaXMuZmxvYXRpbmdUZXh0ID0gdGhpcy5zdmdNYWluLmFwcGVuZCgnZycpXG4gICAgICAgICAgLmF0dHIoJ2NsYXNzJywnZmxvYXRpbmdUZXh0Jyk7XG5cdHRoaXMuZmxvYXRpbmdUZXh0LmFwcGVuZCgncmVjdCcpO1xuXHR0aGlzLmZsb2F0aW5nVGV4dC5hcHBlbmQoJ3RleHQnKTtcblx0Ly9cbiAgICAgICAgdGhpcy5jeHRNZW51ID0gdGhpcy5yb290LnNlbGVjdCgnW25hbWU9XCJjeHRNZW51XCJdJyk7XG5cdC8vXG5cdHIuc2VsZWN0KCcuYnV0dG9uLmNsb3NlJylcblx0ICAgIC5vbignY2xpY2snLCAoKSA9PiB0aGlzLnVwZGF0ZSgpKTtcblxuXHQvLyB6b29tIGNvbnRyb2xzXG5cdHIuc2VsZWN0KCcjem9vbU91dCcpLm9uKCdjbGljaycsXG5cdCAgICAoKSA9PiB7IGEuem9vbShhLmRlZmF1bHRab29tKSB9KTtcblx0ci5zZWxlY3QoJyN6b29tSW4nKSAub24oJ2NsaWNrJyxcblx0ICAgICgpID0+IHsgYS56b29tKDEvYS5kZWZhdWx0Wm9vbSkgfSk7XG5cdHIuc2VsZWN0KCcjem9vbU91dE1vcmUnKS5vbignY2xpY2snLFxuXHQgICAgKCkgPT4geyBhLnpvb20oMiphLmRlZmF1bHRab29tKSB9KTtcblx0ci5zZWxlY3QoJyN6b29tSW5Nb3JlJykgLm9uKCdjbGljaycsXG5cdCAgICAoKSA9PiB7IGEuem9vbSgxLygyKmEuZGVmYXVsdFpvb20pKSB9KTtcblxuXHQvLyBwYW4gY29udHJvbHNcblx0ci5zZWxlY3QoJyNwYW5MZWZ0JykgLm9uKCdjbGljaycsXG5cdCAgICAoKSA9PiB7IGEucGFuKC1hLmRlZmF1bHRQYW4pIH0pO1xuXHRyLnNlbGVjdCgnI3BhblJpZ2h0Jykub24oJ2NsaWNrJyxcblx0ICAgICgpID0+IHsgYS5wYW4oK2EuZGVmYXVsdFBhbikgfSk7XG5cdHIuc2VsZWN0KCcjcGFuTGVmdE1vcmUnKSAub24oJ2NsaWNrJyxcblx0ICAgICgpID0+IHsgYS5wYW4oLTUqYS5kZWZhdWx0UGFuKSB9KTtcblx0ci5zZWxlY3QoJyNwYW5SaWdodE1vcmUnKS5vbignY2xpY2snLFxuXHQgICAgKCkgPT4geyBhLnBhbigrNSphLmRlZmF1bHRQYW4pIH0pO1xuXG5cdC8vXG5cdHRoaXMucm9vdFxuXHQgIC5vbignY2xpY2snLCAoKSA9PiB7XG5cdCAgICAgIC8vIGNsaWNrIG9uIGJhY2tncm91bmQgPT4gaGlkZSBjb250ZXh0IG1lbnVcblx0ICAgICAgbGV0IHRndCA9IGQzLmV2ZW50LnRhcmdldDtcblx0ICAgICAgaWYgKHRndC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpJyAmJiB0Z3QuaW5uZXJIVE1MID09PSAnbWVudScpXG5cdFx0ICAvLyBleGNlcHRpb246IHRoZSBjb250ZXh0IG1lbnUgYnV0dG9uIGl0c2VsZlxuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICBlbHNlXG5cdFx0ICB0aGlzLmhpZGVDb250ZXh0TWVudSgpXG5cdCAgfSk7XG5cblx0Ly8gRmVhdHVyZSBtb3VzZSBldmVudCBoYW5kbGVycy5cblx0Ly9cblx0bGV0IGZDbGlja0hhbmRsZXIgPSBmdW5jdGlvbiAoZiwgZXZ0LCBwcmVzZXJ2ZSkge1xuXHQgICAgbGV0IGlkID0gZi5pZDtcblx0ICAgIGlmIChldnQuY3RybEtleSkge1xuXHQgICAgICAgIGxldCBjeCA9IGQzLmV2ZW50LmNsaWVudFg7XG5cdCAgICAgICAgbGV0IGN5ID0gZDMuZXZlbnQuY2xpZW50WTtcblx0ICAgICAgICBsZXQgYmIgPSB0aGlzLnJvb3Quc2VsZWN0KCdbbmFtZT1cInpvb21jb250cm9sc1wiXSA+IC5tZW51ID4gLmJ1dHRvbicpLm5vZGUoKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRldnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0ZXZ0LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0dGhpcy5zaG93Q29udGV4dE1lbnUodGhpcy5mY3h0TWVudUNmZywgZiwgY3gtYmIueCwgY3ktYmIueSk7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChldnQuc2hpZnRLZXkpIHtcblx0XHRpZiAodGhpcy5oaUZlYXRzW2lkXSlcblx0XHQgICAgZGVsZXRlIHRoaXMuaGlGZWF0c1tpZF1cblx0XHRlbHNlXG5cdFx0ICAgIHRoaXMuaGlGZWF0c1tpZF0gPSBpZDtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdGlmICghcHJlc2VydmUpIHRoaXMuaGlGZWF0cyA9IHt9O1xuXHRcdHRoaXMuaGlGZWF0c1tpZF0gPSBpZDtcblx0ICAgIH1cblx0ICAgIC8vIEZJWE1FOiByZWFjaG92ZXJcblx0ICAgIHRoaXMuYXBwLmZlYXR1cmVEZXRhaWxzLnVwZGF0ZShmKTtcblx0fS5iaW5kKHRoaXMpO1xuXHQvL1xuXHRsZXQgZk1vdXNlT3ZlckhhbmRsZXIgPSBmdW5jdGlvbihmKSB7XG5cdFx0aWYgKGQzLmV2ZW50LmFsdEtleSkge1xuXHRcdCAgICAvLyBJZiB1c2VyIGlzIGhvbGRpbmcgdGhlIGFsdCBrZXksIHNlbGVjdCBldmVyeXRoaW5nIHRvdWNoZWQuXG5cdFx0ICAgIGZDbGlja0hhbmRsZXIoZiwgZDMuZXZlbnQsIHRydWUpO1xuXHRcdCAgICB0aGlzLmhpZ2hsaWdodCgpO1xuXHRcdCAgICAvLyBEb24ndCByZWdpc3RlciBjb250ZXh0IGNoYW5nZXMgdW50aWwgdXNlciBoYXMgcGF1c2VkIGZvciBhdCBsZWFzdCAxcy5cblx0XHQgICAgaWYgKHRoaXMudGltZW91dCkgd2luZG93LmNsZWFyVGltZW91dCh0aGlzLnRpbWVvdXQpO1xuXHRcdCAgICB0aGlzLnRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dChmdW5jdGlvbigpeyB0aGlzLmFwcC5jb250ZXh0Q2hhbmdlZCgpOyB9LmJpbmQodGhpcyksIDEwMDApO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHQgICAgdGhpcy5oaWdobGlnaHQoZik7XG5cdFx0ICAgIGlmIChkMy5ldmVudC5jdHJsS2V5KVxuXHRcdCAgICAgICAgdGhpcy5hcHAuZmVhdHVyZURldGFpbHMudXBkYXRlKGYpO1xuXHRcdH1cblx0fS5iaW5kKHRoaXMpO1xuXHQvL1xuXHRsZXQgZk1vdXNlT3V0SGFuZGxlciA9IGZ1bmN0aW9uKGYpIHtcblx0XHR0aGlzLmhpZ2hsaWdodCgpOyBcblx0fS5iaW5kKHRoaXMpO1xuXG5cdC8vIEhhbmRsZSBrZXkgZXZlbnRzXG5cdGQzLnNlbGVjdCh3aW5kb3cpLm9uKCdrZXlwcmVzcycsICgpID0+IHtcblx0ICAgIGxldCBlID0gZDMuZXZlbnQ7XG4gICAgICAgICAgICBsZXQgdG5hbWUgPSBlLnRhcmdldC50YWdOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdCAgICBpZiAodG5hbWUgPT09ICdpbnB1dCcgfHwgdG5hbWUgPT09ICd0ZXh0YXJlYScpXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgaWYgKGUua2V5ID09PSAneCcgfHwgZS5jb2RlID09PSAnS2V5WCcpe1xuXHQgICAgICAgIHRoaXMuc3ByZWFkVHJhbnNjcmlwdHMgPSAhIHRoaXMuc3ByZWFkVHJhbnNjcmlwdHM7XG5cdCAgICB9XG5cdCAgICBlbHNlIGlmIChlLmtleSA9PT0gJ3QnIHx8IGUuY29kZSA9PT0gJ0tleVQnKXtcblx0ICAgICAgICB0aGlzLnNob3dBbGxMYWJlbHMgPSAhIHRoaXMuc2hvd0FsbExhYmVscztcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGUua2V5ID09PSAnKycgfHwgZS5jb2RlID09PSAnRXF1YWwnICYmIGUuc2hpZnRLZXkpIHtcblx0XHRpZiAoZS5jdHJsS2V5KVxuXHRcdCAgICB0aGlzLmxhbmVHYXAgPSB0aGlzLmxhbmVHYXAgKyAyO1xuXHRcdGVsc2Vcblx0XHQgICAgdGhpcy5mZWF0SGVpZ2h0ID0gdGhpcy5mZWF0SGVpZ2h0ICsgMjtcblx0ICAgIH1cblx0ICAgIGVsc2UgaWYgKGUua2V5ID09PSAnLScgfHwgZS5jb2RlID09PSAnTWludXMnKSB7XG5cdFx0aWYgKGUuY3RybEtleSlcblx0XHQgICAgdGhpcy5sYW5lR2FwID0gTWF0aC5tYXgoMiwgdGhpcy5sYW5lR2FwIC0gMik7XG5cdFx0ZWxzZVxuXHRcdCAgICB0aGlzLmZlYXRIZWlnaHQgPSBNYXRoLm1heCgyLCB0aGlzLmZlYXRIZWlnaHQgLSAyKTtcblx0ICAgIH1cblx0fSlcblxuXHQvLyBcbiAgICAgICAgdGhpcy5zdmdcblx0ICAub24oJ2RibGNsaWNrJywgKCkgPT4ge1xuXHQgICAgICBsZXQgdCA9IGQzLmV2ZW50LnRhcmdldDtcblx0ICAgICAgbGV0IHRndCA9IGQzLnNlbGVjdCh0KTtcblx0ICAgICAgbGV0IGZlbHQgPSB0LmNsb3Nlc3QoJy5mZWF0dXJlJyk7XG5cdCAgICAgIGlmIChmZWx0KSB7XG5cdFx0ICAvLyB1c2VyIGRvdWJsZSBjbGlja2VkIG9uIGEgZmVhdHVyZVxuXHRcdCAgLy8gbWFrZSBpdCB0aGUgbGFuZG1hcmtcblx0XHQgIGxldCBmID0gZmVsdC5fX2RhdGFfXztcblx0XHQgIHRoaXMuYXBwLnNldENvbnRleHQoe2xhbmRtYXJrOmYuaWQsIHJlZjpmLmdlbm9tZS5uYW1lLCBkZWx0YTogMH0pO1xuXHQgICAgICB9XG5cdCAgfSlcblx0ICAub24oJ2NsaWNrJywgKCkgPT4ge1xuXHQgICAgICBsZXQgdCA9IGQzLmV2ZW50LnRhcmdldDtcblx0ICAgICAgbGV0IHRndCA9IGQzLnNlbGVjdCh0KTtcblx0ICAgICAgaWYgKHRoaXMuZGVhbFdpdGhVbndhbnRlZENsaWNrRXZlbnQpIHtcblx0ICAgICAgICAgIHRoaXMuZGVhbFdpdGhVbndhbnRlZENsaWNrRXZlbnQgPSBmYWxzZTtcblx0XHQgIHJldHVybjtcblx0ICAgICAgfVxuXHQgICAgICBsZXQgZmVsdCA9IHQuY2xvc2VzdCgnLmZlYXR1cmUnKTtcblx0ICAgICAgaWYgKGZlbHQpIHtcblx0XHQgIC8vIHVzZXIgY2xpY2tlZCBvbiBhIGZlYXR1cmVcblx0XHQgIGZDbGlja0hhbmRsZXIoZmVsdC5fX2RhdGFfXywgZDMuZXZlbnQpO1xuXHRcdCAgdGhpcy5oaWdobGlnaHQoKTtcblx0ICAgICAgICAgIHRoaXMuYXBwLmNvbnRleHRDaGFuZ2VkKCk7XG5cdCAgICAgIH1cblx0ICAgICAgZWxzZSBpZiAoIWQzLmV2ZW50LnNoaWZ0S2V5ICYmIFxuXHQgICAgICAgICAgKHQudGFnTmFtZSA9PT0gJ3N2ZycgXG5cdFx0ICB8fCB0LnRhZ05hbWUgPT0gJ3JlY3QnICYmIHQuY2xhc3NMaXN0LmNvbnRhaW5zKCdibG9jaycpXG5cdFx0ICB8fCB0LnRhZ05hbWUgPT0gJ3JlY3QnICYmIHQuY2xhc3NMaXN0LmNvbnRhaW5zKCd1bmRlcmxheScpXG5cdFx0ICApKXtcblx0XHQgIC8vIHVzZXIgY2xpY2tlZCBvbiBiYWNrZ3JvdW5kXG5cdFx0ICB0aGlzLmhpRmVhdHMgPSB7fTtcblx0XHQgIHRoaXMuaGlnaGxpZ2h0KCk7XG5cdFx0ICB0aGlzLmFwcC5jb250ZXh0Q2hhbmdlZCgpO1xuXHQgICAgICB9XG5cdCAgfSlcblx0ICAub24oJ2NvbnRleHRtZW51JywgKCkgPT4ge1xuXHQgICAgICBsZXQgdGd0ID0gZDMuc2VsZWN0KGQzLmV2ZW50LnRhcmdldCk7XG5cdCAgICAgIGxldCBmID0gdGd0LmRhdGEoKVswXTtcblx0ICAgICAgZiA9IGYgPyBmLmZlYXR1cmUgfHwgZiA6IGY7XG5cdCAgICAgIGlmIChmIGluc3RhbmNlb2YgRmVhdHVyZSkge1xuXHRcdCAgZkNsaWNrSGFuZGxlcihmLCBkMy5ldmVudCk7XG5cdCAgICAgIH1cblx0ICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgIGQzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdCAgfSlcblx0ICAub24oJ21vdXNlb3ZlcicsICgpID0+IHtcblx0ICAgICAgbGV0IHRndCA9IGQzLnNlbGVjdChkMy5ldmVudC50YXJnZXQpO1xuXHQgICAgICBsZXQgZiA9IHRndC5kYXRhKClbMF07XG5cdCAgICAgIGYgPSBmID8gZi5mZWF0dXJlIHx8IGYgOiBmO1xuXHQgICAgICBpZiAoZiBpbnN0YW5jZW9mIEZlYXR1cmUpIHtcblx0XHQgIGZNb3VzZU92ZXJIYW5kbGVyKGYpO1xuXHQgICAgICB9XG5cdCAgfSlcblx0ICAub24oJ21vdXNlb3V0JywgKCkgPT4ge1xuXHQgICAgICBsZXQgdGd0ID0gZDMuc2VsZWN0KGQzLmV2ZW50LnRhcmdldCk7XG5cdCAgICAgIGxldCBmID0gdGd0LmRhdGEoKVswXTtcblx0ICAgICAgZiA9IGYgPyBmLmZlYXR1cmUgfHwgZiA6IGY7XG5cdCAgICAgIGlmIChmIGluc3RhbmNlb2YgRmVhdHVyZSkge1xuXHRcdCAgZk1vdXNlT3V0SGFuZGxlcihmKTtcblx0ICAgICAgfVxuXHQgIH0pXG5cdCAgLm9uKCd3aGVlbCcsIGZ1bmN0aW9uKGQpIHtcblx0ICAgIGxldCBlID0gZDMuZXZlbnQ7XG5cdCAgICAvLyBsZXQgdGhlIGJyb3dzZXIgaGFuZGxlciB2ZXJ0aWNhbCBtb3Rpb25cblx0ICAgIGlmIChNYXRoLmFicyhlLmRlbHRhWCkgPCBNYXRoLmFicyhlLmRlbHRhWSkpXG5cdCAgICAgICAgcmV0dXJuO1xuXHQgICAgLy8gd2UgaGFuZGxlIGhvcml6b250YWwgbW90aW9uLlxuXHQgICAgZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0ICAgIGUucHJldmVudERlZmF1bHQoKTtcblx0ICAgIC8vIGZpbHRlciBvdXQgdGlueSBtb3Rpb25zXG5cdCAgICBpZiAoTWF0aC5hYnMoZS5kZWx0YVgpIDwgc2VsZi5jZmcud2hlZWxUaHJlc2hvbGQpIFxuXHQgICAgICAgIHJldHVybjtcblx0ICAgIC8vIGdldCB0aGUgem9vbSBzdHJpcCB0YXJnZXQsIGlmIGl0IGV4aXN0cywgZWxzZSB0aGUgcmVmIHpvb20gc3RyaXAuXG5cdCAgICBsZXQgeiA9IGUudGFyZ2V0LmNsb3Nlc3QoJ2cuem9vbVN0cmlwJykgfHwgZDMuc2VsZWN0KCdnLnpvb21TdHJpcC5yZWZlcmVuY2UnKVswXVswXTtcblx0ICAgIGlmICgheikgcmV0dXJuO1xuXG5cdCAgICBsZXQgZGIgPSBlLmRlbHRhWCAvIHNlbGYucHBiOyAvLyBkZWx0YSBpbiBiYXNlcyBmb3IgdGhpcyBldmVudFxuXHQgICAgbGV0IHpkID0gei5fX2RhdGFfXztcblx0ICAgIGlmIChlLmN0cmxLZXkpIHtcblx0XHQvLyBDdHJsLXdoZWVsIHNpbXBseSBzbGlkZXMgdGhlIHN0cmlwIGhvcml6b250YWxseSAodGVtcG9yYXJ5KVxuXHRcdC8vIEZvciBjb21wYXJpc29uIGdlbm9tZXMsIGp1c3QgdHJhbnNsYXRlIHRoZSBibG9ja3MgYnkgdGhlIHdoZWVsIGFtb3VudCwgc28gdGhlIHVzZXIgY2FuIFxuXHRcdC8vIHNlZSBldmVyeXRoaW5nLlxuXHRcdHpkLmRlbHRhQiArPSBkYjtcblx0ICAgICAgICBkMy5zZWxlY3Qoeikuc2VsZWN0KCdnW25hbWU9XCJzQmxvY2tzXCJdJykuYXR0cigndHJhbnNmb3JtJyxgdHJhbnNsYXRlKCR7LXpkLmRlbHRhQiAqIHNlbGYucHBifSwwKXNjYWxlKCR7emQueFNjYWxlfSwxKWApO1xuXHRcdHNlbGYuZHJhd0ZpZHVjaWFscygpO1xuXHRcdHJldHVybjtcblx0ICAgIH1cblxuXHQgICAgLy8gTm9ybWFsIHdoZWVsIGV2ZW50ID0gcGFuIHRoZSB2aWV3LlxuXHQgICAgLy9cblx0ICAgIGxldCBjICA9IHNlbGYuYXBwLmNvb3Jkcztcblx0ICAgIC8vIExpbWl0IGRlbHRhIGJ5IGNociBlbmRzXG5cdCAgICAvLyBEZWx0YSBpbiBiYXNlczpcblx0ICAgIHpkLmRlbHRhQiA9IGNsaXAoemQuZGVsdGFCICsgZGIsIC1jLnN0YXJ0LCBjLmNocm9tb3NvbWUubGVuZ3RoIC0gYy5lbmQpXG5cdCAgICAvLyB0cmFuc2xhdGVcblx0ICAgIGQzLnNlbGVjdCh0aGlzKS5zZWxlY3RBbGwoJ2cuem9vbVN0cmlwID4gZ1tuYW1lPVwic0Jsb2Nrc1wiXScpXG5cdFx0LmF0dHIoJ3RyYW5zZm9ybScsIGN6ID0+IGB0cmFuc2xhdGUoJHstemQuZGVsdGFCICogc2VsZi5wcGJ9LDApc2NhbGUoJHtjei54U2NhbGV9LDEpYCk7XG5cdCAgICBzZWxmLmRyYXdGaWR1Y2lhbHMoKTtcblx0ICAgIC8vIFdhaXQgdW50aWwgd2hlZWwgZXZlbnRzIGhhdmUgc3RvcHBlZCBmb3IgYSB3aGlsZSwgdGhlbiBzY3JvbGwgdGhlIHZpZXcuXG5cdCAgICBpZiAoc2VsZi50aW1lb3V0KXtcblx0ICAgICAgICB3aW5kb3cuY2xlYXJUaW1lb3V0KHNlbGYudGltZW91dCk7XG5cdCAgICB9XG5cdCAgICBzZWxmLnRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdFx0c2VsZi50aW1lb3V0ID0gbnVsbDtcblx0XHRsZXQgY2N4dCA9IHNlbGYuYXBwLmdldENvbnRleHQoKTtcblx0XHRsZXQgbmN4dDtcblx0XHRpZiAoY2N4dC5sYW5kbWFyaykge1xuXHRcdCAgICBuY3h0ID0geyBkZWx0YTogY2N4dC5kZWx0YSArIHpkLmRlbHRhQiB9O1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHQgICAgbmN4dCA9IHsgc3RhcnQ6IGNjeHQuc3RhcnQgKyB6ZC5kZWx0YUIsIGVuZDogY2N4dC5lbmQgKyB6ZC5kZWx0YUIgfTtcblx0XHR9XG5cdFx0c2VsZi5hcHAuc2V0Q29udGV4dChuY3h0KTtcblx0XHR6ZC5kZWx0YUIgPSAwO1xuXHQgICAgfSwgc2VsZi5jZmcud2hlZWxDb250ZXh0RGVsYXkpO1xuXHR9KTtcblxuXHQvLyBCdXR0b246IERyb3AgZG93biBtZW51IGluIHpvb20gdmlld1xuXHR0aGlzLnJvb3Quc2VsZWN0KCcubWVudSA+IC5idXR0b24nKVxuXHQgIC5vbignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG5cdCAgICAgIC8vIHNob3cgY29udGV4dCBtZW51IGF0IG1vdXNlIGV2ZW50IGNvb3JkaW5hdGVzXG5cdCAgICAgIGxldCBjeCA9IGQzLmV2ZW50LmNsaWVudFg7XG5cdCAgICAgIGxldCBjeSA9IGQzLmV2ZW50LmNsaWVudFk7XG5cdCAgICAgIGxldCBiYiA9IGQzLnNlbGVjdCh0aGlzKVswXVswXS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICAgICAgZDMuZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdCAgICAgIHNlbGYuc2hvd0NvbnRleHRNZW51KHNlbGYuY3h0TWVudUNmZywgbnVsbCwgY3gtYmIubGVmdCwgY3ktYmIudG9wKTtcblx0ICB9KTtcblx0Ly8gem9vbSBjb29yZGluYXRlcyBib3hcblx0dGhpcy5yb290LnNlbGVjdCgnI3pvb21Db29yZHMnKVxuXHQgICAgLmNhbGwoemNzID0+IHpjc1swXVswXS52YWx1ZSA9IGZvcm1hdENvb3Jkcyh0aGlzLmFwcC5jb29yZHMpKVxuXHQgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uICgpIHsgdGhpcy5zZWxlY3QoKTsgfSlcblx0ICAgIC5vbignY2hhbmdlJywgZnVuY3Rpb24gKCkgeyBzZWxmLmFwcC5zZXRDb29yZGluYXRlcyh0aGlzLnZhbHVlKTsgfSk7XG5cblx0Ly8gem9vbSB3aW5kb3cgc2l6ZSBib3hcblx0dGhpcy5yb290LnNlbGVjdCgnI3pvb21XU2l6ZScpXG5cdCAgICAub24oJ2NsaWNrJywgZnVuY3Rpb24gKCkgeyB0aGlzLnNlbGVjdCgpOyB9KVxuXHQgICAgLm9uKCdjaGFuZ2UnLCBmdW5jdGlvbigpIHtcblx0ICAgICAgICBsZXQgd3MgPSBwYXJzZUludCh0aGlzLnZhbHVlKTtcblx0XHRsZXQgYyA9IHNlbGYuYXBwLmNvb3Jkcztcblx0XHRpZiAoaXNOYU4od3MpIHx8IHdzIDwgMTAwKSB7XG5cdFx0ICAgIGFsZXJ0KCdJbnZhbGlkIHdpbmRvdyBzaXplLiBQbGVhc2UgZW50ZXIgYW4gaW50ZWdlciA+PSAxMDAuJyk7XG5cdFx0ICAgIHRoaXMudmFsdWUgPSBNYXRoLnJvdW5kKGMuZW5kIC0gYy5zdGFydCArIDEpO1xuXHRcdH1cblx0XHRlbHNlIHtcblx0XHQgICAgbGV0IG1pZCA9IChjLnN0YXJ0ICsgYy5lbmQpIC8gMjtcblx0XHQgICAgbGV0IG5ld3MgPSBNYXRoLnJvdW5kKG1pZCAtIHdzLzIpO1xuXHRcdCAgICBsZXQgbmV3ZSA9IG5ld3MgKyB3cyAtIDE7XG5cdFx0ICAgIHNlbGYuYXBwLnNldENvbnRleHQoe1xuXHRcdCAgICAgICAgY2hyOiBjLmNocixcblx0XHRcdHN0YXJ0OiBuZXdzLFxuXHRcdFx0ZW5kOiBuZXdlLFxuXHRcdFx0bGVuZ3RoOiBuZXdlLW5ld3MrMVxuXHRcdCAgICB9KTtcblx0XHR9XG5cdCAgICB9KTtcblx0Ly8gem9vbSBkcmF3aW5nIG1vZGUgXG5cdHRoaXMucm9vdC5zZWxlY3RBbGwoJ2RpdltuYW1lPVwiem9vbURtb2RlXCJdIC5idXR0b24nKVxuXHQgICAgLm9uKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuXHRcdGlmIChkMy5zZWxlY3QodGhpcykuYXR0cignZGlzYWJsZWQnKSlcblx0XHQgICAgcmV0dXJuO1xuXHRcdGxldCByID0gc2VsZi5yb290O1xuXHRcdGxldCBpc0MgPSByLmNsYXNzZWQoJ2NvbXBhcmlzb24nKTtcblx0XHRyLmNsYXNzZWQoJ2NvbXBhcmlzb24nLCAhaXNDKTtcblx0XHRyLmNsYXNzZWQoJ3JlZmVyZW5jZScsIGlzQyk7XG5cdFx0c2VsZi5hcHAuc2V0Q29udGV4dCh7ZG1vZGU6IHIuY2xhc3NlZCgnY29tcGFyaXNvbicpID8gJ2NvbXBhcmlzb24nIDogJ3JlZmVyZW5jZSd9KTtcblx0ICAgIH0pO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBpbml0Q29udGV4dE1lbnUgKGl0ZW1zLG9iaikge1xuXHR0aGlzLmN4dE1lbnUuc2VsZWN0QWxsKCcubWVudUl0ZW0nKS5yZW1vdmUoKTsgLy8gaW4gY2FzZSBvZiByZS1pbml0XG4gICAgICAgIGxldCBtaXRlbXMgPSB0aGlzLmN4dE1lbnVcblx0ICAuc2VsZWN0QWxsKCcubWVudUl0ZW0nKVxuXHQgIC5kYXRhKGl0ZW1zKTtcblx0bGV0IG5ld3MgPSBtaXRlbXMuZW50ZXIoKVxuXHQgIC5hcHBlbmQoJ2RpdicpXG5cdCAgLmF0dHIoJ2NsYXNzJywgKGQpID0+IGBtZW51SXRlbSBmbGV4cm93ICR7ZC5jbHN8fCcnfWApXG5cdCAgLmNsYXNzZWQoJ2Rpc2FibGVkJywgZCA9PiBkLmRpc2FibGVyID8gZC5kaXNhYmxlcihvYmopIDogZmFsc2UpXG5cdCAgLmF0dHIoJ25hbWUnLCBkID0+IGQubmFtZSB8fCBudWxsIClcblx0ICAuYXR0cigndGl0bGUnLCBkID0+IGQudG9vbHRpcCB8fCBudWxsICk7XG5cblx0bGV0IGhhbmRsZXIgPSBkID0+IHtcblx0ICAgICAgaWYgKGQuZGlzYWJsZXIgJiYgZC5kaXNhYmxlcihvYmopKVxuXHQgICAgICAgICAgcmV0dXJuO1xuXHQgICAgICBkLmhhbmRsZXIgJiYgZC5oYW5kbGVyKG9iaik7XG5cdCAgICAgIHRoaXMuaGlkZUNvbnRleHRNZW51KCk7XG5cdCAgICAgIGQzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICBkMy5ldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9O1xuXHRuZXdzLmFwcGVuZCgnbGFiZWwnKVxuXHQgIC50ZXh0KGQgPT4gdHlwZW9mKGQubGFiZWwpID09PSAnZnVuY3Rpb24nID8gZC5sYWJlbChvYmopIDogZC5sYWJlbClcblx0ICAub24oJ2NsaWNrJywgaGFuZGxlcilcblx0ICAub24oJ2NvbnRleHRtZW51JywgaGFuZGxlcik7XG5cdG5ld3MuYXBwZW5kKCdpJylcblx0ICAuYXR0cignY2xhc3MnLCAnbWF0ZXJpYWwtaWNvbnMnKVxuXHQgIC50ZXh0KCBkPT5kLmljb24gKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgc2hvd0NvbnRleHRNZW51IChjZmcsZix4LHkpIHtcbiAgICAgICAgdGhpcy5pbml0Q29udGV4dE1lbnUoY2ZnLCBmKTtcbiAgICAgICAgdGhpcy5jeHRNZW51XG5cdCAgICAuY2xhc3NlZCgnc2hvd2luZycsIHRydWUpXG5cdCAgICAuc3R5bGUoJ2xlZnQnLCBgJHt4fXB4YClcblx0ICAgIC5zdHlsZSgndG9wJywgYCR7eX1weGApXG5cdCAgICA7XG5cdGlmIChmKSB7XG5cdCAgICB0aGlzLmN4dE1lbnUub24oJ21vdXNlZW50ZXInLCAoKT0+dGhpcy5oaWdobGlnaHQoZikpO1xuXHQgICAgdGhpcy5jeHRNZW51Lm9uKCdtb3VzZWxlYXZlJywgKCk9PiB7XG5cdCAgICAgICAgdGhpcy5oaWdobGlnaHQoKTtcblx0XHR0aGlzLmhpZGVDb250ZXh0TWVudSgpO1xuXHQgICAgfSk7XG5cdH1cbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaGlkZUNvbnRleHRNZW51ICgpIHtcbiAgICAgICAgdGhpcy5jeHRNZW51LmNsYXNzZWQoJ3Nob3dpbmcnLCBmYWxzZSk7XG5cdHRoaXMuY3h0TWVudS5vbignbW91c2VlbnRlcicsIG51bGwpO1xuXHR0aGlzLmN4dE1lbnUub24oJ21vdXNlbGVhdmUnLCBudWxsKTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcmdzOlxuICAgIC8vICAgICBncyAobGlzdCBvZiBHZW5vbWVzKVxuICAgIC8vIFNpZGUgZWZmZWN0czpcbiAgICAvLyAgICAgRm9yIGVhY2ggR2Vub21lLCBzZXRzIGcuem9vbVkgXG4gICAgc2V0IGdlbm9tZXMgKGdzKSB7XG4gICAgICAgbGV0IG9mZnNldCA9IHRoaXMuY2ZnLnRvcE9mZnNldDtcbiAgICAgICBncy5mb3JFYWNoKCBnID0+IHtcbiAgICAgICAgICAgZy56b29tWSA9IG9mZnNldDtcblx0ICAgb2Zmc2V0ICs9IHRoaXMuY2ZnLm1pblN0cmlwSGVpZ2h0ICsgdGhpcy5jZmcuc3RyaXBHYXA7XG4gICAgICAgfSk7XG4gICAgICAgdGhpcy5fZ2Vub21lcyA9IGdzO1xuICAgIH1cbiAgICBnZXQgZ2Vub21lcyAoKSB7XG4gICAgICAgcmV0dXJuIHRoaXMuX2dlbm9tZXM7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFJldHVybnMgdGhlIG5hbWVzIG9mIHRoZSBjdXJyZW50bHkgZGlzcGxheWVkIGdlbm9tZXMgKHN0cmlwZXMpIGluIHRvcC10by1ib3R0b20gb3JkZXIuXG4gICAgLy9cbiAgICBnZXRHZW5vbWVZT3JkZXIgKCkge1xuICAgICAgICBsZXQgc3RyaXBzID0gdGhpcy5zdmdNYWluLnNlbGVjdEFsbCgnLnpvb21TdHJpcCcpO1xuICAgICAgICBsZXQgc3MgPSBzdHJpcHNbMF0ubWFwKGc9PiB7XG5cdCAgICBsZXQgYmIgPSBnLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHQgICAgcmV0dXJuIFtiYi55LCBnLl9fZGF0YV9fLmdlbm9tZS5uYW1lXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBucyA9IHNzLnNvcnQoIChhLGIpID0+IGFbMF0gLSBiWzBdICkubWFwKCB4ID0+IHhbMV0gKVxuXHRyZXR1cm4gbnM7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNldHMgdGhlIHRvcC10by1ib3R0b20gb3JkZXIgb2YgdGhlIGN1cnJlbnRseSBkaXNwbGF5ZWQgZ2Vub21lcyBhY2NvcmRpbmcgdG8gXG4gICAgLy8gdGhlIGdpdmVuIG5hbWUgbGlzdCBvZiBuYW1lcy4gQmVjYXVzZSB3ZSBjYW4ndCBndWFyYW50ZWUgdGhlIGdpdmVuIG5hbWVzIGNvcnJlc3BvbmRcbiAgICAvLyB0byBhY3R1YWwgem9vbSBzdHJpcHMsIG9yIHRoYXQgYWxsIHN0cmlwcyBhcmUgcmVwcmVzZW50ZWQsIGV0Yy5cbiAgICAvLyBUaGVyZWZvcmUsIHRoZSBsaXN0IGlzIHByZXByZWNlc3NlZCBhcyBmb2xsb3dzOlxuICAgIC8vICAgICAqIGR1cGxpY2F0ZSBuYW1lcywgaWYgdGhleSBleGlzdCwgYXJlIHJlbW92ZWRcbiAgICAvLyAgICAgKiBuYW1lcyB0aGF0IGRvIG5vdCBjb3JyZXNwb25kIHRvIGV4aXN0aW5nIHpvb21TdHJpcHMgYXJlIHJlbW92ZWRcbiAgICAvLyAgICAgKiBuYW1lcyBvZiBleGlzdGluZyB6b29tIHN0cmlwcyB0aGF0IGRvbid0IGFwcGVhciBpbiB0aGUgbGlzdCBhcmUgYWRkZWQgdG8gdGhlIGVuZFxuICAgIC8vIFRoZSByZXN1bHQgaXMgYSBsaXN0IG9mIG5hbWVzIHdpdGggdGhlc2UgcHJvcGVydGllczpcbiAgICAvLyAgICAgKiB0aGVyZSBpcyBhIDE6MSBjb3JyZXNwb25kZW5jZSBiZXR3ZWVuIG5hbWVzIGFuZCBhY3R1YWwgem9vbSBzdHJpcHNcbiAgICAvLyAgICAgKiB0aGUgbmFtZSBvcmRlciBpcyBjb25zaXN0ZW50IHdpdGggdGhlIGlucHV0IGxpc3RcbiAgICAvLyBUaGlzIGlzIHRoZSBsaXN0IHVzZWQgdG8gKHJlKW9yZGVyIHRoZSB6b29tIHN0cmlwcy5cbiAgICAvL1xuICAgIC8vIEdpdmVuIHRoZSBsaXN0IG9yZGVyOiBcbiAgICAvLyAgICAgKiBhIFktcG9zaXRpb24gaXMgYXNzaWduZWQgdG8gZWFjaCBnZW5vbWVcbiAgICAvLyAgICAgKiB6b29tIHN0cmlwcyB0aGF0IGFyZSBOT1QgQ1VSUkVOVExZIEJFSU5HIERSQUdHRUQgYXJlIHRyYW5zbGF0ZWQgdG8gdGhlaXIgbmV3IGxvY2F0aW9uc1xuICAgIC8vXG4gICAgLy8gQXJnczpcbiAgICAvLyAgICAgbnMgKGxpc3Qgb2Ygc3RyaW5ncykgTmFtZXMgb2YgdGhlIGdlbm9tZXMuXG4gICAgLy8gUmV0dXJuczpcbiAgICAvLyAgICAgbm90aGluZ1xuICAgIC8vIFNpZGUgZWZmZWN0czpcbiAgICAvLyAgICAgUmVjYWxjdWxhdGVzIHRoZSBZLWNvb3JkaW5hdGVzIGZvciBlYWNoIHN0cmlwIGJhc2VkIG9uIHRoZSBnaXZlbiBvcmRlciwgdGhlbiB0cmFuc2xhdGVzXG4gICAgLy8gICAgIGVhY2ggc3RyaXAgdG8gaXRzIG5ldyBwb3NpdGlvbi5cbiAgICAvL1xuICAgIHNldEdlbm9tZVlPcmRlciAobnMpIHtcblx0dGhpcy5nZW5vbWVzID0gcmVtb3ZlRHVwcyhucykubWFwKG49PiB0aGlzLmFwcC5uYW1lMmdlbm9tZVtuXSApLmZpbHRlcih4PT54KTtcblx0bGV0IG8gPSB0aGlzLmNmZy50b3BPZmZzZXQ7XG4gICAgICAgIHRoaXMuZ2Vub21lcy5mb3JFYWNoKCAoZyxpKSA9PiB7XG5cdCAgICBsZXQgc3RyaXAgPSBkMy5zZWxlY3QoYCN6b29tVmlldyAuem9vbVN0cmlwW25hbWU9XCIke2cubmFtZX1cIl1gKTtcblx0ICAgIGlmICghc3RyaXAuY2xhc3NlZCgnZHJhZ2dpbmcnKSlcblx0ICAgICAgICBzdHJpcC5hdHRyKCd0cmFuc2Zvcm0nLCBnZCA9PiBgdHJhbnNsYXRlKDAsJHtvICsgZ2QuemVyb09mZnNldH0pYCk7XG5cdCAgICBvICs9IHN0cmlwLmRhdGEoKVswXS5zdHJpcEhlaWdodCArIHRoaXMuY2ZnLnN0cmlwR2FwO1xuXHR9KTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBSZXR1cm5zIGEgZHJhZ2dlciAoZDMuYmVoYXZpb3IuZHJhZykgdG8gYmUgYXR0YWNoZWQgdG8gZWFjaCB6b29tIHN0cmlwLlxuICAgIC8vIEFsbG93cyBzdHJpcHMgdG8gYmUgcmVvcmRlcmVkIGJ5IGRyYWdnaW5nLlxuICAgIGdldERyYWdnZXIgKCkgeyAgXG4gICAgICBsZXQgc2VsZiA9IHRoaXM7XG4gICAgICByZXR1cm4gZDMuYmVoYXZpb3IuZHJhZygpXG5cdCAgLm9yaWdpbihmdW5jdGlvbihkLGkpe1xuXHQgICAgICByZXR1cm4gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0ICB9KVxuICAgICAgICAgIC5vbignZHJhZ3N0YXJ0LnonLCBmdW5jdGlvbihnKSB7XG5cdCAgICAgIGxldCB0ID0gZDMuZXZlbnQuc291cmNlRXZlbnQudGFyZ2V0O1xuXHQgICAgICBpZiAoZDMuZXZlbnQuc291cmNlRXZlbnQuc2hpZnRLZXkgfHwgISBkMy5zZWxlY3QodCkuY2xhc3NlZCgnem9vbVN0cmlwSGFuZGxlJykpe1xuXHQgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuXHQgICAgICB9XG5cdCAgICAgIGQzLmV2ZW50LnNvdXJjZUV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHQgICAgICBsZXQgc3RyaXAgPSB0aGlzLmNsb3Nlc3QoJy56b29tU3RyaXAnKTtcblx0ICAgICAgc2VsZi5kcmFnZ2luZyA9IGQzLnNlbGVjdChzdHJpcCkuY2xhc3NlZCgnZHJhZ2dpbmcnLCB0cnVlKTtcblx0ICB9KVxuXHQgIC5vbignZHJhZy56JywgZnVuY3Rpb24gKGcpIHtcblx0ICAgICAgaWYgKCFzZWxmLmRyYWdnaW5nKSByZXR1cm47XG5cdCAgICAgIGxldCBteCA9IGQzLm1vdXNlKHNlbGYuc3ZnTWFpblswXVswXSlbMF07XG5cdCAgICAgIGxldCBteSA9IGQzLm1vdXNlKHNlbGYuc3ZnTWFpblswXVswXSlbMV07XG5cdCAgICAgIHNlbGYuZHJhZ2dpbmcuYXR0cigndHJhbnNmb3JtJywgYHRyYW5zbGF0ZSgwLCAke215fSlgKTtcblx0ICAgICAgc2VsZi5zZXRHZW5vbWVZT3JkZXIoc2VsZi5nZXRHZW5vbWVZT3JkZXIoKSk7XG5cdCAgICAgIHNlbGYuZHJhd0ZpZHVjaWFscygpO1xuXHQgIH0pXG5cdCAgLm9uKCdkcmFnZW5kLnonLCBmdW5jdGlvbiAoZykge1xuXHQgICAgICBpZiAoIXNlbGYuZHJhZ2dpbmcpIHJldHVybjtcblx0ICAgICAgLy9cblx0ICAgICAgc2VsZi5kcmFnZ2luZy5jbGFzc2VkKCdkcmFnZ2luZycsIGZhbHNlKTtcblx0ICAgICAgc2VsZi5kcmFnZ2luZyA9IG51bGw7XG5cdCAgICAgIHNlbGYuc2V0R2Vub21lWU9yZGVyKHNlbGYuZ2V0R2Vub21lWU9yZGVyKCkpO1xuXHQgICAgICBzZWxmLmFwcC5zZXRDb250ZXh0KHsgZ2Vub21lczogc2VsZi5nZXRHZW5vbWVZT3JkZXIoKSB9KTtcblx0ICAgICAgd2luZG93LnNldFRpbWVvdXQoIHNlbGYuZHJhd0ZpZHVjaWFscy5iaW5kKHNlbGYpLCA1MCApO1xuXHQgIH0pXG5cdCAgO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGNsZWFyQnJ1c2hlcyAoKSB7XG5cdHRoaXMucm9vdC5zZWxlY3RBbGwoJ2cuYnJ1c2gnKVxuXHQgICAgLmVhY2goIGZ1bmN0aW9uIChiKSB7XG5cdCAgICAgICAgYi5icnVzaC5jbGVhcigpO1xuXHRcdGQzLnNlbGVjdCh0aGlzKS5jYWxsKGIuYnJ1c2gpO1xuXHQgICAgfSk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gUmV0dXJucyB0aGUgY3VycmVudCBicnVzaCBjb29yZGluYXRlcywgdHJhbnNsYXRlZCAoaWYgbmVlZGVkKSB0byByZWYgZ2Vub21lIGNvb3JkaW5hdGVzLlxuICAgIGJiR2V0UmVmQ29vcmRzICgpIHtcbiAgICAgIGxldCByZyA9IHRoaXMuYXBwLnJHZW5vbWU7XG4gICAgICBsZXQgYmxrID0gdGhpcy5icnVzaGluZztcbiAgICAgIGxldCBleHQgPSBibGsuYnJ1c2guZXh0ZW50KCk7XG4gICAgICBsZXQgciA9IHsgY2hyOiBibGsuY2hyLCBzdGFydDogZXh0WzBdLCBlbmQ6IGV4dFsxXSwgYmxvY2tJZDpibGsuYmxvY2tJZCB9O1xuICAgICAgbGV0IHRyID0gdGhpcy5hcHAudHJhbnNsYXRvcjtcbiAgICAgIGlmKCBibGsuZ2Vub21lICE9PSByZyApIHtcbiAgICAgICAgIC8vIHVzZXIgaXMgYnJ1c2hpbmcgYSBjb21wIGdlbm9tZXMgc28gZmlyc3QgdHJhbnNsYXRlXG5cdCAvLyBjb29yZGluYXRlcyB0byByZWYgZ2Vub21lXG5cdCBsZXQgcnMgPSB0aGlzLmFwcC50cmFuc2xhdG9yLnRyYW5zbGF0ZShibGsuZ2Vub21lLCByLmNociwgci5zdGFydCwgci5lbmQsIHJnKTtcblx0IGlmIChycy5sZW5ndGggPT09IDApIHJldHVybjtcblx0IHIgPSByc1swXTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHIuYmxvY2tJZCA9IHJnLm5hbWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gcjtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gaGFuZGxlciBmb3IgdGhlIHN0YXJ0IG9mIGEgYnJ1c2ggYWN0aW9uIGJ5IHRoZSB1c2VyIG9uIGEgYmxvY2tcbiAgICBiYlN0YXJ0IChibGssYkVsdCkge1xuICAgICAgdGhpcy5icnVzaGluZyA9IGJsaztcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYmJCcnVzaCAoKSB7XG4gICAgICAgIGxldCBldiA9IGQzLmV2ZW50LnNvdXJjZUV2ZW50O1xuXHRsZXQgeHQgPSB0aGlzLmJydXNoaW5nLmJydXNoLmV4dGVudCgpO1xuXHRsZXQgcyA9IE1hdGgucm91bmQoeHRbMF0pO1xuXHRsZXQgZSA9IE1hdGgucm91bmQoeHRbMV0pO1xuXHR0aGlzLnNob3dGbG9hdGluZ1RleHQoYCR7dGhpcy5icnVzaGluZy5jaHJ9OiR7c30uLiR7ZX1gLCBldi5jbGllbnRYLCBldi5jbGllbnRZKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgYmJFbmQgKCkge1xuICAgICAgbGV0IHNlID0gZDMuZXZlbnQuc291cmNlRXZlbnQ7XG4gICAgICBsZXQgeHQgPSB0aGlzLmJydXNoaW5nLmJydXNoLmV4dGVudCgpO1xuICAgICAgbGV0IGcgPSB0aGlzLmJydXNoaW5nLmdlbm9tZS5sYWJlbDtcbiAgICAgIC8vXG4gICAgICB0aGlzLmhpZGVGbG9hdGluZ1RleHQoKTtcbiAgICAgIC8vXG4gICAgICBpZiAoc2UuY3RybEtleSB8fCBzZS5hbHRLZXkgfHwgc2UubWV0YUtleSkge1xuXHQgIHRoaXMuY2xlYXJCcnVzaGVzKCk7XG5cdCAgdGhpcy5icnVzaGluZyA9IG51bGw7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgLy9cbiAgICAgIGlmIChNYXRoLmFicyh4dFswXSAtIHh0WzFdKSA8PSAxMCkge1xuXHQgIC8vIFVzZXIgY2xpY2tlZC4gUmVjZW50ZXIgdmlldyBvbiB0aGUgY2xpY2tlZCBjb29yZGluYXRlLiBcblx0ICAvLyBXaGljaGV2ZXIgZ2Vub21lIHRoZSB1c2VyIGNsaWNrZWQgaW4gYmVjb21lcyB0aGUgcmVmZXJlbmNlLlxuXHQgIC8vIFRoZSBjbGlja2VkIGNvb3JkaW5hdGU6XG5cdCAgbGV0IHhtaWQgPSAoeHRbMF0gKyB4dFsxXSkvMjtcblx0ICAvLyBzaXplIG9mIHZpZXdcblx0ICBsZXQgdyA9IHRoaXMuYXBwLmNvb3Jkcy5lbmQgLSB0aGlzLmFwcC5jb29yZHMuc3RhcnQgKyAxO1xuXHQgIC8vIHN0YXJ0aW5nIGNvb3JkaW5hdGUgaW4gY2xpY2tlZCBnZW5vbWUgb2YgbmV3IHZpZXdcblx0ICBsZXQgcyA9IE1hdGgucm91bmQoeG1pZCAtIHcvMik7XG5cdCAgLy9cblx0ICBsZXQgbmV3Q29udGV4dCA9IHsgcmVmOmcsIGNocjogdGhpcy5icnVzaGluZy5jaHIsIHN0YXJ0OiBzLCBlbmQ6IHMgKyB3IC0gMSB9O1xuXHQgIGlmICh0aGlzLmNtb2RlID09PSAnbGFuZG1hcmsnKSB7XG5cdCAgICAgIGxldCBsbWYgPSB0aGlzLmNvbnRleHQubGFuZG1hcmtGZWF0cy5maWx0ZXIoZiA9PiBmLmdlbm9tZSA9PT0gdGhpcy5icnVzaGluZy5nZW5vbWUpWzBdO1xuXHQgICAgICBpZiAobG1mKSB7XG5cdFx0ICBsZXQgbSA9ICh0aGlzLmJydXNoaW5nLmVuZCArIHRoaXMuYnJ1c2hpbmcuc3RhcnQpIC8gMjtcblx0XHQgIGxldCBkeCA9IHhtaWQgLSBtO1xuXHRcdCAgbmV3Q29udGV4dCA9IHsgcmVmOmcsIGRlbHRhOiB0aGlzLmNvbnRleHQuZGVsdGErZHggfTtcblx0ICAgICAgfVxuXHQgIH1cblx0ICB0aGlzLmFwcC5zZXRDb250ZXh0KG5ld0NvbnRleHQpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG5cdCAgLy8gVXNlciBkcmFnZ2VkLiBab29tIGluIG9yIG91dC5cblx0ICB0aGlzLmFwcC5zZXRDb250ZXh0KHsgcmVmOmcsIGNocjogdGhpcy5icnVzaGluZy5jaHIsIHN0YXJ0Onh0WzBdLCBlbmQ6eHRbMV0gfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWFyQnJ1c2hlcygpO1xuICAgICAgdGhpcy5icnVzaGluZyA9IG51bGw7XG4gICAgICB0aGlzLmRlYWxXaXRoVW53YW50ZWRDbGlja0V2ZW50ID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgaGlnaGxpZ2h0U3RyaXAgKGcsIGVsdCkge1xuXHRpZiAoZyA9PT0gdGhpcy5jdXJyZW50SExHKSByZXR1cm47XG5cdHRoaXMuY3VycmVudEhMRyA9IGc7XG5cdC8vXG5cdHRoaXMuc3ZnTWFpbi5zZWxlY3RBbGwoJy56b29tU3RyaXAnKVxuXHQgICAgLmNsYXNzZWQoJ2hpZ2hsaWdodGVkJywgZCA9PiBkLmdlbm9tZSA9PT0gZyk7XG5cdHRoaXMuYXBwLnNob3dCbG9ja3MoZyk7XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVXBkYXRlcyB0aGUgWm9vbVZpZXcgdG8gc2hvdyB0aGUgZ2l2ZW4gY29vcmRpbmF0ZSByYW5nZSBmcm9tIHRoZSByZWcgZ2Vub21lIGFuZCB0aGUgY29ycmVzcG9uZGluZ1xuICAgIC8vIHJhbmdlKHMpIGluIGVhY2ggY29tcGFyaXNvbiBnZW5vbWUuXG4gICAgLy9cbiAgICB1cGRhdGVWaWFNYXBwZWRDb29yZGluYXRlcyAoY29vcmRzKSB7XG5cdGxldCBjID0gKGNvb3JkcyB8fCB0aGlzLmFwcC5jb29yZHMpO1xuXHRkMy5zZWxlY3QoJyN6b29tQ29vcmRzJylbMF1bMF0udmFsdWUgPSBmb3JtYXRDb29yZHMoYy5jaHIsIGMuc3RhcnQsIGMuZW5kKTtcblx0ZDMuc2VsZWN0KCcjem9vbVdTaXplJylbMF1bMF0udmFsdWUgPSBNYXRoLnJvdW5kKGMuZW5kIC0gYy5zdGFydCArIDEpXG5cdC8vXG4gICAgICAgIGxldCBtZ3YgPSB0aGlzLmFwcDtcblx0Ly8gSXNzdWUgcmVxdWVzdHMgZm9yIGZlYXR1cmVzLiBPbmUgcmVxdWVzdCBwZXIgZ2Vub21lLCBlYWNoIHJlcXVlc3Qgc3BlY2lmaWVzIG9uZSBvciBtb3JlXG5cdC8vIGNvb3JkaW5hdGUgcmFuZ2VzLlxuXHQvLyBXYWl0IGZvciBhbGwgdGhlIGRhdGEgdG8gYmVjb21lIGF2YWlsYWJsZSwgdGhlbiBkcmF3LlxuXHQvL1xuXHRsZXQgcHJvbWlzZXMgPSBbXTtcblxuXHQvL1xuXHR0aGlzLnNob3dGZWF0dXJlRGV0YWlscyA9IChjLmVuZCAtIGMuc3RhcnQgKyAxKSA8PSB0aGlzLmNmZy5mZWF0dXJlRGV0YWlsVGhyZXNob2xkO1xuXG5cdC8vIEZpcnN0IHJlcXVlc3QgaXMgZm9yIHRoZSB0aGUgcmVmZXJlbmNlIGdlbm9tZS4gR2V0IGFsbCB0aGUgZmVhdHVyZXMgaW4gdGhlIHJhbmdlLlxuXHRwcm9taXNlcy5wdXNoKG1ndi5mZWF0dXJlTWFuYWdlci5nZXRGZWF0dXJlc0J5UmFuZ2UobWd2LnJHZW5vbWUsIFt7XG5cdCAgICAvLyBOZWVkIHRvIHNpbXVsYXRlIHRoZSByZXN1bHRzIGZyb20gY2FsbGluZyB0aGUgdHJhbnNsYXRvci4gXG5cdCAgICAvLyBcblx0ICAgIGNociAgICA6IGMuY2hyLFxuXHQgICAgc3RhcnQgIDogYy5zdGFydCxcblx0ICAgIGVuZCAgICA6IGMuZW5kLFxuXHQgICAgaW5kZXggIDogMCxcblx0ICAgIGZDaHIgICA6IGMuY2hyLFxuXHQgICAgZlN0YXJ0IDogYy5zdGFydCxcblx0ICAgIGZFbmQgICA6IGMuZW5kLFxuXHQgICAgZkluZGV4ICA6IDAsXG5cdCAgICBvcmkgICAgOiAnKycsXG5cdCAgICBibG9ja0lkOiBtZ3Yuckdlbm9tZS5uYW1lXG5cdH1dLCB0aGlzLnNob3dGZWF0dXJlRGV0YWlscykpO1xuXHRpZiAoISB0aGlzLnJvb3QuY2xhc3NlZCgnY2xvc2VkJykpIHtcblx0ICAgIC8vIEFkZCBhIHJlcXVlc3QgZm9yIGVhY2ggY29tcGFyaXNvbiBnZW5vbWUsIHVzaW5nIHRyYW5zbGF0ZWQgY29vcmRpbmF0ZXMuIFxuXHQgICAgbWd2LmNHZW5vbWVzLmZvckVhY2goY0dlbm9tZSA9PiB7XG5cdFx0bGV0IHJhbmdlcyA9IG1ndi50cmFuc2xhdG9yLnRyYW5zbGF0ZSggbWd2LnJHZW5vbWUsIGMuY2hyLCBjLnN0YXJ0LCBjLmVuZCwgY0dlbm9tZSApO1xuXHRcdGxldCBwID0gbWd2LmZlYXR1cmVNYW5hZ2VyLmdldEZlYXR1cmVzQnlSYW5nZShjR2Vub21lLCByYW5nZXMsIHRoaXMuc2hvd0ZlYXR1cmVEZXRhaWxzKTtcblx0XHRwcm9taXNlcy5wdXNoKHApO1xuXHQgICAgfSk7XG5cdH1cblx0cmV0dXJuIFByb21pc2UuYWxsKHByb21pc2VzKVxuICAgIH1cbiAgICAvLyBVcGRhdGVzIHRoZSBab29tVmlldyB0byBzaG93IHRoZSByZWdpb24gYXJvdW5kIGEgbGFuZG1hcmsgaW4gZWFjaCBnZW5vbWUuXG4gICAgLy9cbiAgICAvLyBjb29yZHMgPSB7XG4gICAgLy8gICAgIGxhbmRtYXJrIDogaWQgb2YgYSBmZWF0dXJlIHRvIHVzZSBhcyBhIHJlZmVyZW5jZVxuICAgIC8vICAgICBmbGFua3x3aWR0aCA6IHNwZWNpZnkgb25lIG9mIGZsYW5rIG9yIHdpZHRoLiBcbiAgICAvLyAgICAgICAgIGZsYW5rID0gYW1vdW50IG9mIGZsYW5raW5nIHJlZ2lvbiAoYnApIHRvIGluY2x1ZGUgYXQgYm90aCBlbmRzIG9mIHRoZSBsYW5kbWFyaywgXG4gICAgLy8gICAgICAgICBzbyB0aGUgdG90YWwgdmlld2luZyByZWdpb24gPSBmbGFuayArIGxlbmd0aChsYW5kbWFyaykgKyBmbGFuay5cbiAgICAvLyAgICAgICAgIHdpZHRoID0gdG90YWwgdmlld2luZyByZWdpb24gd2lkdGguIElmIGJvdGggd2lkdGggYW5kIGZsYW5rIGFyZSBzcGVjaWZpZWQsIGZsYW5rIGlzIGlnbm9yZWQuXG4gICAgLy8gICAgIGRlbHRhIDogYW1vdW50IHRvIHNoaWZ0IHRoZSB2aWV3IGxlZnQvcmlnaHRcbiAgICAvLyB9XG4gICAgLy8gXG4gICAgLy8gVGhlIGxhbmRtYXJrIG11c3QgZXhpc3QgaW4gdGhlIGN1cnJlbnQgcmVmZXJlbmNlIGdlbm9tZS4gXG4gICAgLy9cbiAgICB1cGRhdGVWaWFMYW5kbWFya0Nvb3JkaW5hdGVzIChjb29yZHMpIHtcblx0bGV0IGMgPSBjb29yZHM7XG5cdGxldCBtZ3YgPSB0aGlzLmFwcDtcbiAgICAgICAgbGV0IHNlbGYgPSB0aGlzO1xuXHRsZXQgcmYgPSBjb29yZHMubGFuZG1hcmtSZWZGZWF0O1xuXHRsZXQgZmVhdHMgPSBjb29yZHMubGFuZG1hcmtGZWF0cztcblx0aWYgKHRoaXMucm9vdC5jbGFzc2VkKCdjbG9zZWQnKSlcblx0ICAgIGZlYXRzID0gZmVhdHMuZmlsdGVyKGYgPT4gZi5nZW5vbWUgPT09IHRoaXMuYXBwLnJHZW5vbWUpO1xuXHRsZXQgZGVsdGEgPSBjb29yZHMuZGVsdGEgfHwgMDtcblxuXHQvLyBjb21wdXRlIHJhbmdlcyBhcm91bmQgbGFuZG1hcmsgaW4gZWFjaCBnZW5vbWVcblx0bGV0IHJhbmdlcyA9IGZlYXRzLm1hcChmID0+IHtcblx0ICAgIGxldCBmbGFuayA9IGMubGVuZ3RoID8gKGMubGVuZ3RoIC0gZi5sZW5ndGgpIC8gMiA6IGMuZmxhbms7XG5cdCAgICBsZXQgY2xlbmd0aCA9IGYuZ2Vub21lLmdldENocm9tb3NvbWUoZi5jaHIpLmxlbmd0aDtcblx0ICAgIGxldCB3ICAgICA9IGMubGVuZ3RoID8gYy5sZW5ndGggOiAoZi5sZW5ndGggKyAyKmZsYW5rKTtcblx0ICAgIGxldCBzaWduID0gZi5zdHJhbmQgPT09ICctJyA/IC0xIDogMTtcblx0ICAgIGxldCBzdGFydCA9IGNsaXAoTWF0aC5yb3VuZChkZWx0YSArIGYuc3RhcnQgLSBmbGFuayksIDEsIGNsZW5ndGgpO1xuXHQgICAgbGV0IGVuZCAgID0gY2xpcChNYXRoLnJvdW5kKHN0YXJ0ICsgdyksIHN0YXJ0LCBjbGVuZ3RoKVxuXHQgICAgbGV0IGZkZWx0YSA9IGYubGVuZ3RoIC8gMjtcblx0ICAgIGxldCByYW5nZSA9IHtcblx0XHRnZW5vbWU6XHQgICAgZi5nZW5vbWUsXG5cdFx0Y2hyOlx0ICAgIGYuY2hyLFxuXHRcdGNocm9tb3NvbWU6IGYuZ2Vub21lLmdldENocm9tb3NvbWUoZi5jaHIpLFxuXHRcdHN0YXJ0OiAgICAgIHN0YXJ0IC0gc2lnbiAqIGZkZWx0YSxcblx0XHRlbmQ6ICAgICAgICBlbmQgICAtIHNpZ24gKiBmZGVsdGFcblx0ICAgIH0gO1xuXHQgICAgaWYgKGYuZ2Vub21lID09PSBtZ3Yuckdlbm9tZSkge1xuXHRcdGxldCBjID0gdGhpcy5hcHAuY29vcmRzID0gcmFuZ2U7XG5cdFx0ZDMuc2VsZWN0KCcjem9vbUNvb3JkcycpWzBdWzBdLnZhbHVlID0gZm9ybWF0Q29vcmRzKGMuY2hyLCBjLnN0YXJ0LCBjLmVuZCk7XG5cdFx0ZDMuc2VsZWN0KCcjem9vbVdTaXplJylbMF1bMF0udmFsdWUgPSBNYXRoLnJvdW5kKGMuZW5kIC0gYy5zdGFydCArIDEpXG5cdCAgICB9XG5cdCAgICByZXR1cm4gcmFuZ2U7XG5cdH0pO1xuXHRsZXQgc2Vlbkdlbm9tZXMgPSBuZXcgU2V0KCk7XG5cdGxldCByQ29vcmRzO1xuXHQvLyBHZXQgKHByb21pc2VzIGZvcikgdGhlIGZlYXR1cmVzIGluIGVhY2ggcmFuZ2UuXG5cdGxldCBwcm9taXNlcyA9IHJhbmdlcy5tYXAociA9PiB7XG4gICAgICAgICAgICBsZXQgcnJzO1xuXHQgICAgc2Vlbkdlbm9tZXMuYWRkKHIuZ2Vub21lKTtcblx0ICAgIGlmIChyLmdlbm9tZSA9PT0gbWd2LnJHZW5vbWUpe1xuXHRcdC8vIHRoZSByZWYgZ2Vub21lIHJhbmdlXG5cdFx0ckNvb3JkcyA9IHI7XG5cdFx0Ly9cblx0XHR0aGlzLnNob3dGZWF0dXJlRGV0YWlscyA9IChyLmVuZCAtIHIuc3RhcnQgKyAxKSA8PSB0aGlzLmNmZy5mZWF0dXJlRGV0YWlsVGhyZXNob2xkO1xuXHRcdC8vXG5cdCAgICAgICAgcnJzID0gW3tcblx0XHQgICAgY2hyICAgIDogci5jaHIsXG5cdFx0ICAgIHN0YXJ0ICA6IHIuc3RhcnQsXG5cdFx0ICAgIGVuZCAgICA6IHIuZW5kLFxuXHRcdCAgICBpbmRleCAgOiAwLFxuXHRcdCAgICBmQ2hyICAgOiByLmNocixcblx0XHQgICAgZlN0YXJ0IDogci5zdGFydCxcblx0XHQgICAgZkVuZCAgIDogci5lbmQsXG5cdFx0ICAgIGZJbmRleCAgOiAwLFxuXHRcdCAgICBvcmkgICAgOiAnKycsXG5cdFx0ICAgIGJsb2NrSWQ6IG1ndi5yR2Vub21lLm5hbWVcblx0XHR9XTtcblx0ICAgIH1cblx0ICAgIGVsc2UgeyBcblx0XHQvLyB0dXJuIHRoZSBzaW5nbGUgcmFuZ2UgaW50byBhIHJhbmdlIGZvciBlYWNoIG92ZXJsYXBwaW5nIHN5bnRlbnkgYmxvY2sgd2l0aCB0aGUgcmVmIGdlbm9tZVxuXHQgICAgICAgIHJycyA9IG1ndi50cmFuc2xhdG9yLnRyYW5zbGF0ZShyLmdlbm9tZSwgci5jaHIsIHIuc3RhcnQsIHIuZW5kLCBtZ3Yuckdlbm9tZSwgdHJ1ZSk7XG5cdCAgICB9XG5cdCAgICByZXR1cm4gbWd2LmZlYXR1cmVNYW5hZ2VyLmdldEZlYXR1cmVzQnlSYW5nZShyLmdlbm9tZSwgcnJzLCB0aGlzLnNob3dGZWF0dXJlRGV0YWlscyk7XG5cdH0pO1xuXHQvLyBGb3IgZWFjaCBnZW5vbWUgd2hlcmUgdGhlIGxhbmRtYXJrIGRvZXMgbm90IGV4aXN0LCBjb21wdXRlIGEgbWFwcGVkIHJhbmdlIChhcyBpbiBtYXBwZWQgY21vZGUpLlxuXHRpZiAoIXRoaXMucm9vdC5jbGFzc2VkKCdjbG9zZWQnKSlcblx0ICAgIG1ndi5jR2Vub21lcy5mb3JFYWNoKGcgPT4ge1xuXHRcdGlmICghIHNlZW5HZW5vbWVzLmhhcyhnKSkge1xuXHRcdCAgICBsZXQgcnJzID0gbWd2LnRyYW5zbGF0b3IudHJhbnNsYXRlKG1ndi5yR2Vub21lLCByQ29vcmRzLmNociwgckNvb3Jkcy5zdGFydCwgckNvb3Jkcy5lbmQsIGcpO1xuXHRcdCAgICBwcm9taXNlcy5wdXNoKCBtZ3YuZmVhdHVyZU1hbmFnZXIuZ2V0RmVhdHVyZXNCeVJhbmdlKGcsIHJycywgdGhpcy5zaG93RmVhdHVyZURldGFpbHMpICk7XG5cdFx0fVxuXHQgICAgfSk7XG5cdC8vIFdoZW4gYWxsIHRoZSBkYXRhIGlzIHJlYWR5LCBkcmF3LlxuXHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgIH1cbiAgICAvL1xuICAgIHVwZGF0ZSAoY29udGV4dCkge1xuXHR0aGlzLmNvbnRleHQgPSBjb250ZXh0IHx8IHRoaXMuY29udGV4dDtcblx0dGhpcy5oaWdobGlnaHRlZCA9IHRoaXMuY29udGV4dC5oaWdobGlnaHQ7XG5cdHRoaXMuZ2Vub21lcyA9IHRoaXMuY29udGV4dC5nZW5vbWVzO1xuXHR0aGlzLmRtb2RlID0gdGhpcy5jb250ZXh0LmRtb2RlO1xuXHR0aGlzLmNtb2RlID0gdGhpcy5jb250ZXh0LmNtb2RlO1xuXHRsZXQgcDtcblx0aWYgKHRoaXMuY21vZGUgPT09ICdtYXBwZWQnKVxuXHQgICAgcCA9IHRoaXMudXBkYXRlVmlhTWFwcGVkQ29vcmRpbmF0ZXModGhpcy5hcHAuY29vcmRzKTtcblx0ZWxzZVxuXHQgICAgcCA9IHRoaXMudXBkYXRlVmlhTGFuZG1hcmtDb29yZGluYXRlcyh0aGlzLmFwcC5sY29vcmRzKTtcblx0cC50aGVuKCBkYXRhID0+IHtcblx0ICAgIHRoaXMuZHJhdyh0aGlzLm11bmdlRGF0YShkYXRhKSk7XG5cdH0pO1xuXHRyZXR1cm4gcDtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIG1lcmdlU2Jsb2NrUnVucyAoZGF0YSkge1xuXHQvLyAtLS0tLVxuXHQvLyBSZWR1Y2VyIGZ1bmN0aW9uLiBXaWxsIGJlIGNhbGxlZCB3aXRoIHRoZXNlIGFyZ3M6XG5cdC8vICAgbmJsY2tzIChsaXN0KSBOZXcgYmxvY2tzLiAoY3VycmVudCBhY2N1bXVsYXRvciB2YWx1ZSlcblx0Ly8gICBcdEEgbGlzdCBvZiBsaXN0cyBvZiBzeW50ZW55IGJsb2Nrcy5cblx0Ly8gICBibGsgKHN5bnRlbnkgYmxvY2spIHRoZSBjdXJyZW50IHN5bnRlbnkgYmxvY2tcblx0Ly8gICBpIChpbnQpIFRoZSBpdGVyYXRpb24gY291bnQuXG5cdC8vIFJldHVybnM6XG5cdC8vICAgbGlzdCBvZiBsaXN0cyBvZiBibG9ja3Ncblx0bGV0IG1lcmdlciA9IChuYmxrcywgYiwgaSkgPT4ge1xuXHQgICAgbGV0IGluaXRCbGsgPSBmdW5jdGlvbiAoYmIpIHtcblx0XHRsZXQgbmIgPSBPYmplY3QuYXNzaWduKHt9LCBiYik7XG5cdFx0bmIuc3VwZXJCbG9jayA9IHRydWU7XG5cdFx0bmIuZmVhdHVyZXMgPSBiYi5mZWF0dXJlcy5jb25jYXQoKTtcblx0XHRuYi5zYmxvY2tzID0gW2JiXTtcblx0XHRuYi5vcmkgPSAnKydcblx0XHRyZXR1cm4gbmI7XG5cdCAgICB9O1xuXHQgICAgaWYgKGkgPT09IDApe1xuXHRcdG5ibGtzLnB1c2goaW5pdEJsayhiKSk7XG5cdFx0cmV0dXJuIG5ibGtzO1xuXHQgICAgfVxuXHQgICAgbGV0IGxhc3RCbGsgPSBuYmxrc1tuYmxrcy5sZW5ndGggLSAxXTtcblx0ICAgIGlmIChiLmNociAhPT0gbGFzdEJsay5jaHIgfHwgYi5pbmRleCAtIGxhc3RCbGsuaW5kZXggIT09IDEpIHtcblx0ICAgICAgICBuYmxrcy5wdXNoKGluaXRCbGsoYikpO1xuXHRcdHJldHVybiBuYmxrcztcblx0ICAgIH1cblx0ICAgIC8vIG1lcmdlXG5cdCAgICBsYXN0QmxrLmluZGV4ID0gYi5pbmRleDtcblx0ICAgIGxhc3RCbGsuZW5kID0gYi5lbmQ7XG5cdCAgICBsYXN0QmxrLmJsb2NrRW5kID0gYi5ibG9ja0VuZDtcblx0ICAgIGxhc3RCbGsuZmVhdHVyZXMgPSBsYXN0QmxrLmZlYXR1cmVzLmNvbmNhdChiLmZlYXR1cmVzKTtcblx0ICAgIGxldCBsYXN0U2IgPSBsYXN0QmxrLnNibG9ja3NbbGFzdEJsay5zYmxvY2tzLmxlbmd0aCAtIDFdO1xuXHQgICAgbGV0IGQgPSBiLnN0YXJ0IC0gbGFzdFNiLmVuZDtcblx0ICAgIGxhc3RTYi5lbmQgKz0gZC8yO1xuXHQgICAgYi5zdGFydCAtPSBkLzI7XG5cdCAgICBsYXN0QmxrLnNibG9ja3MucHVzaChiKTtcblx0ICAgIHJldHVybiBuYmxrcztcblx0fTtcblx0Ly8gLS0tLS1cbiAgICAgICAgZGF0YS5mb3JFYWNoKChnZGF0YSxpKSA9PiB7XG5cdCAgICBpZiAodGhpcy5kbW9kZSA9PT0gJ2NvbXBhcmlzb24nKSB7XG5cdFx0Z2RhdGEuYmxvY2tzLnNvcnQoIChhLGIpID0+IGEuaW5kZXggLSBiLmluZGV4ICk7XG5cdFx0Z2RhdGEuYmxvY2tzID0gZ2RhdGEuYmxvY2tzLnJlZHVjZShtZXJnZXIsW10pO1xuXHQgICAgfVxuXHQgICAgZWxzZSB7XG5cdFx0Ly8gZmlyc3Qgc29ydCBieSByZWYgZ2Vub21lIG9yZGVyXG5cdFx0Z2RhdGEuYmxvY2tzLnNvcnQoIChhLGIpID0+IGEuZkluZGV4IC0gYi5mSW5kZXggKTtcblx0XHQvLyBTdWItZ3JvdXAgaW50byBydW5zIG9mIHNhbWUgY29tcCBnZW5vbWUgY2hyb21vc29tZS5cblx0XHRsZXQgdG1wID0gZ2RhdGEuYmxvY2tzLnJlZHVjZSgobmJzLCBiLCBpKSA9PiB7XG5cdFx0ICAgIGlmIChpID09PSAwIHx8IG5ic1tuYnMubGVuZ3RoIC0gMV1bMF0uY2hyICE9PSBiLmNocilcblx0XHRcdG5icy5wdXNoKFtiXSk7XG5cdFx0ICAgIGVsc2Vcblx0XHRcdG5ic1tuYnMubGVuZ3RoIC0gMV0ucHVzaChiKTtcblx0XHQgICAgcmV0dXJuIG5icztcblx0XHR9LCBbXSk7XG5cdFx0Ly8gU29ydCBlYWNoIHN1Ymdyb3VwIGludG8gY29tcGFyaXNvbiBnZW5vbWUgb3JkZXJcblx0XHR0bXAuZm9yRWFjaCggc3ViZ3JwID0+IHN1YmdycC5zb3J0KChhLGIpID0+IGEuaW5kZXggLSBiLmluZGV4KSApO1xuXHRcdC8vIEZsYXR0ZW4gdGhlIGxpc3Rcblx0XHR0bXAgPSB0bXAucmVkdWNlKChsc3QsIGN1cnIpID0+IGxzdC5jb25jYXQoY3VyciksIFtdKTtcblx0XHQvLyBOb3cgY3JlYXRlIHRoZSBzdXBlcmdyb3Vwcy5cblx0XHRnZGF0YS5ibG9ja3MgPSB0bXAucmVkdWNlKG1lcmdlcixbXSk7XG5cdCAgICB9XG5cdH0pO1xuXHRyZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvL1xuICAgIHVuaXFpZnlCbG9ja3MgKGJsb2Nrcykge1xuXHQvLyBoZWxwZXIgZnVuY3Rpb24uIFdoZW4gc2Jsb2NrIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGdlbm9tZXMgaXMgY29uZnVzZWQsIHJlcXVlc3Rpbmcgb25lXG5cdC8vIHJlZ2lvbiBpbiBnZW5vbWUgQSBjYW4gZW5kIHVwIHJlcXVlc3RpbmcgdGhlIHNhbWUgcmVnaW9uIGluIGdlbm9tZSBCIG11bHRpcGxlIHRpbWVzLlxuXHQvLyBUaGlzIGZ1bmN0aW9uIGF2b2lkcyBkcmF3aW5nIHRoZSBzYW1lIHNibG9jayB0d2ljZS4gKE5COiBSZWFsbHkgbm90IHN1cmUgd2hlcmUgdGhpcyBcblx0Ly8gY2hlY2sgaXMgYmVzdCBkb25lLiBDb3VsZCBwdXNoIGl0IGZhcnRoZXIgdXBzdHJlYW0uKVxuXHRsZXQgc2VlbiA9IG5ldyBTZXQoKTtcblx0cmV0dXJuIGJsb2Nrcy5maWx0ZXIoIGIgPT4geyBcblx0ICAgIGlmIChzZWVuLmhhcyhiLmluZGV4KSkgcmV0dXJuIGZhbHNlO1xuXHQgICAgc2Vlbi5hZGQoYi5pbmRleCk7XG5cdCAgICByZXR1cm4gdHJ1ZTtcblx0fSk7XG4gICAgfTtcbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBBcHBsaWVzIHNldmVyYWwgdHJhbnNmb3JtYXRpb24gc3RlcHMgb24gdGhlIGRhdGEgYXMgcmV0dXJuZWQgYnkgdGhlIHNlcnZlciB0byBwcmVwYXJlIGZvciBkcmF3aW5nLlxuICAgIC8vIElucHV0IGRhdGEgaXMgc3RydWN0dXJlZCBhcyBmb2xsb3dzOlxuICAgIC8vICAgICBkYXRhID0gWyB6b29tU3RyaXBfZGF0YSBdXG4gICAgLy8gICAgIHpvb21TdHJpcF9kYXRhID0geyBnZW5vbWUgWyB6b29tQmxvY2tfZGF0YSBdIH1cbiAgICAvLyAgICAgem9vbUJsb2NrX2RhdGEgPSB7IHhzY2FsZSwgY2hyLCBzdGFydCwgZW5kLCBpbmRleCwgZkNociwgZlN0YXJ0LCBmRW5kLCBmSW5kZXgsIG9yaSwgWyBmZWF0dXJlX2RhdGEgXSB9XG4gICAgLy8gICAgIGZlYXR1cmVfZGF0YSA9IHsgSUQsIGNhbm9uaWNhbCwgc3ltYm9sLCBjaHIsIHN0YXJ0LCBlbmQsIHN0cmFuZCwgdHlwZSwgYmlvdHlwZSB9XG4gICAgLy9cbiAgICAvLyBBZ2FpbiwgaW4gRW5nbGlzaDpcbiAgICAvLyAgLSBkYXRhIGlzIGEgbGlzdCBvZiBpdGVtcywgb25lIHBlciBzdHJpcCB0byBiZSBkaXNwbGF5ZWQuIEl0ZW1bMF0gaXMgZGF0YSBmb3IgdGhlIHJlZiBnZW5vbWUuXG4gICAgLy8gICAgSXRlbXNbMStdIGFyZSBkYXRhIGZvciB0aGUgY29tcGFyaXNvbiBnZW5vbWUuXG4gICAgLy8gIC0gZWFjaCBzdHJpcCBpdGVtIGlzIGFuIG9iamVjdCBjb250YWluaW5nIGEgZ2Vub21lIGFuZCBhIGxpc3Qgb2YgYmxvY2tzLiBJdGVtWzBdIGFsd2F5cyBoYXMgXG4gICAgLy8gICAgYSBzaW5nbGUgYmxvY2suXG4gICAgLy8gIC0gZWFjaCBibG9jayBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhIGNocm9tb3NvbWUsIHN0YXJ0LCBlbmQsIG9yaWVudGF0aW9uLCBldGMsIGFuZCBhIGxpc3Qgb2YgZmVhdHVyZXMuXG4gICAgLy8gIC0gZWFjaCBmZWF0dXJlIGhhcyBjaHIsc3RhcnQsZW5kLHN0cmFuZCx0eXBlLGJpb3R5cGUsSURcbiAgICAvL1xuICAgIC8vIEJlY2F1c2UgU0Jsb2NrcyBjYW4gYmUgdmVyeSBmcmFnbWVudGVkLCBvbmUgY29udGlndW91cyByZWdpb24gaW4gdGhlIHJlZiBnZW5vbWUgY2FuIHR1cm4gaW50byBcbiAgICAvLyBhIGJhemlsbGlvbiB0aW55IGJsb2NrcyBpbiB0aGUgY29tcGFyaXNvbi4gVGhlIHJlc3VsdGluZyByZW5kZXJpbmcgaXMgamFycmluZyBhbmQgdW51c2FibGUuXG4gICAgLy8gVGhlIGRyYXdpbmcgcm91dGluZSBtb2RpZmllcyB0aGUgZGF0YSBieSBtZXJnaW5nIHJ1bnMgb2YgY29uc2VjdXRpdmUgYmxvY2tzIGluIGVhY2ggY29tcCBnZW5vbWUuXG4gICAgLy8gVGhlIGRhdGEgY2hhbmdlIGlzIHRvIGluc2VydCBhIGdyb3VwaW5nIGxheWVyIG9uIHRvcCBvZiB0aGUgc2Jsb2Nrcywgc3BlY2lmaWNhbGx5LCBcbiAgICAvLyAgICAgem9vbVN0cmlwX2RhdGEgPSB7IGdlbm9tZSBbIHpvb21CbG9ja19kYXRhIF0gfVxuICAgIC8vIGJlY29tZXNcbiAgICAvLyAgICAgem9vbVN0cmlwX2RhdGEgPSB7IGdlbm9tZSBbIHpvb21TdXBlckJsb2NrX2RhdGEgXSB9XG4gICAgLy8gICAgIHpvb21TdXBlckJsb2NrX2RhdGEgPSB7IGNociBzdGFydCBlbmQgYmxvY2tzIFsgem9vbUJsb2NrX2RhdGEgXSB9XG4gICAgLy9cbiAgICBtdW5nZURhdGEgKGRhdGEpIHtcbiAgICAgICAgZGF0YS5mb3JFYWNoKGdEYXRhID0+IHtcblx0ICAgIGdEYXRhLmJsb2NrcyA9IHRoaXMudW5pcWlmeUJsb2NrcyhnRGF0YS5ibG9ja3MpXG5cdCAgICAvLyBFYWNoIHN0cmlwIGlzIGluZGVwZW5kZW50bHkgc2Nyb2xsYWJsZS4gSW5pdCBpdHMgb2Zmc2V0IChpbiBieXRlcykuXG5cdCAgICBnRGF0YS5kZWx0YUIgPSAwO1xuXHQgICAgLy8gRWFjaCBzdHJpcCBpcyBpbmRlcGVuZGVudGx5IHNjYWxhYmxlLiBJbml0IHNjYWxlLlxuXHQgICAgZ0RhdGEueFNjYWxlID0gMS4wO1xuXHR9KTtcblx0ZGF0YSA9IHRoaXMubWVyZ2VTYmxvY2tSdW5zKGRhdGEpO1xuXHQvLyBcblx0ZGF0YS5mb3JFYWNoKCBnRGF0YSA9PiB7XG5cdCAgLy8gXG5cdCAgZ0RhdGEubWF4TGFuZXNQID0gMDtcblx0ICBnRGF0YS5tYXhMYW5lc04gPSAwO1xuXHQgIGdEYXRhLm1heExhbmVzID0gMDtcblx0ICBnRGF0YS5ibG9ja3MuZm9yRWFjaCggc2I9PiB7XG5cdCAgICBzYi5mZWF0dXJlcy5mb3JFYWNoKGYgPT4ge1xuXHRcdGdEYXRhLm1heExhbmVzID0gTWF0aC5tYXgoZ0RhdGEubWF4TGFuZXMsIGYubGFuZTIgKyBmLnRyYW5zY3JpcHRfY291bnQpO1xuXHRcdGlmIChmLmxhbmUgPiAwKVxuXHRcdCAgICBnRGF0YS5tYXhMYW5lc1AgPSBNYXRoLm1heChnRGF0YS5tYXhMYW5lc1AsIGYubGFuZSlcblx0XHRlbHNlXG5cdFx0ICAgIGdEYXRhLm1heExhbmVzTiA9IE1hdGgubWF4KGdEYXRhLm1heExhbmVzTiwgLWYubGFuZSlcblx0ICAgIH0pO1xuXHQgIH0pO1xuXHQgIGlmIChnRGF0YS5ibG9ja3MubGVuZ3RoID4gMSlcblx0ICAgICAgZ0RhdGEuYmxvY2tzID0gZ0RhdGEuYmxvY2tzLmZpbHRlcihiPT5iLmZlYXR1cmVzLmxlbmd0aCA+IDApO1xuXHQgIGlmICh0aGlzLnNob3dGZWF0dXJlRGV0YWlscyAmJiB0aGlzLnNwcmVhZFRyYW5zY3JpcHRzKSB7XG5cdCAgICAgIGdEYXRhLnN0cmlwSGVpZ2h0ID0gMTUgKyB0aGlzLmNmZy5sYW5lSGVpZ2h0TWlub3IgKiBnRGF0YS5tYXhMYW5lcztcblx0ICAgICAgZ0RhdGEuemVyb09mZnNldCA9IDA7XG5cdCAgfVxuXHQgIGVsc2Uge1xuXHQgICAgICBnRGF0YS5zdHJpcEhlaWdodCA9IDE1ICsgdGhpcy5jZmcubGFuZUhlaWdodCAqIChnRGF0YS5tYXhMYW5lc1AgKyBnRGF0YS5tYXhMYW5lc04pO1xuXHQgICAgICBnRGF0YS56ZXJvT2Zmc2V0ID0gdGhpcy5jZmcubGFuZUhlaWdodCAqIGdEYXRhLm1heExhbmVzUDtcblx0ICB9XG5cdH0pO1xuXHRyZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBMYXlzIG91dCB0aGUgZmVhdHVyZXMgd2l0aGluIGFuIHNibG9ja1xuICAgIGxheW91dFNCRmVhdHVyZXMgKHNiKSB7XG5cdGxldCBmeCA9IGZ1bmN0aW9uKGYpIHtcblx0ICAgIGYueCA9IHNiLnhzY2FsZShNYXRoLm1heChmLnN0YXJ0LHNiLnN0YXJ0KSlcblx0ICAgIGYud2lkdGggPSBNYXRoLmFicyhzYi54c2NhbGUoTWF0aC5taW4oZi5lbmQsc2IuZW5kKSkgLSBzYi54c2NhbGUoTWF0aC5tYXgoZi5zdGFydCxzYi5zdGFydCkpKSArIDE7XG5cdCAgICBpZiAoZi5lbmQgPCBzYi5zdGFydCB8fCBmLnN0YXJ0ID4gc2IuZW5kKSBmLndpZHRoID0gMDtcblx0fVxuXHRsZXQgZnkgPSBmID0+IHtcblx0ICAgIGlmICh0aGlzLnNob3dGZWF0dXJlRGV0YWlscyAmJiB0aGlzLnNwcmVhZFRyYW5zY3JpcHRzKSB7XG5cdCAgICAgICAgZi55ID0gZi5sYW5lMiAqIHRoaXMuY2ZnLmxhbmVIZWlnaHRNaW5vcjtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdC8vIHBvcyBzdHJhbmQgZmVhdHVyZXMgYWJvdmUgYXhpcyBsaW5lLCBuZWcgc3RyYW5kIGJlbG93XG5cdFx0Zi55ID0gLXRoaXMuY2ZnLmxhbmVIZWlnaHQqZi5sYW5lIC0gKGYuc3RyYW5kID09PSAnKycgPyAwIDogdGhpcy5jZmcuZmVhdEhlaWdodCk7XG5cdCAgICB9XG5cdH1cbiAgICAgICAgc2IuZmVhdHVyZXMuZm9yRWFjaCggZiA9PiB7XG5cdCAgICBmeChmKTtcblx0ICAgIGZ5KGYpO1xuXHQgICAgZi50cmFuc2NyaXB0cyAmJiBmLnRyYW5zY3JpcHRzLmZvckVhY2goIHQgPT4ge1xuXHQgICAgICAgIGZ4KHQpO1xuXHRcdHQueSA9IGYueTtcblx0XHR0LmV4b25zLmZvckVhY2goIGUgPT4ge1xuXHRcdCAgICBmeChlKTtcblx0XHQgICAgZS55ID0gZi55O1xuXHRcdH0pO1xuXHQgICAgfSk7XG5cdH0pO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIE9yZGVycyBzYmxvY2tzIGhvcml6b250YWxseSB3aXRoaW4gZWFjaCBnZW5vbWUuIFRyYW5zbGF0ZXMgdGhlbSBpbnRvIHBvc2l0aW9uLlxuICAgIC8vXG4gICAgbGF5b3V0U0Jsb2NrcyAoc2Jsb2Nrcykge1xuXHQvLyBTb3J0IHRoZSBzYmxvY2tzIGluIGVhY2ggc3RyaXAgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IGRyYXdpbmcgbW9kZS5cblx0bGV0IGNtcEZpZWxkID0gdGhpcy5kbW9kZSA9PT0gJ2NvbXBhcmlzb24nID8gJ2luZGV4JyA6ICdmSW5kZXgnO1xuXHRsZXQgY21wRnVuYyA9IChhLGIpID0+IGEuX19kYXRhX19bY21wRmllbGRdLWIuX19kYXRhX19bY21wRmllbGRdO1xuXHRzYmxvY2tzLmZvckVhY2goIHN0cmlwID0+IHN0cmlwLnNvcnQoIGNtcEZ1bmMgKSApO1xuXHRsZXQgcHN0YXJ0ID0gW107IC8vIG9mZnNldCAoaW4gcGl4ZWxzKSBvZiBzdGFydCBwb3NpdGlvbiBvZiBuZXh0IGJsb2NrLCBieSBzdHJpcCBpbmRleCAoMD09PXJlZilcblx0bGV0IGJzdGFydCA9IFtdOyAvLyBibG9jayBzdGFydCBwb3MgKGluIGJwKSBhc3NvYyB3aXRoIHBzdGFydFxuXHRsZXQgY2NociA9IG51bGw7XG5cdGxldCBzZWxmID0gdGhpcztcblx0bGV0IEdBUCAgPSAxNjsgICAvLyBsZW5ndGggb2YgZ2FwIGJldHdlZW4gYmxvY2tzIG9mIGRpZmYgY2hyb21zLlxuXHRsZXQgZHg7XG5cdGxldCBwZW5kO1xuXHRzYmxvY2tzLmVhY2goIGZ1bmN0aW9uIChiLGksaikgeyAvLyBiPWJsb2NrLCBpPWluZGV4IHdpdGhpbiBzdHJpcCwgaj1zdHJpcCBpbmRleFxuXHQgICAgbGV0IGdkID0gdGhpcy5fX2RhdGFfXy5nZW5vbWU7XG5cdCAgICBsZXQgYmxlbiA9IHNlbGYucHBiICogKGIuZW5kIC0gYi5zdGFydCArIDEpOyAvLyB0b3RhbCBzY3JlZW4gd2lkdGggb2YgdGhpcyBzYmxvY2tcblx0ICAgIGIueHNjYWxlID0gZDMuc2NhbGUubGluZWFyKCkuZG9tYWluKFtiLnN0YXJ0LCBiLmVuZF0pLnJhbmdlKCBbMCwgYmxlbl0gKTtcblx0ICAgIC8vXG5cdCAgICBpZiAoaT09PTApIHtcblx0XHQvLyBmaXJzdCBibG9jayBpbiBlYWNoIHN0cmlwIGluaXRzXG5cdFx0cHN0YXJ0W2pdID0gMDtcblx0XHRnZC5wd2lkdGggPSBibGVuO1xuXHRcdGJzdGFydFtqXSA9IGIuc3RhcnQ7XG5cdFx0ZHggPSAwO1xuXHRcdGNjaHIgPSBiLmNocjtcblx0ICAgIH1cblx0ICAgIGVsc2Uge1xuXHRcdGdkLnB3aWR0aCArPSBibGVuO1xuXHRcdGR4ID0gYi5jaHIgPT09IGNjaHIgPyBwc3RhcnRbal0gKyBzZWxmLnBwYiAqIChiLnN0YXJ0IC0gYnN0YXJ0W2pdKSA6IEluZmluaXR5O1xuXHRcdGlmIChkeCA8IDAgfHwgZHggPiBzZWxmLmNmZy5tYXhTQmdhcCkge1xuXHRcdCAgICAvLyBDaGFuZ2VkIGNociBvciBqdW1wZWQgYSBsYXJnZSBnYXBcblx0XHQgICAgcHN0YXJ0W2pdID0gcGVuZCArIEdBUDtcblx0XHQgICAgYnN0YXJ0W2pdID0gYi5zdGFydDtcblx0XHQgICAgZ2QucHdpZHRoICs9IEdBUDtcblx0XHQgICAgZHggPSBwc3RhcnRbal07XG5cdFx0ICAgIGNjaHIgPSBiLmNocjtcblx0XHR9XG5cdCAgICB9XG5cdCAgICBwZW5kID0gZHggKyBibGVuO1xuXHQgICAgZDMuc2VsZWN0KHRoaXMpLmF0dHIoJ3RyYW5zZm9ybScsIGB0cmFuc2xhdGUoJHtkeH0sMClgKTtcblx0ICAgIC8vXG5cdCAgICBzZWxmLmxheW91dFNCRmVhdHVyZXMoYik7XG5cdH0pO1xuXHR0aGlzLnNxdWlzaCgpO1xuICAgIH1cblxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIC8vIFNjYWxlcyBlYWNoIHpvb20gc3RyaXAgaG9yaXpvbnRhbGx5IHRvIGZpdCB0aGUgd2lkdGguIE9ubHkgc2NhbGVzIGRvd24uXG4gICAgc3F1aXNoICgpIHtcbiAgICAgICAgbGV0IHNicyA9IGQzLnNlbGVjdEFsbCgnLnpvb21TdHJpcCBbbmFtZT1cInNCbG9ja3NcIl0nKTtcblx0bGV0IHNlbGYgPSB0aGlzO1xuXHRzYnMuZWFjaChmdW5jdGlvbiAoc2IsaSkge1xuXHQgICAgaWYgKHNiLmdlbm9tZS5wd2lkdGggPiBzZWxmLndpZHRoKSB7XG5cdCAgICAgICAgbGV0IHMgPSBzZWxmLndpZHRoIC8gc2IuZ2Vub21lLnB3aWR0aDtcblx0XHRzYi54U2NhbGUgPSBzO1xuXHRcdGxldCB0ID0gZDMuc2VsZWN0KHRoaXMpO1xuXHRcdHQuYXR0cigndHJhbnNmb3JtJywgKCk9PiBgdHJhbnNsYXRlKCR7LXNiLmRlbHRhQiAqIHNlbGYucHBifSwwKXNjYWxlKCR7c2IueFNjYWxlfSwxKWApO1xuXHQgICAgfVxuXHR9KTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gRHJhd3MgdGhlIHpvb20gdmlldyBwYW5lbCB3aXRoIHRoZSBnaXZlbiBkYXRhLlxuICAgIC8vXG4gICAgZHJhdyAoZGF0YSkge1xuXHQvL1xuXHR0aGlzLmRyYXdDb3VudCArPSAxO1xuXHQvL1xuXHRsZXQgc2VsZiA9IHRoaXM7XG4gICAgICAgIC8vIElzIFpvb21WaWV3IGN1cnJlbnRseSBjbG9zZWQ/XG5cdGxldCBjbG9zZWQgPSB0aGlzLnJvb3QuY2xhc3NlZCgnY2xvc2VkJyk7XG5cdC8vIFNob3cgcmVmIGdlbm9tZSBuYW1lXG5cdGQzLnNlbGVjdCgnI3pvb21WaWV3IC56b29tQ29vcmRzIGxhYmVsJylcblx0ICAgIC50ZXh0KHRoaXMuYXBwLnJHZW5vbWUubGFiZWwgKyAnIGNvb3JkcycpO1xuXHQvLyBTaG93IGxhbmRtYXJrIGxhYmVsLCBpZiBhcHBsaWNhYmxlXG5cdGxldCBsbXR4dCA9ICcnO1xuXHRpZiAodGhpcy5jbW9kZSA9PT0gJ2xhbmRtYXJrJykge1xuXHQgICAgbGV0IHJmID0gdGhpcy5hcHAubGNvb3Jkcy5sYW5kbWFya1JlZkZlYXQ7XG5cdCAgICBsZXQgZCA9IHRoaXMuYXBwLmxjb29yZHMuZGVsdGE7XG5cdCAgICBsZXQgZHR4dCA9IGQgPyBgICgke2QgPiAwID8gJysnIDogJyd9JHtwcmV0dHlQcmludEJhc2VzKGQpfSlgIDogJyc7XG5cdCAgICBsbXR4dCA9IGBBbGlnbmVkIG9uICR7cmYuc3ltYm9sIHx8IHJmLmlkfSR7ZHR4dH1gO1xuXHR9XG5cdC8vIGRpc3BsYXkgbGFuZG1hcmsgdGV4dFxuXHRkMy5zZWxlY3QoJyN6b29tVmlldyAuem9vbUNvb3JkcyBkaXZbbmFtZT1cImxtdHh0XCJdIHNwYW4nKVxuXHQgICAgLnRleHQobG10eHQpO1xuXHRkMy5zZWxlY3QoJyN6b29tVmlldyAuem9vbUNvb3JkcyBkaXZbbmFtZT1cImxtdHh0XCJdIGknKVxuXHQgICAgLnRleHQobG10eHQ/J2hpZ2hsaWdodF9vZmYnOicnKVxuXHQgICAgLnN0eWxlKCdmb250LXNpemUnLCcxMnB4Jylcblx0ICAgIC5zdHlsZSgnY29sb3InLCdyZWQnKVxuXHQgICAgLm9uKCdjbGljaycsICgpID0+IHtcblx0XHR0aGlzLmFwcC5zZXRDb250ZXh0KHRoaXMuYXBwLmNvb3Jkcyk7XG5cdCAgICB9KVxuXHQgICAgO1xuXHQvLyBkaXNhYmxlIHRoZSBSL0MgYnV0dG9uIGluIGxhbmRtYXJrIG1vZGVcblx0dGhpcy5yb290LnNlbGVjdEFsbCgnW25hbWU9XCJ6b29tY29udHJvbHNcIl0gW25hbWU9XCJ6b29tRG1vZGVcIl0gLmJ1dHRvbicpXG5cdCAgICAuYXR0cignZGlzYWJsZWQnLCB0aGlzLmNtb2RlID09PSAnbGFuZG1hcmsnIHx8IG51bGwpO1xuXHRcblx0Ly8gdGhlIHJlZmVyZW5jZSBnZW5vbWUgYmxvY2sgKGFsd2F5cyBqdXN0IDEgb2YgdGhlc2UpLlxuXHRsZXQgckRhdGEgPSBkYXRhLmZpbHRlcihkZCA9PiBkZC5nZW5vbWUgPT09IHRoaXMuYXBwLnJHZW5vbWUpWzBdO1xuXHRsZXQgckJsb2NrID0gckRhdGEuYmxvY2tzWzBdO1xuXG5cdC8vIHgtc2NhbGUgYW5kIHgtYXhpcyBiYXNlZCBvbiB0aGUgcmVmIGdlbm9tZS5cblx0dGhpcy54c2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKVxuXHQgICAgLmRvbWFpbihbckJsb2NrLnN0YXJ0LHJCbG9jay5lbmRdKVxuXHQgICAgLnJhbmdlKFswLHRoaXMud2lkdGhdKTtcblx0Ly9cblx0Ly8gcGl4ZWxzIHBlciBiYXNlXG5cdHRoaXMucHBiID0gdGhpcy53aWR0aCAvICh0aGlzLmFwcC5jb29yZHMuZW5kIC0gdGhpcy5hcHAuY29vcmRzLnN0YXJ0ICsgMSk7XG5cbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gZHJhdyB0aGUgY29vcmRpbmF0ZSBheGlzXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdHRoaXMuYXhpc0Z1bmMgPSBkMy5zdmcuYXhpcygpXG5cdCAgICAuc2NhbGUodGhpcy54c2NhbGUpXG5cdCAgICAub3JpZW50KCd0b3AnKVxuXHQgICAgLm91dGVyVGlja1NpemUoMilcblx0ICAgIC50aWNrcyg1KVxuXHQgICAgLnRpY2tTaXplKDUpXG5cdCAgICA7XG5cdHRoaXMuYXhpcy5jYWxsKHRoaXMuYXhpc0Z1bmMpO1xuXG4gICAgICAgIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cdC8vIHpvb20gc3RyaXBzIChvbmUgcGVyIGdlbm9tZSlcbiAgICAgICAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAgICAgbGV0IHpzdHJpcHMgPSB0aGlzLnN0cmlwc0dycFxuXHQgICAgICAgIC5zZWxlY3RBbGwoJ2cuem9vbVN0cmlwJylcblx0XHQuZGF0YShkYXRhLCBkID0+IGQuZ2Vub21lLm5hbWUpO1xuXHQvLyBDcmVhdGUgdGhlIGdyb3VwXG5cdGxldCBuZXd6cyA9IHpzdHJpcHMuZW50ZXIoKVxuXHQgICAgICAgIC5hcHBlbmQoJ2cnKVxuXHRcdC5hdHRyKCdjbGFzcycsJ3pvb21TdHJpcCcpXG5cdFx0LmF0dHIoJ25hbWUnLCBkID0+IGQuZ2Vub21lLm5hbWUpXG5cdFx0Lm9uKCdjbGljaycsIGZ1bmN0aW9uIChnKSB7XG5cdFx0ICAgIHNlbGYuaGlnaGxpZ2h0U3RyaXAoZy5nZW5vbWUsIHRoaXMpO1xuXHRcdH0pXG5cdFx0LmNhbGwodGhpcy5kcmFnZ2VyKVxuXHRcdDtcblx0Ly9cblx0Ly8gU3RyaXAgbGFiZWxcblx0bmV3enMuYXBwZW5kKCd0ZXh0Jylcblx0ICAgIC5hdHRyKCduYW1lJywgJ2dlbm9tZUxhYmVsJylcblx0ICAgIDtcblx0Ly8gU3RyaXAgdW5kZXJsYXlcblx0bmV3enMuYXBwZW5kKCdyZWN0Jylcblx0ICAgIC5hdHRyKCdjbGFzcycsJ3VuZGVybGF5Jylcblx0ICAgIC5zdHlsZSgnd2lkdGgnLCcxMDAlJylcblx0ICAgIC5zdHlsZSgnb3BhY2l0eScsMClcblx0ICAgIDtcblx0ICAgIFxuXHQvLyBHcm91cCBmb3Igc0Jsb2Nrc1xuXHRuZXd6cy5hcHBlbmQoJ2cnKVxuXHQgICAgLmF0dHIoJ25hbWUnLCAnc0Jsb2NrcycpO1xuXHQvLyBTdHJpcCBlbmQgY2FwXG5cdG5ld3pzLmFwcGVuZCgncmVjdCcpXG5cdCAgICAuYXR0cignY2xhc3MnLCAnbWF0ZXJpYWwtaWNvbnMgem9vbVN0cmlwRW5kQ2FwJylcblx0ICAgIDtcblx0Ly8gU3RyaXAgZHJhZy1oYW5kbGVcblx0bmV3enMuYXBwZW5kKCd0ZXh0Jylcblx0ICAgIC5hdHRyKCdjbGFzcycsICdtYXRlcmlhbC1pY29ucyB6b29tU3RyaXBIYW5kbGUnKVxuXHQgICAgLnRleHQoJ2RyYWdfaW5kaWNhdG9yJylcblx0ICAgIC5hcHBlbmQoJ3RpdGxlJylcblx0ICAgICAgICAudGV4dCgnRHJhZyB1cC9kb3duIHRvIHJlb3JkZXIgdGhlIGdlbm9tZXMuJylcblx0ICAgIDtcblx0Ly8gVXBkYXRlc1xuXHR6c3RyaXBzLnNlbGVjdCgnLnpvb21TdHJpcEVuZENhcCcpXG5cdCAgICAuYXR0cigneCcsIC0xNSlcblx0ICAgIC5hdHRyKCd3aWR0aCcsIDE1KVxuXHQgICAgLmF0dHIoJ3knLCBkID0+IC1kLnplcm9PZmZzZXQpXG5cdCAgICAuYXR0cignaGVpZ2h0JywgZCA9PiBkLnN0cmlwSGVpZ2h0ICsgMTApXG5cdCAgICA7XG5cdHpzdHJpcHMuc2VsZWN0KCd0ZXh0Lnpvb21TdHJpcEhhbmRsZScpXG5cdCAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxOHB4Jylcblx0ICAgIC5hdHRyKCd4JywgLTE1KVxuXHQgICAgLmF0dHIoJ3knLCBkID0+IGQuc3RyaXBIZWlnaHQgLyAyIC0gZC56ZXJvT2Zmc2V0ICsgMTApXG5cdCAgICA7XG5cdHpzdHJpcHMuc2VsZWN0KCdbbmFtZT1cImdlbm9tZUxhYmVsXCJdJylcblx0ICAgIC50ZXh0KGQgPT4gZC5nZW5vbWUubGFiZWwpXG5cdCAgICAuYXR0cigneCcsIDApXG5cdCAgICAuYXR0cigneScsIGQgPT4gZC5zdHJpcEhlaWdodCAtIGQuemVyb09mZnNldCArIDIwKVxuXHQgICAgLmF0dHIoJ2ZvbnQtZmFtaWx5Jywnc2Fucy1zZXJpZicpXG5cdCAgICAuYXR0cignZm9udC1zaXplJywgMTApXG5cdCAgICA7XG5cdHpzdHJpcHMuc2VsZWN0KCcudW5kZXJsYXknKVxuXHQgICAgLmF0dHIoJ3knLCBkID0+IC1kLnplcm9PZmZzZXQpXG5cdCAgICAuYXR0cignaGVpZ2h0JywgZCA9PiBkLnN0cmlwSGVpZ2h0KVxuXHQgICAgO1xuXHQgICAgXG5cdC8vIHRyYW5zbGF0ZSBzdHJpcHMgaW50byBwb3NpdGlvblxuXHRsZXQgb2Zmc2V0ID0gdGhpcy5jZmcudG9wT2Zmc2V0O1xuXHRsZXQgckhlaWdodCA9IDA7XG5cdHRoaXMuYXBwLnZHZW5vbWVzLmZvckVhY2goIHZnID0+IHtcblx0ICAgIGxldCBzID0gdGhpcy5zdHJpcHNHcnAuc2VsZWN0KGAuem9vbVN0cmlwW25hbWU9XCIke3ZnLm5hbWV9XCJdYCk7XG5cdCAgICBzLmNsYXNzZWQoJ3JlZmVyZW5jZScsIGQgPT4gZC5nZW5vbWUgPT09IHRoaXMuYXBwLnJHZW5vbWUpXG5cdCAgICAgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGQgPT4ge1xuXHRcdCAgICBpZiAoZC5nZW5vbWUgPT09IHRoaXMuYXBwLnJHZW5vbWUpXG5cdFx0ICAgICAgICBySGVpZ2h0ID0gZC5zdHJpcEhlaWdodCArIGQuemVyb09mZnNldCArIDEwO1xuXHRcdCAgICBsZXQgbyA9IG9mZnNldCArIGQuemVyb09mZnNldDtcblx0XHQgICAgZC56b29tWSA9IG9mZnNldDtcblx0XHQgICAgb2Zmc2V0ICs9IGQuc3RyaXBIZWlnaHQgKyB0aGlzLmNmZy5zdHJpcEdhcCArIDEwO1xuXHRcdCAgICByZXR1cm4gYHRyYW5zbGF0ZSgwLCR7Y2xvc2VkID8gdGhpcy5jZmcudG9wT2Zmc2V0K2QuemVyb09mZnNldCA6IG99KWBcblx0XHR9KTtcblx0fSk7XG5cdC8vIHJlc2V0IHRoZSBzdmcgc2l6ZSBiYXNlZCBvbiBzdHJpcCB3aWR0aHNcblx0dGhpcy5zdmcuYXR0cignaGVpZ2h0JywgKGNsb3NlZCA/IHJIZWlnaHQgOiBvZmZzZXQpICsgMjUpO1xuXG4gICAgICAgIHpzdHJpcHMuZXhpdCgpXG5cdCAgICAub24oJy5kcmFnJywgbnVsbClcblx0ICAgIC5yZW1vdmUoKTtcblx0Ly9cbiAgICAgICAgenN0cmlwcy5zZWxlY3QoJ2dbbmFtZT1cInNCbG9ja3NcIl0nKVxuXHQgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGcgPT4gYHRyYW5zbGF0ZSgke2cuZGVsdGFCICogdGhpcy5wcGJ9LDApYClcblx0ICAgIDtcblx0Ly8gLS0tLSBTeW50ZW55IHN1cGVyIGJsb2NrcyAtLS0tXG4gICAgICAgIGxldCBzYmxvY2tzID0genN0cmlwcy5zZWxlY3QoJ1tuYW1lPVwic0Jsb2Nrc1wiXScpLnNlbGVjdEFsbCgnZy5zQmxvY2snKVxuXHQgICAgLmRhdGEoZD0+ZC5ibG9ja3MsIGIgPT4gYi5ibG9ja0lkKTtcblx0bGV0IG5ld3NicyA9IHNibG9ja3MuZW50ZXIoKVxuXHQgICAgLmFwcGVuZCgnZycpXG5cdCAgICAuYXR0cignY2xhc3MnLCAnc0Jsb2NrJylcblx0ICAgIC5hdHRyKCduYW1lJywgYj0+Yi5pbmRleClcblx0ICAgIDtcblx0bGV0IGwwID0gbmV3c2JzLmFwcGVuZCgnZycpLmF0dHIoJ25hbWUnLCAnbGF5ZXIwJyk7XG5cdGxldCBsMSA9IG5ld3Nicy5hcHBlbmQoJ2cnKS5hdHRyKCduYW1lJywgJ2xheWVyMScpO1xuXG5cdC8vXG5cdHRoaXMubGF5b3V0U0Jsb2NrcyhzYmxvY2tzKTtcblxuXHQvLyByZWN0YW5nbGUgZm9yIGVhY2ggaW5kaXZpZHVhbCBzeW50ZW55IGJsb2NrXG5cdGxldCBzYnJlY3RzID0gc2Jsb2Nrcy5zZWxlY3QoJ2dbbmFtZT1cImxheWVyMFwiXScpLnNlbGVjdEFsbCgncmVjdC5ibG9jaycpLmRhdGEoZD0+IHtcblx0ICAgIGQuc2Jsb2Nrcy5mb3JFYWNoKGI9PmIueHNjYWxlID0gZC54c2NhbGUpO1xuXHQgICAgcmV0dXJuIGQuc2Jsb2Nrc1xuXHQgICAgfSwgc2I9PnNiLmluZGV4KTtcbiAgICAgICAgc2JyZWN0cy5lbnRlcigpLmFwcGVuZCgncmVjdCcpLmFwcGVuZCgndGl0bGUnKTtcblx0c2JyZWN0cy5leGl0KCkucmVtb3ZlKCk7XG5cdHNicmVjdHNcblx0ICAgLmF0dHIoJ2NsYXNzJywgYiA9PiAnYmxvY2sgJyArIFxuXHQgICAgICAgKGIub3JpPT09JysnID8gJ3BsdXMnIDogYi5vcmk9PT0nLScgPyAnbWludXMnOiAnY29uZnVzZWQnKSArIFxuXHQgICAgICAgKGIuY2hyICE9PSBiLmZDaHIgPyAnIHRyYW5zbG9jYXRpb24nIDogJycpKVxuXHQgICAuYXR0cigneCcsICAgICBiID0+IGIueHNjYWxlKGIuc3RhcnQpKVxuXHQgICAuYXR0cigneScsICAgICBmdW5jdGlvbihiKSB7XG5cdCAgICAgICBsZXQgYmIgPSB0aGlzLmNsb3Nlc3QoJy56b29tU3RyaXAnKS5fX2RhdGFfXztcblx0ICAgICAgIHJldHVybiAtYmIuemVyb09mZnNldDtcblx0ICAgfSlcblx0ICAgLmF0dHIoJ3dpZHRoJywgYiA9PiBNYXRoLm1heCg0LCBNYXRoLmFicyhiLnhzY2FsZShiLmVuZCktYi54c2NhbGUoYi5zdGFydCkpKSlcblx0ICAgLmF0dHIoJ2hlaWdodCcsIGZ1bmN0aW9uIChiKSB7XG5cdCAgICAgICBsZXQgYmIgPSB0aGlzLmNsb3Nlc3QoJy56b29tU3RyaXAnKS5fX2RhdGFfXztcblx0ICAgICAgIHJldHVybiBiYi5zdHJpcEhlaWdodDtcblx0ICAgfSk7XG5cdCAgIDtcblx0c2JyZWN0cy5zZWxlY3QoJ3RpdGxlJylcblx0ICAgLnRleHQoIGIgPT4ge1xuXHQgICAgICAgbGV0IGFkamVjdGl2ZXMgPSBbXTtcblx0ICAgICAgIGIub3JpID09PSAnLScgJiYgYWRqZWN0aXZlcy5wdXNoKCdpbnZlcnRlZCcpO1xuXHQgICAgICAgYi5jaHIgIT09IGIuZkNociAmJiBhZGplY3RpdmVzLnB1c2goJ3RyYW5zbG9jYXRlZCcpO1xuXHQgICAgICAgcmV0dXJuIGFkamVjdGl2ZXMubGVuZ3RoID8gYWRqZWN0aXZlcy5qb2luKCcsICcpICsgJyBibG9jaycgOiAnJztcblx0ICAgfSk7XG5cblx0Ly8gdGhlIGF4aXMgbGluZVxuXHRsMC5hcHBlbmQoJ2xpbmUnKS5hdHRyKCdjbGFzcycsJ2F4aXMnKTtcblx0Ly9cblx0c2Jsb2Nrcy5zZWxlY3QoJ2xpbmUuYXhpcycpXG5cdCAgICAuYXR0cigneDEnLCBiID0+IGIueHNjYWxlKGIuc3RhcnQpKVxuXHQgICAgLmF0dHIoJ3kxJywgMClcblx0ICAgIC5hdHRyKCd4MicsIGIgPT4gYi54c2NhbGUodGhpcy5zaG93RmVhdHVyZURldGFpbHMgJiYgdGhpcy5zcHJlYWRUcmFuc2NyaXB0cyA/IGIuc3RhcnQgOiBiLmVuZCkpXG5cdCAgICAuYXR0cigneTInLCAwKVxuXHQgICAgO1xuXHQvLyBzZXF1ZW5jZVxuXHRsMC5hcHBlbmQoJ3RleHQnKVxuXHQgICAgLmF0dHIoJ2NsYXNzJywnc2VxdWVuY2UnKVxuXHQgICAgLnN0eWxlKCdmb250LWZhbWlseScsJ21vbm9zcGFjZScpXG5cdCAgICA7XG5cdHNibG9ja3Muc2VsZWN0KCd0ZXh0LnNlcXVlbmNlJylcblx0ICAgIC5lYWNoKCBmdW5jdGlvbiAoYikge1xuXHRcdGxldCBibGVuID0gYi5lbmQgLSBiLnN0YXJ0ICsgMTtcblx0XHRpZiAoYmxlbiA8IDIqc2VsZi53aWR0aCkge1xuXHRcdCAgICBsZXQgYWRtID0gc2VsZi5hcHAucXVlcnlNYW5hZ2VyLmF1eERhdGFNYW5hZ2VyO1xuXHRcdCAgICBsZXQgcCA9IGFkbS5zZXF1ZW5jZVNsaWNlKGIuZ2Vub21lLmxhYmVsLCBiLmNociwgTWF0aC5mbG9vcihiLnN0YXJ0KSwgTWF0aC5mbG9vcihiLmVuZCkpO1xuXHRcdCAgICBwLnRoZW4ocyA9PiB7XG5cdFx0XHQvL2NvbnNvbGUubG9nKHMpO1xuXHRcdFx0bGV0IGJhc2VzID0gcy5zZXEuc3BsaXQoJycpO1xuXHRcdFx0ZDMuc2VsZWN0KHRoaXMpXG5cdFx0XHQgICAgLmh0bWwoYmFzZXMubWFwKGIgPT4gYDx0c3BhbiBjbGFzcz1cIiR7Yn1cIj4ke2JsZW4gPj0gc2VsZi53aWR0aCA/ICcuJyA6IGJ9PC90c3Bhbj5gKS5qb2luKCcnKSlcblx0XHRcdCAgICAuc3R5bGUoJ2ZvbnQtc2l6ZScsICcxMHB4Jylcblx0XHRcdCAgICA7XG5cdFx0XHRkMy5zZWxlY3QodGhpcylcblx0XHRcdCAgICAuYXR0cigndHJhbnNmb3JtJyxgc2NhbGUoJHtzZWxmLndpZHRoL3RoaXMuZ2V0QkJveCgpLndpZHRofSwxKWApXG5cdFx0ICAgIH0pO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0ICAgIGQzLnNlbGVjdCh0aGlzKS50ZXh0KCcnKTtcblx0ICAgIH0pXG5cdCAgICA7XG5cblx0Ly8gbGFiZWxcblx0bDAuYXBwZW5kKCd0ZXh0Jylcblx0ICAgIC5hdHRyKCdjbGFzcycsJ2Jsb2NrTGFiZWwnKSA7XG5cdC8vIGJydXNoXG5cdGwwLmFwcGVuZCgnZycpLmF0dHIoJ2NsYXNzJywnYnJ1c2gnKTtcblx0Ly9cblx0c2Jsb2Nrcy5leGl0KCkucmVtb3ZlKCk7XG5cblx0Ly8gc3ludGVueSBibG9jayBsYWJlbHNcblx0c2Jsb2Nrcy5zZWxlY3QoJ3RleHQuYmxvY2tMYWJlbCcpXG5cdCAgICAudGV4dCggYiA9PiBiLmNociApXG5cdCAgICAuYXR0cigneCcsIGIgPT4gKGIueHNjYWxlKGIuc3RhcnQpICsgYi54c2NhbGUoYi5lbmQpKS8yIClcblx0ICAgIC5hdHRyKCd5JywgZnVuY3Rpb24gKGIpIHtcblx0XHRsZXQgYmIgPSB0aGlzLmNsb3Nlc3QoJy56b29tU3RyaXAnKS5fX2RhdGFfXztcblx0ICAgICAgICByZXR1cm4gYmIuc3RyaXBIZWlnaHQgLSBiYi56ZXJvT2Zmc2V0ICsgMTBcblx0ICAgIH0pXG5cdCAgICA7XG5cblx0Ly8gYnJ1c2hcblx0c2Jsb2Nrcy5zZWxlY3QoJ2cuYnJ1c2gnKVxuXHQgICAgLmF0dHIoJ3RyYW5zZm9ybScsIGZ1bmN0aW9uKGIpIHtcblx0XHRsZXQgYmIgPSB0aGlzLmNsb3Nlc3QoJy56b29tU3RyaXAnKS5fX2RhdGFfXztcblx0XHRyZXR1cm4gYHRyYW5zbGF0ZSgwLCR7IGJiLnN0cmlwSGVpZ2h0IC0gYmIuemVyb09mZnNldCB9KWA7XG5cdCAgICB9KVxuXHQgICAgLm9uKCdtb3VzZW1vdmUnLCBmdW5jdGlvbihiKSB7XG5cdCAgICAgICAgbGV0IGNyID0gdGhpcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRsZXQgeCA9IGQzLmV2ZW50LmNsaWVudFggLSBjci54O1xuXHRcdGxldCBjID0gTWF0aC5yb3VuZChiLnhzY2FsZS5pbnZlcnQoeCkpO1xuXHRcdHNlbGYuc2hvd0Zsb2F0aW5nVGV4dChgJHtiLmNocn06JHtjfWAsIGQzLmV2ZW50LmNsaWVudFgsIGQzLmV2ZW50LmNsaWVudFkpO1xuXHQgICAgfSlcblx0ICAgIC5vbignbW91c2VvdXQnLCBiID0+IHRoaXMuaGlkZUZsb2F0aW5nVGV4dCgpKVxuXHQgICAgLmVhY2goZnVuY3Rpb24oYikge1xuXHRcdGlmICghYi5icnVzaCkge1xuXHRcdCAgICBiLmJydXNoID0gZDMuc3ZnLmJydXNoKClcblx0XHRcdC5vbignYnJ1c2hzdGFydCcsIGZ1bmN0aW9uKCl7IHNlbGYuYmJTdGFydCggYiwgdGhpcyApOyB9KVxuXHRcdFx0Lm9uKCdicnVzaCcsICAgICAgZnVuY3Rpb24oKXsgc2VsZi5iYkJydXNoKCBiLCB0aGlzICk7IH0pXG5cdFx0XHQub24oJ2JydXNoZW5kJywgICBmdW5jdGlvbigpeyBzZWxmLmJiRW5kKCBiLCB0aGlzICk7IH0pXG5cdFx0fVxuXHRcdGIuYnJ1c2gueChiLnhzY2FsZSkuY2xlYXIoKTtcblx0XHRkMy5zZWxlY3QodGhpcykuY2FsbChiLmJydXNoKTtcblx0ICAgIH0pXG5cdCAgICAuc2VsZWN0QWxsKCdyZWN0Jylcblx0XHQuYXR0cignaGVpZ2h0JywgMTApO1xuXG5cdHRoaXMuZHJhd0ZlYXR1cmVzKHNibG9ja3MpO1xuXG5cdC8vXG5cdHRoaXMuYXBwLmZhY2V0TWFuYWdlci5hcHBseUFsbCgpO1xuXG5cdC8vIFdlIG5lZWQgdG8gbGV0IHRoZSB2aWV3IHJlbmRlciBiZWZvcmUgZG9pbmcgdGhlIGhpZ2hsaWdodGluZywgc2luY2UgaXQgZGVwZW5kcyBvblxuXHQvLyB0aGUgcG9zaXRpb25zIG9mIHJlY3RhbmdsZXMgaW4gdGhlIHNjZW5lLlxuXHR3aW5kb3cuc2V0VGltZW91dCgoKSA9PiB7XG5cdCAgICB0aGlzLmhpZ2hsaWdodCgpO1xuXHQgICAgd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuXHRcdHRoaXMuaGlnaGxpZ2h0KCk7XG5cdCAgICB9LCAxNTApO1xuXHR9LCAxNTApO1xuICAgIH07XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEcmF3cyB0aGUgZmVhdHVyZXMgKHJlY3RhbmdsZXMpIGZvciB0aGUgc3BlY2lmaWVkIHN5bnRlbnkgYmxvY2tzLlxuICAgIC8vIEFyZ3M6XG4gICAgLy8gICAgIHNibG9ja3MgKEQzIHNlbGVjdGlvbiBvZiBnLnNibG9jayBub2RlcykgLSBtdWx0aWxldmVsIHNlbGVjdGlvbi5cbiAgICAvLyAgICAgICAgQXJyYXkgKGNvcnJlc3BvbmRpbmcgdG8gc3RyaXBzKSBvZiBhcnJheXMgb2Ygc3ludGVueSBibG9ja3MuXG4gICAgLy8gICAgIGRldGFpbGVkIChib29sZWFuKSBpZiB0cnVlLCBkcmF3cyBlYWNoIGZlYXR1cmUgaW4gZnVsbCBkZXRhaWwgKGllLFxuICAgIC8vICAgICAgICBzaG93IGV4b24gc3RydWN0dXJlIGlmIGF2YWlsYWJsZSkuIE90aGVyd2lzZSAodGhlIGRlZmF1bHQpLCBkcmF3XG4gICAgLy8gICAgICAgIGVhY2ggZmVhdHVyZSBhcyBqdXN0IGEgcmVjdGFuZ2xlLlxuICAgIC8vXG4gICAgZHJhd0ZlYXR1cmVzIChzYmxvY2tzKSB7XG5cdC8vIGJlZm9yZSBkb2luZyBhbnl0aGluZyBlbHNlLi4uXG5cdGlmICh0aGlzLmNsZWFyQWxsKSB7XG5cdCAgICAvLyBpZiB3ZSBhcmUgY2hhbmdpbmcgYmV0d2VlbiBkZXRhaWxlZCBhbmQgc2ltcGxlIGZlYXR1cmVzLCBoYXZlIHRvIGRlbGV0ZSBleGlzdGluZyByZW5kZXJlZCBmZWF0dXJlcyBmaXJzdFxuXHQgICAgLy8gYmVjYXVzZSB0aGUgc3RydWN0dXJlcyBhcmUgaW5jb21wYXRpYmxlLiBVZ2guIFxuXHQgICAgc2Jsb2Nrcy5zZWxlY3RBbGwoJy5mZWF0dXJlJykucmVtb3ZlKCk7XG5cdH1cblx0Ly8gb2ssIG5vdyB0aGF0J3MgdGFrZW4gY2FyZSBvZi4uLlxuICAgICAgICBsZXQgc2VsZiA9IHRoaXM7XG5cdC8vXG5cdC8vIG5ldmVyIGRyYXcgdGhlIHNhbWUgZmVhdHVyZSB0d2ljZSBpbiBvbmUgcmVuZGVyaW5nIHBhc3Ncblx0Ly8gQ2FuIGhhcHBlbiBpbiBjb21wbGV4IHNibG9ja3Mgd2hlcmUgdGhlIHJlbGF0aW9uc2hpcCBpbiBub3QgMToxXG5cdGxldCBkcmF3biA9IG5ldyBTZXQoKTtcdC8vIHNldCBvZiBJRHMgb2YgZHJhd24gZmVhdHVyZXNcblx0bGV0IGZpbHRlckRyYXduID0gZnVuY3Rpb24gKGYpIHtcblx0ICAgIC8vIHJldHVybnMgdHJ1ZSBpZiB3ZSd2ZSBub3Qgc2VlbiB0aGlzIG9uZSBiZWZvcmUuXG5cdCAgICAvLyByZWdpc3RlcnMgdGhhdCB3ZSd2ZSBzZWVuIGl0LlxuXHQgICAgbGV0IGZpZCA9IGYuSUQ7XG5cdCAgICBsZXQgdiA9ICEgZHJhd24uaGFzKGZpZCk7XG5cdCAgICBkcmF3bi5hZGQoZmlkKTtcblx0ICAgIHJldHVybiB2O1xuXHR9O1xuXHQvL1xuXHRsZXQgZmVhdHMgPSBzYmxvY2tzLnNlbGVjdCgnW25hbWU9XCJsYXllcjFcIl0nKS5zZWxlY3RBbGwoJy5mZWF0dXJlJylcblx0ICAgIC5kYXRhKGQ9PmQuZmVhdHVyZXMuZmlsdGVyKGZpbHRlckRyYXduKSwgZD0+ZC5JRCk7XG5cdGZlYXRzLmV4aXQoKS5yZW1vdmUoKTtcblx0Ly9cblx0bGV0IG5ld0ZlYXRzO1xuXHRpZiAodGhpcy5zaG93RmVhdHVyZURldGFpbHMpIHtcblx0ICAgIC8vIGRyYXcgZGV0YWlsZWQgZmVhdHVyZXNcblx0ICAgIG5ld0ZlYXRzID0gZmVhdHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuXHRcdC5hdHRyKCdjbGFzcycsIGYgPT4gJ2ZlYXR1cmUgZGV0YWlsZWQgJyArIChmLnN0cmFuZD09PSctJyA/ICcgbWludXMnIDogJyBwbHVzJykpXG5cdFx0LmF0dHIoJ25hbWUnLCBmID0+IGYuSUQpXG5cdFx0O1xuXHQgICAgbmV3RmVhdHMuYXBwZW5kKCdyZWN0Jylcblx0XHQuc3R5bGUoJ2ZpbGwnLCBmID0+IHNlbGYuYXBwLmNzY2FsZShmLmdldE11bmdlZFR5cGUoKSkpXG5cdFx0O1xuXHQgICAgbmV3RmVhdHMuYXBwZW5kKCdnJylcblx0ICAgICAgICAuYXR0cignY2xhc3MnLCd0cmFuc2NyaXB0cycpXG5cdFx0LmF0dHIoJ3RyYW5zZm9ybScsJ3RyYW5zbGF0ZSgwLDApJylcblx0XHQ7XG5cdCAgICBuZXdGZWF0cy5hcHBlbmQoJ3RleHQnKVxuXHQgICAgICAgIC5hdHRyKCdjbGFzcycsJ2xhYmVsJylcblx0XHQ7XG5cdH1cblx0ZWxzZSB7XG5cdCAgICAvLyBzaW1wbGUgc3R5bGU6IGRyYXcgZmVhdHVyZXMgYXMganVzdCBhIHJlY3RhbmdsZVxuXHQgICAgbmV3RmVhdHMgPSBmZWF0cy5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0LmF0dHIoJ2NsYXNzJywgZiA9PiAnZmVhdHVyZScgKyAoZi5zdHJhbmQ9PT0nLScgPyAnIG1pbnVzJyA6ICcgcGx1cycpKVxuXHRcdC5hdHRyKCduYW1lJywgZiA9PiBmLklEKVxuXHRcdC5zdHlsZSgnZmlsbCcsIGYgPT4gc2VsZi5hcHAuY3NjYWxlKGYuZ2V0TXVuZ2VkVHlwZSgpKSlcblx0XHQ7XG5cdH1cblx0Ly8gTkI6IGlmIHlvdSBhcmUgbG9va2luZyBmb3IgY2xpY2sgaGFuZGxlcnMsIHRoZXkgYXJlIGF0IHRoZSBzdmcgbGV2ZWwgKHNlZSBpbml0RG9tIGFib3ZlKS5cblxuXHQvLyBTZXQgcG9zaXRpb24gYW5kIHNpemUgYXR0cmlidXRlcyBvZiB0aGUgb3ZlcmFsbCBmZWF0dXJlIHJlY3QuXG5cdCh0aGlzLnNob3dGZWF0dXJlRGV0YWlscyA/IGZlYXRzLnNlbGVjdCgncmVjdCcpIDogZmVhdHMpXG5cdCAgLmF0dHIoJ3gnLCBmID0+IGYueClcblx0ICAuYXR0cigneScsIDApXG5cdCAgLmF0dHIoJ3dpZHRoJywgZiA9PiBmLndpZHRoKVxuXHQgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmNmZy5mZWF0SGVpZ2h0KVxuXHQgIDtcblx0Ly9cbiAgICAgICAgZmVhdHMuYXR0cigndHJhbnNmb3JtJywgZiA9PiB7XG5cdCAgICBpZiAoaXNOYU4oZi55KSkgXG5cdCAgICAgICAgY29uc29sZS5sb2coJ1doYXQ/JywgZik7XG5cdCAgICByZXR1cm4gYHRyYW5zbGF0ZSgwLCR7Zi55fSlgXG5cdH0pXG5cblx0Ly8gZHJhdyBkZXRhaWxlZCBmZWF0dXJlXG5cdGlmICh0aGlzLnNob3dGZWF0dXJlRGV0YWlscykge1xuXHQgICAgLy9cblx0ICAgIC8vIGZlYXR1cmUgbGFiZWxzXG5cdCAgICBmZWF0cy5zZWxlY3QoJ3RleHQubGFiZWwnKVxuXHQgICAgICAgIC5hdHRyKCd4JywgZiA9PiBmLnggKyBmLndpZHRoIC8gMilcblx0XHQuYXR0cigneScsIGYgPT4gLTEpXG5cdFx0LnN0eWxlKCdmb250LXNpemUnLCB0aGlzLmxhbmVHYXApXG5cdFx0LnN0eWxlKCd0ZXh0LWFuY2hvcicsICdtaWRkbGUnKVxuXHRcdC50ZXh0KGYgPT4gdGhpcy5zaG93QWxsTGFiZWxzID8gKGYuc3ltYm9sIHx8IGYuSUQpIDogJycpXG5cdFx0O1xuXHQgICAgLy8gZHJhdyB0cmFuc2NyaXB0c1xuXHQgICAgbGV0IHRncnBzID0gZmVhdHMuc2VsZWN0KCdnLnRyYW5zY3JpcHRzJyk7XG5cdCAgICBsZXQgdHJhbnNjcmlwdHMgPSB0Z3Jwcy5zZWxlY3RBbGwoJy50cmFuc2NyaXB0Jylcblx0ICAgICAgICAuZGF0YSggZiA9PiBmLnRyYW5zY3JpcHRzLCB0ID0+IHQuSUQgKVxuXHRcdDtcblx0ICAgIGxldCBuZXd0cyA9IHRyYW5zY3JpcHRzLmVudGVyKCkuYXBwZW5kKCdnJylcblx0ICAgICAgICAuYXR0cignY2xhc3MnLCd0cmFuc2NyaXB0Jylcblx0XHQ7XG5cdCAgICBuZXd0cy5hcHBlbmQoJ3BvbHlsaW5lJyk7XG5cdCAgICBuZXd0cy5hcHBlbmQoJ2cnKS5hdHRyKCdjbGFzcycsJ2V4b25zJyk7XG5cdCAgICBuZXd0cy5hcHBlbmQoJ3JlY3QnKS5hdHRyKCdjbGFzcycsJ292ZXJsYXknKTtcblxuXHQgICAgdHJhbnNjcmlwdHMuZXhpdCgpLnJlbW92ZSgpO1xuXHQgICAgLy8gZHJhdyB0cmFuc2NyaXB0IGF4aXMgbGluZXNcblx0ICAgIHRyYW5zY3JpcHRzLnNlbGVjdCgncG9seWxpbmUnKVxuXHQgICAgICAgIC8vLmF0dHIoJ3gxJywgdCA9PiB0LngpXG5cdFx0Ly8uYXR0cigneTEnLCAwKVxuXHRcdC8vLmF0dHIoJ3gyJywgdCA9PiB0LnggKyB0LndpZHRoIC0gMSlcblx0XHQvLy5hdHRyKCd5MicsIDApXG5cdFx0LmF0dHIoJ3BvaW50cycsIHQgPT4ge1xuXHRcdCAgICBsZXQgZXh0ID0gMTA7XG5cdFx0ICAgIGxldCBoICAgPSAzO1xuXHRcdCAgICBsZXQgeDEsIHgyLCB5O1xuXHRcdCAgICBpZiAodC5zdHJhbmQgPT09ICcrJykge1xuXHRcdCAgICAgICAgeDEgPSB0Lng7XG5cdFx0XHR4MiA9IHQueCArIHQud2lkdGggKyBleHQ7XG5cdFx0XHRyZXR1cm4gYCR7eDF9IDAgJHt4Mn0gMCAke3gyIC0gZXh0LzJ9ICR7LWh9ICR7eDJ9IDAgJHt4MiAtIGV4dC8yfSAke2h9YDtcblx0XHQgICAgfVxuXHRcdCAgICBlbHNlIHtcblx0XHRcdHgxID0gdC54ICsgdC53aWR0aDtcblx0XHQgICAgICAgIHgyID0gdC54IC0gZXh0O1xuXHRcdFx0cmV0dXJuIGAke3gxfSAwICR7eDJ9IDAgJHt4MiArIGV4dC8yfSAkey1ofSAke3gyfSAwICR7eDIgKyBleHQvMn0gJHtofWA7XG5cdFx0ICAgIH1cblx0XHR9KVxuXHRcdC5hdHRyKCd0cmFuc2Zvcm0nLGB0cmFuc2xhdGUoMCwke3RoaXMuY2ZnLmZlYXRIZWlnaHQvMn0pYClcblx0XHQuYXR0cignc3Ryb2tlJywgdCA9PiB0aGlzLmFwcC5jc2NhbGUodC5mZWF0dXJlLmdldE11bmdlZFR5cGUoKSkpXG5cdFx0LnN0eWxlKCdmaWxsJywnbm9uZScpXG5cdFx0O1xuXHQgICAgLy8gZHJhdyB0aGUgdHJhbnNjcmlwdCByZWN0YW5nbGVcblx0ICAgIHRyYW5zY3JpcHRzLnNlbGVjdCgncmVjdC5vdmVybGF5Jylcblx0XHQuYXR0cigneCcsIHQgPT4gdC54KVxuXHRcdC5hdHRyKCd5JywgMClcblx0XHQuYXR0cignd2lkdGgnLCB0ID0+IHQud2lkdGgpXG5cdFx0LmF0dHIoJ2hlaWdodCcsIHRoaXMuY2ZnLmZlYXRIZWlnaHQpXG5cdFx0LnN0eWxlKCdmaWxsJywgdCA9PiB0aGlzLmFwcC5jc2NhbGUodC5mZWF0dXJlLmdldE11bmdlZFR5cGUoKSkpXG5cdFx0LnN0eWxlKCdmaWxsLW9wYWNpdHknLCAwKVxuXHRcdC5vbignbW91c2VlbnRlcicsIGZ1bmN0aW9uKCl7IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnZmlsbC1vcGFjaXR5JywgMC4yMCkgfSlcblx0XHQub24oJ21vdXNlbGVhdmUnLCBmdW5jdGlvbigpeyBkMy5zZWxlY3QodGhpcykuc3R5bGUoJ2ZpbGwtb3BhY2l0eScsIDApIH0pXG5cdFx0LmFwcGVuZCgndGl0bGUnKVxuXHRcdCAgICAudGV4dCh0ID0+ICd0cmFuc2NyaXB0OiAnK3QuSUQpXG5cdFx0O1xuXG5cdCAgICBsZXQgZWdycHMgPSB0cmFuc2NyaXB0cy5zZWxlY3QoJ2cuZXhvbnMnKTtcblx0ICAgIGxldCBleG9ucyA9IGVncnBzLnNlbGVjdEFsbCgnLmV4b24nKVxuXHRcdC5kYXRhKGYgPT4gZi5leG9ucyB8fCBbXSlcblx0XHQ7XG5cdCAgICBleG9ucy5lbnRlcigpLmFwcGVuZCgncmVjdCcpXG5cdFx0LmF0dHIoJ2NsYXNzJywnZXhvbicpXG5cdFx0LnN0eWxlKCdmaWxsJywgZSA9PiB0aGlzLmFwcC5jc2NhbGUoZS5mZWF0dXJlLmdldE11bmdlZFR5cGUoKSkpXG5cdFx0ICAgIDtcblx0ICAgIGV4b25zLmV4aXQoKS5yZW1vdmUoKTtcblx0ICAgIGV4b25zLmF0dHIoJ25hbWUnLCBlID0+IGUucHJpbWFyeUlkZW50aWZpZXIpXG5cdCAgICAgICAgLmF0dHIoJ3gnLCBlID0+IGUueClcblx0ICAgICAgICAuYXR0cigneScsIDApXG5cdCAgICAgICAgLmF0dHIoJ3dpZHRoJywgZSA9PiBlLndpZHRoKVxuXHQgICAgICAgIC5hdHRyKCdoZWlnaHQnLCB0aGlzLmNmZy5mZWF0SGVpZ2h0KVxuXHRcdDtcbiAgICAgICAgICAgIC8vIHRyYW5zbGF0ZSBlYWNoIHRyYW5zY3JpcHQgaW50byBwb3NpdGlvblxuICAgICAgICAgICAgbGV0IHhwcyA9IHRoaXMuc3ZnTWFpbi5zZWxlY3RBbGwoJy5mZWF0dXJlIC50cmFuc2NyaXB0cycpLnNlbGVjdEFsbCgnLnRyYW5zY3JpcHQnKTtcbiAgICAgICAgICAgIHhwcy5hdHRyKCd0cmFuc2Zvcm0nLCAoeHAsaSkgPT4gYHRyYW5zbGF0ZSgwLCR7IHRoaXMuc3ByZWFkVHJhbnNjcmlwdHMgPyAoaSAqIHRoaXMuY2ZnLmxhbmVIZWlnaHRNaW5vcikgOiAwfSlgKTtcbiAgICAgICAgICAgIC8vIHNldCBmZWF0dXJlIHJlY3RhbmdsZSBoZWlnaHRcbiAgICAgICAgICAgIGxldCBmcnMgPSB0aGlzLnN2Z01haW4uc2VsZWN0QWxsKCcuZmVhdHVyZSA+IHJlY3QnKVxuXHRcdC5hdHRyKCdoZWlnaHQnLCAoZixpKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBuTGFuZXMgPSBNYXRoLm1heCgxLCB0aGlzLnNwcmVhZFRyYW5zY3JpcHRzID8gZi50cmFuc2NyaXB0cy5sZW5ndGggOiAxKTtcblx0XHQgICAgbGV0IGggPSBuTGFuZXMgKiB0aGlzLmNmZy5mZWF0SGVpZ2h0ICsgKG5MYW5lcyAtIDEpICogdGhpcy5jZmcubGFuZUdhcE1pbm9yO1xuXHRcdCAgICBmLmggPSBoO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaDtcbiAgICAgICAgICAgICAgICB9KVxuXHRcdC8vLmF0dHIoJ3RyYW5zZm9ybScsIGYgPT4gYHRyYW5zbGF0ZSgwLCR7LShmLmgtdGhpcy5jZmcubGFuZUhlaWdodE1pbm9yKX0pYClcblxuICAgICAgICAgICAgICAgIDtcblxuXHR9XG4gICAgfVxuXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8gVXBkYXRlcyBmZWF0dXJlIGhpZ2hsaWdodGluZyBpbiB0aGUgY3VycmVudCB6b29tIHZpZXcuXG4gICAgLy8gRmVhdHVyZXMgdG8gYmUgaGlnaGxpZ2h0ZWQgaW5jbHVkZSB0aG9zZSBpbiB0aGUgaGlGZWF0cyBsaXN0IHBsdXMgdGhlIGZlYXR1cmVcbiAgICAvLyBjb3JyZXNwb25kaW5nIHRvIHRoZSByZWN0YW5nbGUgYXJndW1lbnQsIGlmIGdpdmVuLiAoVGhlIG1vdXNlb3ZlciBmZWF0dXJlLilcbiAgICAvL1xuICAgIC8vIERyYXdzIGZpZHVjaWFscyBmb3IgZmVhdHVyZXMgaW4gdGhpcyBsaXN0IHRoYXQ6XG4gICAgLy8gMS4gb3ZlcmxhcCB0aGUgY3VycmVudCB6b29tVmlldyBjb29yZCByYW5nZVxuICAgIC8vIDIuIGFyZSBub3QgcmVuZGVyZWQgaW52aXNpYmxlIGJ5IGN1cnJlbnQgZmFjZXQgc2V0dGluZ3NcbiAgICAvL1xuICAgIC8vIEFyZ3M6XG4gICAgLy8gICAgY3VycmVudCAocmVjdCBlbGVtZW50KSBPcHRpb25hbC4gQWRkJ2wgcmVjdGFuZ2xlIGVsZW1lbnQsIGUuZy4sIHRoYXQgd2FzIG1vdXNlZC1vdmVyLiBIaWdobGlnaHRpbmdcbiAgICAvLyAgICAgICAgd2lsbCBpbmNsdWRlIHRoZSBmZWF0dXJlIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyByZWN0IGFsb25nIHdpdGggdGhvc2UgaW4gdGhlIGhpZ2hsaWdodCBsaXN0LlxuICAgIC8vICAgIHB1bHNlQ3VycmVudCAoYm9vbGVhbikgSWYgdHJ1ZSBhbmQgY3VycmVudCBpcyBnaXZlbiwgY2F1c2UgaXQgdG8gcHVsc2UgYnJpZWZseS5cbiAgICAvL1xuICAgIGhpZ2hsaWdodCAoY3VycmVudCwgcHVsc2VDdXJyZW50KSB7XG5cdGxldCBzZWxmID0gdGhpcztcblx0Ly8gY3VycmVudCBmZWF0dXJlXG5cdGxldCBjdXJyRmVhdCA9IGN1cnJlbnQgPyAoY3VycmVudCBpbnN0YW5jZW9mIEZlYXR1cmUgPyBjdXJyZW50IDogY3VycmVudC5fX2RhdGFfXykgOiBudWxsO1xuXHQvLyBjcmVhdGUgbG9jYWwgY29weSBvZiBoaUZlYXRzLCB3aXRoIGN1cnJlbnQgZmVhdHVyZSBhZGRlZFxuXHRsZXQgaGlGZWF0cyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuaGlGZWF0cywgdGhpcy5hcHAuY3Vyckxpc3RJbmRleCB8fHt9KTtcblx0aWYgKGN1cnJGZWF0KSB7XG5cdCAgICBoaUZlYXRzW2N1cnJGZWF0LmlkXSA9IGN1cnJGZWF0LmlkO1xuXHR9XG5cblx0Ly8gRmlsdGVyIGFsbCBmZWF0dXJlcyAocmVjdGFuZ2xlcykgaW4gdGhlIHNjZW5lIGZvciB0aG9zZSBiZWluZyBoaWdobGlnaHRlZC5cblx0Ly8gQWxvbmcgdGhlIHdheSwgYnVpbGQgaW5kZXggbWFwcGluZyBmZWF0dXJlIGlkIHRvIGl0cyAnc3RhY2snIG9mIGVxdWl2YWxlbnQgZmVhdHVyZXMsXG5cdC8vIGkuZS4gYSBsaXN0IG9mIGl0cyBnZW5vbG9ncyBzb3J0ZWQgYnkgeSBjb29yZGluYXRlLlxuXHQvL1xuXHR0aGlzLnN0YWNrcyA9IHt9OyAvLyBmaWQgLT4gWyByZWN0cyBdIFxuXHRsZXQgZGggPSB0aGlzLmNmZy5ibG9ja0hlaWdodC8yIC0gdGhpcy5jZmcuZmVhdEhlaWdodDtcbiAgICAgICAgbGV0IGZlYXRzID0gdGhpcy5zdmdNYWluLnNlbGVjdEFsbCgnLmZlYXR1cmUnKVxuXHQgIC8vIGZpbHRlciByZWN0LmZlYXR1cmVzIGZvciB0aG9zZSBpbiB0aGUgaGlnaGxpZ2h0IGxpc3Rcblx0ICAuZmlsdGVyKGZ1bmN0aW9uKGZmKXtcblx0ICAgICAgLy8gaGlnaGxpZ2h0IGZmIGlmIGVpdGhlciBpZCBpcyBpbiB0aGUgbGlzdCBBTkQgaXQncyBub3QgYmVlbiBoaWRkZW5cblx0ICAgICAgbGV0IG1naSA9IGhpRmVhdHNbZmYuY2Fub25pY2FsXTtcblx0ICAgICAgbGV0IG1ncCA9IGhpRmVhdHNbZmYuSURdO1xuXHQgICAgICBsZXQgc2hvd2luZyA9IGQzLnNlbGVjdCh0aGlzKS5zdHlsZSgnZGlzcGxheScpICE9PSAnbm9uZSc7XG5cdCAgICAgIGxldCBobCA9IHNob3dpbmcgJiYgKG1naSB8fCBtZ3ApO1xuXHQgICAgICBpZiAoaGwpIHtcblx0XHQgIC8vIGZvciBlYWNoIGhpZ2hsaWdodGVkIGZlYXR1cmUsIGFkZCBpdHMgcmVjdGFuZ2xlIHRvIHRoZSBsaXN0XG5cdFx0ICBsZXQgayA9IGZmLmlkO1xuXHRcdCAgaWYgKCFzZWxmLnN0YWNrc1trXSkgc2VsZi5zdGFja3Nba10gPSBbXVxuXHRcdCAgLy8gaWYgc2hvd2luZyBmZWF0dXJlIGRldGFpbHMsIC5mZWF0dXJlIGlzIGEgZ3JvdXAgd2l0aCB0aGUgcmVjdCBhcyB0aGUgMXN0IGNoaWxkLlxuXHRcdCAgLy8gb3RoZXJ3aXNlLCAuZmVhdHVyZSBpcyB0aGUgcmVjdCBpdHNlbGYuXG5cdFx0ICBzZWxmLnN0YWNrc1trXS5wdXNoKHRoaXMudGFnTmFtZSA9PT0gJ2cnID8gdGhpcy5jaGlsZE5vZGVzWzBdIDogdGhpcylcblx0ICAgICAgfVxuXHQgICAgICAvLyBcblx0ICAgICAgZDMuc2VsZWN0KHRoaXMpXG5cdFx0ICAuY2xhc3NlZCgnaGlnaGxpZ2h0JywgaGwpXG5cdFx0ICAuY2xhc3NlZCgnY3VycmVudCcsIGhsICYmIGN1cnJGZWF0ICYmIHRoaXMuX19kYXRhX18uaWQgPT09IGN1cnJGZWF0LmlkKVxuXHRcdCAgLmNsYXNzZWQoJ2V4dHJhJywgcHVsc2VDdXJyZW50ICYmIGZmID09PSBjdXJyRmVhdClcblx0ICAgICAgcmV0dXJuIGhsO1xuXHQgIH0pXG5cdCAgO1xuXG5cdHRoaXMuZHJhd0ZpZHVjaWFscyhjdXJyRmVhdCk7XG5cbiAgICB9XG5cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICAvLyBEcmF3cyBwb2x5Z29ucyB0aGF0IGNvbm5lY3QgaGlnaGxpZ2h0ZWQgZmVhdHVyZXMgaW4gdGhlIHZpZXdcbiAgICAvL1xuICAgIGRyYXdGaWR1Y2lhbHMgKGN1cnJGZWF0KSB7XG5cdC8vIGJ1aWxkIGRhdGEgYXJyYXkgZm9yIGRyYXdpbmcgZmlkdWNpYWxzIGJldHdlZW4gZXF1aXZhbGVudCBmZWF0dXJlc1xuXHRsZXQgZGF0YSA9IFtdO1xuXHRmb3IgKGxldCBrIGluIHRoaXMuc3RhY2tzKSB7XG5cdCAgICAvLyBmb3IgZWFjaCBoaWdobGlnaHRlZCBmZWF0dXJlLCBzb3J0IHRoZSByZWN0YW5nbGVzIGluIGl0cyBsaXN0IGJ5IFktY29vcmRpbmF0ZVxuXHQgICAgbGV0IHJlY3RzID0gdGhpcy5zdGFja3Nba107XG5cdCAgICByZWN0cy5zb3J0KCAoYSxiKSA9PiBwYXJzZUZsb2F0KGEuZ2V0QXR0cmlidXRlKCd5JykpIC0gcGFyc2VGbG9hdChiLmdldEF0dHJpYnV0ZSgneScpKSApO1xuXHQgICAgcmVjdHMuc29ydCggKGEsYikgPT4ge1xuXHRcdHJldHVybiBhLl9fZGF0YV9fLmdlbm9tZS56b29tWSAtIGIuX19kYXRhX18uZ2Vub21lLnpvb21ZO1xuXHQgICAgfSk7XG5cdCAgICAvLyBXYW50IGEgcG9seWdvbiBiZXR3ZWVuIGVhY2ggc3VjY2Vzc2l2ZSBwYWlyIG9mIGl0ZW1zLiBUaGUgZm9sbG93aW5nIGNyZWF0ZXMgYSBsaXN0IG9mXG5cdCAgICAvLyBuIHBhaXJzLCB3aGVyZSByZWN0W2ldIGlzIHBhaXJlZCB3aXRoIHJlY3RbaSsxXS4gVGhlIGxhc3QgcGFpciBjb25zaXN0cyBvZiB0aGUgbGFzdFxuXHQgICAgLy8gcmVjdGFuZ2xlIHBhaXJlZCB3aXRoIHVuZGVmaW5lZC4gKFdlIHdhbnQgdGhpcy4pXG5cdCAgICBsZXQgcGFpcnMgPSByZWN0cy5tYXAoKHIsIGkpID0+IFtyLHJlY3RzW2krMV1dKTtcblx0ICAgIC8vIEFkZCBhIGNsYXNzICgnY3VycmVudCcpIGZvciB0aGUgcG9seWdvbnMgYXNzb2NpYXRlZCB3aXRoIHRoZSBtb3VzZW92ZXIgZmVhdHVyZSBzbyB0aGV5XG5cdCAgICAvLyBjYW4gYmUgZGlzdGluZ3Vpc2hlZCBmcm9tIG90aGVycy5cblx0ICAgIGRhdGEucHVzaCh7IGZpZDogaywgcmVjdHM6IHBhaXJzLCBjbHM6IChjdXJyRmVhdCAmJiBjdXJyRmVhdC5pZCA9PT0gayA/ICdjdXJyZW50JyA6ICcnKSB9KTtcblx0fVxuXG5cdGxldCBzZWxmID0gdGhpcztcblx0Ly9cblx0Ly8gcHV0IGZpZHVjaWFsIG1hcmtzIGluIHRoZWlyIG93biBncm91cCBcblx0bGV0IGZHcnAgPSB0aGlzLmZpZHVjaWFscy5jbGFzc2VkKCdoaWRkZW4nLCBmYWxzZSk7XG5cblx0Ly8gQmluZCBmaXJzdCBsZXZlbCBkYXRhIHRvICdmZWF0dXJlTWFya3MnIGdyb3Vwc1xuXHRsZXQgZmZHcnBzID0gZkdycC5zZWxlY3RBbGwoJ2cuZmVhdHVyZU1hcmtzJylcblx0ICAgIC5kYXRhKGRhdGEsIGQgPT4gZC5maWQpO1xuXHRmZkdycHMuZW50ZXIoKS5hcHBlbmQoJ2cnKVxuXHQgICAgLmF0dHIoJ25hbWUnLCBkID0+IGQuZmlkKTtcblx0ZmZHcnBzLmV4aXQoKS5yZW1vdmUoKTtcblx0Ly9cblx0ZmZHcnBzLmF0dHIoJ2NsYXNzJywgZCA9PiB7XG4gICAgICAgICAgICBsZXQgY2xhc3NlcyA9IFsnZmVhdHVyZU1hcmtzJ107XG5cdCAgICBkLmNscyAmJiBjbGFzc2VzLnB1c2goZC5jbHMpO1xuXHQgICAgdGhpcy5hcHAuY3Vyckxpc3RJbmRleFtkLmZpZF0gJiYgY2xhc3Nlcy5wdXNoKCdsaXN0SXRlbScpXG5cdCAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XG5cdH0pO1xuXG5cdC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cblx0Ly8gRHJhdyB0aGUgY29ubmVjdG9yIHBvbHlnb25zLlxuXHQvLyBCaW5kIHNlY29uZCBsZXZlbCBkYXRhIChyZWN0YW5nbGUgcGFpcnMpIHRvIHBvbHlnb25zIGluIHRoZSBncm91cFxuXHRsZXQgcGdvbnMgPSBmZkdycHMuc2VsZWN0QWxsKCdwb2x5Z29uJylcblx0ICAgIC5kYXRhKGQ9PmQucmVjdHMuZmlsdGVyKHIgPT4gclswXSAmJiByWzFdKSk7XG5cdHBnb25zLmVudGVyKCkuYXBwZW5kKCdwb2x5Z29uJylcblx0ICAgIC5hdHRyKCdjbGFzcycsJ2ZpZHVjaWFsJylcblx0ICAgIDtcblx0Ly9cblx0cGdvbnMuYXR0cigncG9pbnRzJywgciA9PiB7XG5cdCAgICB0cnkge1xuXHQgICAgLy8gcG9seWdvbiBjb25uZWN0cyBib3R0b20gY29ybmVycyBvZiAxc3QgcmVjdCB0byB0b3AgY29ybmVycyBvZiAybmQgcmVjdFxuXHQgICAgbGV0IGMxID0gY29vcmRzQWZ0ZXJUcmFuc2Zvcm0oclswXSk7IC8vIHRyYW5zZm9ybSBjb29yZHMgZm9yIDFzdCByZWN0XG5cdCAgICBsZXQgYzIgPSBjb29yZHNBZnRlclRyYW5zZm9ybShyWzFdKTsgIC8vIHRyYW5zZm9ybSBjb29yZHMgZm9yIDJuZCByZWN0XG5cdCAgICByLnRjb29yZHMgPSBbYzEsYzJdO1xuXHQgICAgLy8gZm91ciBwb2x5Z29uIHBvaW50c1xuXHQgICAgbGV0IHMgPSBgJHtjMS54fSwke2MxLnkrYzEuaGVpZ2h0fSAke2MyLnh9LCR7YzIueX0gJHtjMi54K2MyLndpZHRofSwke2MyLnl9ICR7YzEueCtjMS53aWR0aH0sJHtjMS55K2MxLmhlaWdodH1gXG5cdCAgICByZXR1cm4gcztcblx0ICAgIH1cblx0ICAgIGNhdGNoIChlKSB7XG5cdCAgICAgICAgY29uc29sZS5sb2coXCJDYXVnaHQgZXJyb3I6XCIsIGUpO1xuXHRcdHJldHVybiAnJztcblx0ICAgIH1cblx0fSlcblx0Ly8gbW91c2luZyBvdmVyIHRoZSBmaWR1Y2lhbCBoaWdobGlnaHRzIChhcyBpZiB0aGUgdXNlciBoYWQgbW91c2VkIG92ZXIgdGhlIGZlYXR1cmUgaXRzZWxmKVxuXHQub24oJ21vdXNlb3ZlcicsIChwKSA9PiB7XG5cdCAgICB0aGlzLmhpZ2hsaWdodChwWzBdKTtcblx0fSlcblx0Lm9uKCdtb3VzZW91dCcsICAocCkgPT4ge1xuXHQgICAgdGhpcy5oaWdobGlnaHQoKTtcblx0fSk7XG5cdC8vXG5cdHBnb25zLmV4aXQoKS5yZW1vdmUoKTtcblx0Ly8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXHQvLyBEcmF3IGZlYXR1cmUgbGFiZWxzLiBFYWNoIGxhYmVsIGlzIGRyYXduIG9uY2UsIGFib3ZlIHRoZSBmaXJzdCByZWN0YW5nbGUgaW4gaXRzIGxpc3QuXG5cdC8vIFRoZSBleGNlcHRpb24gaXMgdGhlIGN1cnJlbnQgKG1vdXNlb3ZlcikgZmVhdHVyZSwgd2hlcmUgdGhlIGxhYmVsIGlzIGRyYXduIGFib3ZlIHRoYXQgZmVhdHVyZS5cblx0bGV0IGxhYmVscyA9IGZmR3Jwcy5zZWxlY3RBbGwoJ3RleHQuZmVhdExhYmVsJylcblx0ICAgIC5kYXRhKGQgPT4ge1xuXHRcdGxldCByID0gZC5yZWN0c1swXVswXTtcblx0XHRpZiAoY3VyckZlYXQgJiYgKGQuZmlkID09PSBjdXJyRmVhdC5JRCB8fCBkLmZpZCA9PT0gY3VyckZlYXQuY2Fub25pY2FsKSl7XG5cdFx0ICAgIGxldCByMiA9IGQucmVjdHMubWFwKCByciA9PlxuXHRcdCAgICAgICByclswXS5fX2RhdGFfXyA9PT0gY3VyckZlYXQgPyByclswXSA6IHJyWzFdJiZyclsxXS5fX2RhdGFfXyA9PT0gY3VyckZlYXQgPyByclsxXSA6IG51bGxcblx0XHQgICAgICAgKS5maWx0ZXIoeD0+eClbMF07XG5cdFx0ICAgIHIgPSByMiA/IHIyIDogcjtcblx0XHR9XG5cdCAgICAgICAgcmV0dXJuIFt7XG5cdFx0ICAgIGZpZDogZC5maWQsXG5cdFx0ICAgIHJlY3Q6IHIsXG5cdFx0ICAgIHRyZWN0OiBjb29yZHNBZnRlclRyYW5zZm9ybShyKVxuXHRcdH1dO1xuXHQgICAgfSk7XG5cblx0Ly8gRHJhdyB0aGUgdGV4dC5cblx0bGFiZWxzLmVudGVyKCkuYXBwZW5kKCd0ZXh0JykuYXR0cignY2xhc3MnLCdmZWF0TGFiZWwnKTtcblx0bGFiZWxzLmV4aXQoKS5yZW1vdmUoKTtcblx0bGFiZWxzXG5cdCAgLmF0dHIoJ3gnLCBkID0+IGQudHJlY3QueCArIGQudHJlY3Qud2lkdGgvMiApXG5cdCAgLmF0dHIoJ3knLCBkID0+IGQucmVjdC5fX2RhdGFfXy5nZW5vbWUuem9vbVkrMTUpXG5cdCAgLnRleHQoZCA9PiB7XG5cdCAgICAgICBsZXQgZiA9IGQucmVjdC5fX2RhdGFfXztcblx0ICAgICAgIGxldCBzeW0gPSBmLnN5bWJvbCB8fCBmLklEO1xuXHQgICAgICAgcmV0dXJuIHN5bTtcblx0ICB9KTtcblxuXHQvLyBQdXQgYSByZWN0YW5nbGUgYmVoaW5kIGVhY2ggbGFiZWwgYXMgYSBiYWNrZ3JvdW5kXG5cdGxldCBsYmxCb3hEYXRhID0gbGFiZWxzLm1hcChsYmwgPT4gbGJsWzBdLmdldEJCb3goKSlcblx0bGV0IGxibEJveGVzID0gZmZHcnBzLnNlbGVjdEFsbCgncmVjdC5mZWF0TGFiZWxCb3gnKVxuXHQgICAgLmRhdGEoKGQsaSkgPT4gW2xibEJveERhdGFbaV1dKTtcblx0bGJsQm94ZXMuZW50ZXIoKS5pbnNlcnQoJ3JlY3QnLCd0ZXh0JykuYXR0cignY2xhc3MnLCdmZWF0TGFiZWxCb3gnKTtcblx0bGJsQm94ZXMuZXhpdCgpLnJlbW92ZSgpO1xuXHRsYmxCb3hlc1xuXHQgICAgLmF0dHIoJ3gnLCAgICAgIGJiID0+IGJiLngtMilcblx0ICAgIC5hdHRyKCd5JywgICAgICBiYiA9PiBiYi55LTEpXG5cdCAgICAuYXR0cignd2lkdGgnLCAgYmIgPT4gYmIud2lkdGgrNClcblx0ICAgIC5hdHRyKCdoZWlnaHQnLCBiYiA9PiBiYi5oZWlnaHQrMilcblx0ICAgIDtcblx0XG5cdC8vIGlmIHRoZXJlIGlzIGEgY3VyckZlYXQsIG1vdmUgaXRzIGZpZHVjaWFscyB0byB0aGUgZW5kIChzbyB0aGV5J3JlIG9uIHRvcCBvZiBldmVyeW9uZSBlbHNlKVxuXHRpZiAoY3VyckZlYXQpIHtcblx0ICAgIC8vIGdldCBsaXN0IG9mIGdyb3VwIGVsZW1lbnRzIGZyb20gdGhlIGQzIHNlbGVjdGlvblxuXHQgICAgbGV0IGZmTGlzdCA9IGZmR3Jwc1swXTtcblx0ICAgIC8vIGZpbmQgdGhlIG9uZSB3aG9zZSBmZWF0dXJlIGlzIGN1cnJGZWF0XG5cdCAgICBsZXQgaSA9IC0xO1xuXHQgICAgZmZMaXN0LmZvckVhY2goIChnLGopID0+IHsgaWYgKGcuX19kYXRhX18uZmlkID09PSBjdXJyRmVhdC5pZCkgaSA9IGo7IH0pO1xuXHQgICAgLy8gaWYgd2UgZm91bmQgaXQgYW5kIGl0J3Mgbm90IGFscmVhZHkgdGhlIGxhc3QsIG1vdmUgaXQgdG8gdGhlXG5cdCAgICAvLyBsYXN0IHBvc2l0aW9uIGFuZCByZW9yZGVyIGluIHRoZSBET00uXG5cdCAgICBpZiAoaSA+PSAwKSB7XG5cdFx0bGV0IGxhc3RpID0gZmZMaXN0Lmxlbmd0aCAtIDE7XG5cdCAgICAgICAgbGV0IHggPSBmZkxpc3RbaV07XG5cdFx0ZmZMaXN0W2ldID0gZmZMaXN0W2xhc3RpXTtcblx0XHRmZkxpc3RbbGFzdGldID0geDtcblx0XHRmZkdycHMub3JkZXIoKTtcblx0ICAgIH1cblx0fVxuXHRcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0IGhpZ2hsaWdodGVkICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGlGZWF0cyA/IE9iamVjdC5rZXlzKHRoaXMuaGlGZWF0cykgOiBbXTtcbiAgICB9XG4gICAgc2V0IGhpZ2hsaWdodGVkIChobHMpIHtcblx0aWYgKHR5cGVvZihobHMpID09PSAnc3RyaW5nJylcblx0ICAgIGhscyA9IFtobHNdO1xuXHQvL1xuXHR0aGlzLmhpRmVhdHMgPSB7fTtcbiAgICAgICAgZm9yKGxldCBoIG9mIGhscyl7XG5cdCAgICB0aGlzLmhpRmVhdHNbaF0gPSBoO1xuXHR9XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldCBmZWF0SGVpZ2h0ICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2ZnLmZlYXRIZWlnaHQ7XG4gICAgfVxuICAgIHNldCBmZWF0SGVpZ2h0IChoKSB7XG4gICAgICAgIHRoaXMuY2ZnLmZlYXRIZWlnaHQgPSBoO1xuXHR0aGlzLmNmZy5sYW5lSGVpZ2h0ID0gdGhpcy5jZmcuZmVhdEhlaWdodCArIHRoaXMuY2ZnLmxhbmVHYXA7XG5cdHRoaXMuY2ZnLmxhbmVIZWlnaHRNaW5vciA9IHRoaXMuY2ZnLmZlYXRIZWlnaHQgKyB0aGlzLmNmZy5sYW5lR2FwTWlub3I7XG5cdHRoaXMuY2ZnLmJsb2NrSGVpZ2h0ID0gdGhpcy5jZmcubGFuZUhlaWdodCAqIHRoaXMuY2ZnLm1pbkxhbmVzICogMjtcblx0dGhpcy51cGRhdGUoKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0IGxhbmVHYXAgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZmcubGFuZUdhcDtcbiAgICB9XG4gICAgc2V0IGxhbmVHYXAgKGcpIHtcbiAgICAgICAgdGhpcy5jZmcubGFuZUdhcCA9IGc7XG5cdHRoaXMuY2ZnLmxhbmVIZWlnaHQgPSB0aGlzLmNmZy5mZWF0SGVpZ2h0ICsgdGhpcy5jZmcubGFuZUdhcDtcblx0dGhpcy5jZmcuYmxvY2tIZWlnaHQgPSB0aGlzLmNmZy5sYW5lSGVpZ2h0ICogdGhpcy5jZmcubWluTGFuZXMgKiAyO1xuXHR0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXQgc3RyaXBHYXAgKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZmcuc3RyaXBHYXA7XG4gICAgfVxuICAgIHNldCBzdHJpcEdhcCAoZykge1xuICAgICAgICB0aGlzLmNmZy5zdHJpcEdhcCA9IGc7XG5cdHRoaXMuY2ZnLnRvcE9mZnNldCA9IGc7XG5cdHRoaXMudXBkYXRlKCk7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIHNob3dGbG9hdGluZ1RleHQgKHRleHQsIHgsIHkpIHtcblx0bGV0IHNyID0gdGhpcy5zdmcubm9kZSgpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHR4ID0geC1zci54LTEyO1xuXHR5ID0geS1zci55O1xuXHRsZXQgYW5jaG9yID0geCA8IDYwID8gJ3N0YXJ0JyA6IHRoaXMud2lkdGgteCA8IDYwID8gJ2VuZCcgOiAnbWlkZGxlJztcblx0dGhpcy5mbG9hdGluZ1RleHQuc2VsZWN0KCd0ZXh0Jylcblx0ICAgIC50ZXh0KHRleHQpXG5cdCAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJyxhbmNob3IpXG5cdCAgICAuYXR0cigneCcsIHgpXG5cdCAgICAuYXR0cigneScsIHkpXG4gICAgfVxuICAgIGhpZGVGbG9hdGluZ1RleHQgKCkge1xuXHR0aGlzLmZsb2F0aW5nVGV4dC5zZWxlY3QoJ3RleHQnKS50ZXh0KCcnKTtcbiAgICB9XG4gICAgLy8tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAgZ2V0IHNob3dGZWF0dXJlRGV0YWlscyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93RmVhdHVyZURldGFpbHM7XG4gICAgfVxuICAgIHNldCBzaG93RmVhdHVyZURldGFpbHMgKHYpIHtcblx0bGV0IHByZXYgPSB0aGlzLnNob3dGZWF0dXJlRGV0YWlscztcbiAgICAgICAgdGhpcy5fc2hvd0ZlYXR1cmVEZXRhaWxzID0gdiA/IHRydWUgOiBmYWxzZTtcblx0dGhpcy5jbGVhckFsbCA9IHByZXYgIT09IHRoaXMuc2hvd0ZlYXR1cmVEZXRhaWxzO1xuXHQvLyBcblx0dGhpcy5yb290LmNsYXNzZWQoJ3Nob3dpbmdBbGxMYWJlbHMnLCB0aGlzLnNob3dpbmdBbGxMYWJlbHMpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXQgc2hvd0FsbExhYmVscyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zaG93QWxsTGFiZWxzO1xuICAgIH1cbiAgICBzZXQgc2hvd0FsbExhYmVscyAodikge1xuICAgICAgICB0aGlzLl9zaG93QWxsTGFiZWxzID0gdiA/IHRydWUgOiBmYWxzZTtcblx0dGhpcy5yb290LmNsYXNzZWQoJ3Nob3dpbmdBbGxMYWJlbHMnLCB0aGlzLnNob3dpbmdBbGxMYWJlbHMpO1xuXHR0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBnZXQgc2hvd2luZ0FsbExhYmVscyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNob3dGZWF0dXJlRGV0YWlscyAmJiB0aGlzLnNob3dBbGxMYWJlbHM7XG4gICAgfVxuICAgIC8vLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgIGdldCBzcHJlYWRUcmFuc2NyaXB0cyAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zcHJlYWRUcmFuc2NyaXB0cztcbiAgICB9XG4gICAgc2V0IHNwcmVhZFRyYW5zY3JpcHRzICh2KSB7XG5cdGxldCBzZWxmID0gdGhpcztcbiAgICAgICAgdGhpcy5fc3ByZWFkVHJhbnNjcmlwdHMgPSB2ID8gdHJ1ZSA6IGZhbHNlO1xuXHR0aGlzLnVwZGF0ZSgpO1xuICAgIH1cbiAgICAvLy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICBoaWRlRmlkdWNpYWxzICgpIHtcblx0dGhpcy5zdmdNYWluLnNlbGVjdCgnZy5maWR1Y2lhbHMnKVxuXHQgICAgLmNsYXNzZWQoJ2hpZGRlbicsIHRydWUpO1xuICAgIH1cbn0gLy8gZW5kIGNsYXNzIFpvb21WaWV3XG5cbmV4cG9ydCB7IFpvb21WaWV3IH07XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3d3dy9qcy9ab29tVmlldy5qc1xuLy8gbW9kdWxlIGlkID0gMjRcbi8vIG1vZHVsZSBjaHVua3MgPSAwIl0sInNvdXJjZVJvb3QiOiIifQ==